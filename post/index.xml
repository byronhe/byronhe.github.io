<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Tech Ideas</title>
    <link>https://blog.helong.info/post/</link>
    <description>Recent content in Posts on Tech Ideas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 20 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.helong.info/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>构造最短程序打印自身的 MD5</title>
      <link>https://blog.helong.info/post/shortest-print-self-md5-contest/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/shortest-print-self-md5-contest/</guid>
      <description>&lt;h2 id=&#34;一介绍&#34;&gt;一，介绍&lt;/h2&gt;
&lt;p&gt;比赛题目很简单：构造一个程序，在 stdout 上打印出自身的 MD5，程序越短越好。按最终程序文件大小字节数排名，文件越小，排名越靠前。
只能使用 ld-linux-x86-64.so, libc.so, libdl.so, libgcc_s.so, libm.so, libstdc++.so 。
禁止了 socket, shmget, fork, execvc 等 syscall 。&lt;/p&gt;
&lt;p&gt;汇编高手如云，本人只做到 752 字节，只拿到 27 名。
但忙活好几天，学到不少东西，也有苦劳，还是值得记录一下。&lt;/p&gt;
&lt;p&gt;基本是纯 C 实现，没有动用汇编。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于 ElasticSearch 开发垂直搜索系统</title>
      <link>https://blog.helong.info/post/elasticsearch-dev-arch/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/elasticsearch-dev-arch/</guid>
      <description>&lt;h2 id=&#34;一背景介绍&#34;&gt;一，背景介绍&lt;/h2&gt;
&lt;p&gt;ElasticSearch 是由 Lucene 包装上分布式复制一致性算法等附加功能，构成的开源搜索引擎系统。&lt;/p&gt;
&lt;p&gt;近两年在业界热度大增，主要有 3 种应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全文搜索引擎&lt;/li&gt;
&lt;li&gt;NOSQL 数据库&lt;/li&gt;
&lt;li&gt;日志分析数据库 ELK&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很多垂直领域搜索需求，都可以基于 ElasticSearch 来设计架构。&lt;/p&gt;
&lt;p&gt;ElasticSearch 能大幅度提升相关业务的迭代开发速度，实现类似 sql 数据库增删改查一样的快速开发。
并在相对高 qps 的在线业务中，保证毫秒级的延迟，提供极高的可用性和稳定性。&lt;/p&gt;
&lt;p&gt;经过持续的研读官方文档，调研业界经验，并在实践中应用反思后，总结出一套架构方案。供参考，欢迎意见建议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎样让 C&#43;&#43; 中 throw exception 产生的 coredump 带上栈</title>
      <link>https://blog.helong.info/post/cpp-throw-coredump-with-backtrace/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/cpp-throw-coredump-with-backtrace/</guid>
      <description>&lt;h1 id=&#34;1-问题&#34;&gt;1. 问题&lt;/h1&gt;
&lt;p&gt;一个 C++ 程序，如果 throw 了 exception ，但是又没有 catch，那么一般会产生 coredump，
问题是，在 gcc 4.x 版本产生的 coredump 文件中，&lt;em&gt;没有 throw 时候的堆栈信息&lt;/em&gt;，导致不知道是哪里 throw 的，没法查问题。&lt;/p&gt;
&lt;p&gt;原因是 gcc 4.x 的 /libstdc++-v3/src/c++11/thread.cc:92 里面有个 catch(&amp;hellip;)，所以 stack unwind 了，就没了 throw 时候的 stack 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;execute_native_thread_routine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;   
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;terminate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://abcdabcd987.com/libstdc++-bug/&#34;&gt;https://abcdabcd987.com/libstdc++-bug/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个解决办法是可以升级 GCC 7 ，或者可以用更简单的办法：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 abstract unix socket 实现进程单实例运行</title>
      <link>https://blog.helong.info/post/2020/03/03/abstract-unix-socket-single-instance/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2020/03/03/abstract-unix-socket-single-instance/</guid>
      <description>&lt;h2 id=&#34;一问题背景&#34;&gt;一，问题背景&lt;/h2&gt;
&lt;p&gt;很多时候，我们需要&lt;strong&gt;确保进程只有一个实例运行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有几种方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux&#34;&gt;http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c&#34;&gt;http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src&#34;&gt;https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比较常规的做法，是对一个文件加文件锁 flock，比如对 pid 文件 flock( LOCK_EX|LOCK_NB )&lt;/p&gt;
&lt;p&gt;但是这种方法有些弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果文件被 mv 或者 rm，是会被绕过的。&lt;/li&gt;
&lt;li&gt;如果磁盘故障比如磁盘满，目录没有写权限，会失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二abstract-namespace-unix-socket&#34;&gt;二，abstract namespace unix socket&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://linux.die.net/man/7/unix&#34;&gt;http://linux.die.net/man/7/unix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;unix socket 有3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于文件的&lt;/li&gt;
&lt;li&gt;socketpair 创建的，匿名的&lt;/li&gt;
&lt;li&gt;abstract namespace 的，Linux特有&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux 下， AF_UNIX socket 支持一种特殊的
abstract namespace unix socket 。&lt;/p&gt;
&lt;p&gt;相比 普通的基于文件系统的 unix socket，abstract namespace unix socket ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有磁盘文件&lt;/li&gt;
&lt;li&gt;进程挂了以后自动删除，无残留文件&lt;/li&gt;
&lt;li&gt;无需担心与 文件系统上的文件冲突，不需要关心文件系统上的绝对路径是否存在的问题&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Python 自动翻译成 C&#43;&#43; ，彻底保证离线在线特征一致</title>
      <link>https://blog.helong.info/post/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/</guid>
      <description>&lt;h1 id=&#34;一问题背景&#34;&gt;一，问题背景&lt;/h1&gt;
&lt;p&gt;随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。&lt;/p&gt;
&lt;p&gt;机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。&lt;/p&gt;
&lt;h3 id=&#34;1常见的特征工程逻辑&#34;&gt;1.常见的特征工程逻辑&lt;/h3&gt;
&lt;p&gt;常见的特征工程逻辑有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分箱/分桶 离散化&lt;/li&gt;
&lt;li&gt;log/exp 对数/幂等 math numpy 常见数学运算&lt;/li&gt;
&lt;li&gt;特征缩放/归一化/截断&lt;/li&gt;
&lt;li&gt;交叉特征生成&lt;/li&gt;
&lt;li&gt;分词匹配程度计算&lt;/li&gt;
&lt;li&gt;字符串分隔匹配判断tong&lt;/li&gt;
&lt;li&gt;缺省值填充等&lt;/li&gt;
&lt;li&gt;数据平滑&lt;/li&gt;
&lt;li&gt;onehot 编码，hash 编码等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些特征工程代码，当然一般使用深度学习最主要的语言 &lt;strong&gt;python&lt;/strong&gt; 实现。&lt;/p&gt;
&lt;h1 id=&#34;二业务痛点&#34;&gt;二，业务痛点&lt;/h1&gt;
&lt;p&gt;离线训练完成，模型上线部署后，同样要&lt;strong&gt;用 C++ 重新实现&lt;/strong&gt; 这些 python 的特征工程逻辑代码。&lt;/p&gt;
&lt;p&gt;我们发现，&lt;strong&gt;“用 C++ 重新实现”&lt;/strong&gt; 这个步骤，给实际业务带来了大量的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;繁琐，费时费力，极容易出现 python 和 C++ 代码&lt;strong&gt;不一致&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不一致&lt;/strong&gt;会直接影响模型在线上的效果，导致大盘业务指标不如预期，产生各种 bad case&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不一致&lt;/strong&gt;难以发现，无法测试，无法监控，经常要靠用户投诉反馈，甚至大盘数据异常才能发现&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗</title>
      <link>https://blog.helong.info/post/2019/11/25/cppjieba-darts-DAT-memory_optimize/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2019/11/25/cppjieba-darts-DAT-memory_optimize/</guid>
      <description>&lt;h2 id=&#34;一问题背景&#34;&gt;一，问题背景&lt;/h2&gt;
&lt;p&gt;中文分词应用比较广泛的开源算法，是 &lt;a href=&#34;https://github.com/fxsjy/jieba&#34;&gt;jieba 结巴分词&lt;/a&gt;，结巴分词较高性能的实现是 C++ 版本的 CppJieba :
&lt;a href=&#34;https://github.com/yanyiwu/cppjieba&#34;&gt;https://github.com/yanyiwu/cppjieba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在实际使用 CppJieba 的过程中，我们发现 CppJieba 的内存占用比较高。&lt;/p&gt;
&lt;p&gt;比如对一个 76W 词 大小 11MB 的词典 ，加载 2份 （比如为了支持平滑改动用户词典）就需要耗费 505MB内存。&lt;/p&gt;
&lt;p&gt;这对一些多进程的后台服务，浪费大量内存，难以接受，因此这里希望削减内存耗费。&lt;/p&gt;
&lt;p&gt;经过初步调查，确定改进方法，然后动手改造，&lt;strong&gt;最终把 505MB 缩减到了 4.7MB ，实现了 99% 内存降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此处也有 issue 讨论 &lt;a href=&#34;https://github.com/yanyiwu/cppjieba/issues/3&#34;&gt;https://github.com/yanyiwu/cppjieba/issues/3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码稍后可能会开源出来。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GB 规模语料上的高性能新词发现算法</title>
      <link>https://blog.helong.info/post/2019/09/18/newwords_discovery/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2019/09/18/newwords_discovery/</guid>
      <description>&lt;p&gt;分词是中文搜索的重要环节，目前分词算法已经比较成熟，分词错误的主要是由于未登录词。&lt;/p&gt;
&lt;p&gt;因此发现业务领域语料库中的新词，减少未登录词，对改善搜索引擎的用户体验有重要意义。&lt;/p&gt;
&lt;p&gt;新词发现的一种常用算法，是 matrix67 大神 2012 年提出的 《互联网时代的社会语言学：基于SNS的文本数据挖掘》
&lt;a href=&#34;https://www.matrix67.com/blog/archives/5044&#34;&gt;https://www.matrix67.com/blog/archives/5044&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要思路，是统计语料中出现的所有 ngram 子字符串的凝固度，自由度，信息熵。&lt;/p&gt;
&lt;p&gt;算法中需要统计所有 ngram 子字符串的 左熵右熵，实现该算法时，一般以子字符串为 key，用哈希表来存。&lt;/p&gt;
&lt;p&gt;但随着语料库变大时，内存消耗变大，&lt;/p&gt;
&lt;p&gt;比如之前的 python 版本实现，对 200MB 的语料，就需要约 30G 内存来存哈希表，&lt;/p&gt;
&lt;p&gt;导致单机内存不足无法运行，而且对这样规模的语料库，算法需要跑一两天才能出结果。&lt;/p&gt;
&lt;p&gt;这里我应用一些工程实现方面的技巧，
把用哈希表统计左熵右熵的计算，拆分成多个子哈希表，分批计算，并利用多核并行，大幅度优化了算法的性能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Proxygen http2 代码分析</title>
      <link>https://blog.helong.info/post/Proxygen-http2-code-analysis/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/Proxygen-http2-code-analysis/</guid>
      <description>&lt;p&gt;Proxygen 的整体架构
&lt;img src=&#34;https://raw.githubusercontent.com/facebook/proxygen/master/CoreProxygenArchitecture.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个 HTTPSession 对应一个 tcp 连接。&lt;/p&gt;
&lt;p&gt;HTTPSession 中包含HTTPCodec ，HTTPCodec用来在 HTTPMessage(Request/Response) 和 字节流之间做转换（就是解析/序列化）。&lt;/p&gt;
&lt;p&gt;一个 HTTPTransaction 对应一个 HTTP2  的Stream ，也就是一次 Req/Resp
Handler 是业务逻辑处理的基类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TrafficServer http2 代码分析</title>
      <link>https://blog.helong.info/post/TrafficServer-http2-code-analysis/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/TrafficServer-http2-code-analysis/</guid>
      <description>&lt;p&gt;TrafficServer 是Apache基金会的 HTTP/HTTP2 代理服务器。&lt;/p&gt;
&lt;p&gt;TrafficServer 的 HTTP2 部分主要的代码在 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;trafficserver/proxy/http2/HTTP2.h, HTTP2.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/Http2Stream.h, Http2Stream.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/Http2ClientSession.h, Http2ClientSession.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/Http2ConnectionState.h, Http2ConnectionState.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/ Http2DependencyTree.h, Http2DependencyTree.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/HPACK.h, HPACK.cc&lt;/li&gt;
&lt;li&gt;trafficserver/proxy/http2/HuffmanCodec.h, HuffmanCodec.cc&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>TLS协议分析 与 现代加密通信协议设计</title>
      <link>https://blog.helong.info/post/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/</link>
      <pubDate>Sun, 06 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/</guid>
      <description>&lt;p&gt;最近发现密码学很有意思，刚好还和工作有点关系，就研究了一下，本文是其中一部分笔记和一些思考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文禁止转载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习鉴赏TLS协议的设计，透彻理解原理和重点细节&lt;/li&gt;
&lt;li&gt;跟进一下密码学应用领域的历史和进展&lt;/li&gt;
&lt;li&gt;整理现代加密通信协议设计的一般思路&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文有门槛，读者需要对现代密码学有清晰而系统的理解，建议花精力补足背景知识再读。本文最后的参考文献里有一些很不错的学习资料。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux LoadAvg 编程比赛</title>
      <link>https://blog.helong.info/post/2015/08/13/linux-loadavg-competation/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/08/13/linux-loadavg-competation/</guid>
      <description>&lt;h2 id=&#34;问题背景&#34;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://timyang.net/programming/load-average/&#34;&gt;https://timyang.net/programming/load-average/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2015.08.13 高可用架构群 Load 编程比赛，Tim 在群征集一段代码使 load average 最高&lt;/p&gt;
&lt;p&gt;多线程写几个 while 循环的方法太 trivial 了，就不提了。&lt;/p&gt;
&lt;p&gt;下面是 byronhe 的两个解：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>现代密码学实践指南[2015年]</title>
      <link>https://blog.helong.info/post/2015/06/05/modern-crypto/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/06/05/modern-crypto/</guid>
      <description>&lt;p&gt;本文介绍目前现代密码学的最先进技术，
前半部分主要翻译自  &lt;a href=&#34;https://gist.github.com/tqbf/be58d2d39690c3b366ad&#34;&gt;《Cryptographic Right Answers》&lt;/a&gt;，附上收集的资料，和byron个人的理解。&lt;/p&gt;
&lt;p&gt;密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;下文分类介绍在各种适用场景下你应该使用的现代密码学算法&#34;&gt;下文分类介绍在各种适用场景下，你应该使用的现代密码学算法&lt;/h5&gt;
&lt;h3 id=&#34;1--加密数据-&#34;&gt;1.  &lt;strong&gt;加密数据&lt;/strong&gt; :&lt;/h3&gt;
&lt;p&gt;按照优先级，应该选择:&lt;/p&gt;
&lt;p&gt;(1)   首选 NaCl库，或者libsodium库，使用里面的crypto_secretbox()/crypto_secretbox_open() 函数
(2)   Chacha20-Poly1305 算法
(3)   AES-GCM 算法&lt;/p&gt;
&lt;p&gt;适用场景:当你需要避免把明文数据在网络上传输的时候。&lt;/p&gt;
&lt;p&gt;以上3种算法，都是AEAD类的算法，AEAD是2015年最好的选择。
其中的(2)和(3)在结构上类似：一个流加密模式的算法，配合一个多项式结构的MAC。
(2)是一个流加密算法，配合一个为通用cpu优化的MAC算法，
对密码学库的实现者来说，Poly1305也比GCM更容易安全地实现。
AES-GCM是工业标准(TLS目前主要用的就是AES-GCM)，现代CPU通常都有专门为AES-GCM设计的硬件指令，但是在没有硬件指令支持的CPU上(比如32位的arm)，(3)性能低于(2)。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nginx下配置高性能，高安全性的https TLS服务</title>
      <link>https://blog.helong.info/post/2015/05/08/https-config-optimize-in-nginx/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/05/08/https-config-optimize-in-nginx/</guid>
      <description>&lt;p&gt;下文以nginx为例，介绍如何部署一个高性能，高安全性的https服务器。&lt;/p&gt;
&lt;p&gt;并附送一个优化出来的openssl编译脚本，可以编译出一个高性能，高安全性的openssl库，您可以直接复制粘贴使用。&lt;/p&gt;
&lt;p&gt;此处直接给出实践指导，后续再写文章解释tls协议的这些原理细节。&lt;/p&gt;
&lt;p&gt;nginx下https配置的优化点，主要有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;session ticket&lt;/li&gt;
&lt;li&gt;session id cache&lt;/li&gt;
&lt;li&gt;ocsp stapling&lt;/li&gt;
&lt;li&gt;http KeepAlive&lt;/li&gt;
&lt;li&gt;ECDHE等ciphersuite优化&lt;/li&gt;
&lt;li&gt;openssl 编译优化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;一-nginx-https的配置&#34;&gt;一， nginx https的配置&lt;/h3&gt;
&lt;p&gt;先贴一下nginx配置，如下。&lt;/p&gt;
&lt;p&gt;是根据&lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx&#34;&gt;mozilla的权威文档&lt;/a&gt;
,和&lt;a href=&#34;https://mozilla.github.io/server-side-tls/ssl-config-generator/&#34;&gt;生成工具&lt;/a&gt;(选择 nginx，intermediate ) 生成的配置为基础，加入session ticket等配置的结果&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【翻译】密码学一小时必知</title>
      <link>https://blog.helong.info/post/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour/</link>
      <pubDate>Sun, 12 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour/</guid>
      <description>&lt;p&gt;本文翻译了Colin Percival 于2010年在bsdcan的演讲ppt&lt;/p&gt;
&lt;p&gt;原文标题：Everything you need to know about cryptography in 1 hour&lt;/p&gt;
&lt;p&gt;演讲时间：May 13, 2010&lt;/p&gt;
&lt;p&gt;原文在 &lt;a href=&#34;https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf&#34;&gt;https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;演讲视频在 &lt;a href=&#34;https://www.youtube.com/watch?v=jzY3m5Kv7Y8&#34;&gt;https://www.youtube.com/watch?v=jzY3m5Kv7Y8&lt;/a&gt; ( 请自行翻墙 )&lt;/p&gt;
&lt;p&gt;Colin Percival 是密码学方面的专家，FreeBSD项目的安全长官，Tarsnap在线备份服务的创始人，scrypt密钥衍生算法的作者，致力于改进软件中密码学的应用，向程序员传播密码学的正确使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【翻译/介绍】jump consistent hash 零内存消耗，均匀，快速，简洁，来自Google的一致性哈希算法</title>
      <link>https://blog.helong.info/post/2015/03/13/jump_consistent_hash/</link>
      <pubDate>Fri, 13 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/03/13/jump_consistent_hash/</guid>
      <description>&lt;h2 id=&#34;一简介&#34;&gt;一，简介&lt;/h2&gt;
&lt;p&gt;jump consistent hash是一种一致性哈希算法, 此算法&lt;strong&gt;零内存消耗&lt;/strong&gt;，&lt;strong&gt;均匀分配&lt;/strong&gt;，&lt;strong&gt;快速&lt;/strong&gt;，并且&lt;strong&gt;只有5行代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此算法适合使用在分shard的分布式存储系统中 。&lt;/p&gt;
&lt;p&gt;此算法的作者是 Google 的 John Lamping 和 Eric Veach，论文原文在 &lt;a href=&#34;http://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf&#34;&gt;http://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    
    &lt;span class=&#34;kt&#34;&gt;int32_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;JumpConsistentHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2862933555777941757ULL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1LL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;31&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;33&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输入是一个64位的key，和桶的数量（一般对应服务器的数量），输出是一个桶的编号。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SSL/TLS CipherSuite 介绍</title>
      <link>https://blog.helong.info/post/2015/01/23/ssl_tls_ciphersuite_intro/</link>
      <pubDate>Fri, 23 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2015/01/23/ssl_tls_ciphersuite_intro/</guid>
      <description>&lt;p&gt;本文是关于SSL/TLS的 CipherSuite 的信息摘录，翻译。如有疑问，欢迎指出。&lt;/p&gt;
&lt;h2 id=&#34;一ciphersuite的概念&#34;&gt;一，CipherSuite的概念&lt;/h2&gt;
&lt;p&gt;CipherSuite 这个名词目前没看到有好的中文翻译，个人觉得翻译成“加密算法套件”比较合适。Cipher泛指是密码学的加密算法，例如 aes, rsa, ecdh 等。
tls是由各类基础算法，作为原语组合而成。
一个CipherSuite是4个算法的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1个authentication (认证)算法 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1个encryption(加密)算法
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1个message authentication code (消息认证码 简称MAC)算法 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;1 个key exchange(密钥交换)算法
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>mock C&#43;&#43; function for unit test</title>
      <link>https://blog.helong.info/post/2014/03/27/mock-c-plus-plus-function-for-unit-test/</link>
      <pubDate>Thu, 27 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2014/03/27/mock-c-plus-plus-function-for-unit-test/</guid>
      <description>&lt;p&gt;在单元测试中，我们需要提供业务逻辑的mock版本，
当业务逻辑实现为C++的virtual function时，这是很容易的，我们只需要写一个子类，
实现virtual function就行了，Google 的 gmock就针对这种情况设计。&lt;/p&gt;
&lt;p&gt;可是，如果遗留代码中有一般C函数，非virtual的类成员函数，模板函数，inline函数，如何提供mock版本呢？&lt;/p&gt;
&lt;p&gt;下面的代码用一点trick实现了上述函数的运行时mock。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>博客迁移到octopress</title>
      <link>https://blog.helong.info/post/2014/03/24/move-to-octopress/</link>
      <pubDate>Mon, 24 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2014/03/24/move-to-octopress/</guid>
      <description>wordpress的编辑器混淆了 结构 和 表现 而markdown，类似latex，结构和表现分离，更符合我的偏好。 在vim里面写博客，更能激起人</description>
    </item>
    
    <item>
      <title>一个使用KuaiPan备份linux服务器的脚本</title>
      <link>https://blog.helong.info/post/2014/02/08/kuaipan-backup-script/</link>
      <pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2014/02/08/kuaipan-backup-script/</guid>
      <description>近日需要给服务器做备份，在网上找到了一个现成的金山快盘的api：https://github.com/deren/python-kuaipa</description>
    </item>
    
    <item>
      <title>a http proxy script</title>
      <link>https://blog.helong.info/post/2013/11/18/a-http-proxy-script/</link>
      <pubDate>Mon, 18 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2013/11/18/a-http-proxy-script/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #!/usr/local/bin/python # -*- coding: utf-8 -*- import base64 import select import socket import httplib</description>
    </item>
    
    <item>
      <title>libpcap试玩</title>
      <link>https://blog.helong.info/post/2013/08/04/libpcap-sniffer/</link>
      <pubDate>Sun, 04 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2013/08/04/libpcap-sniffer/</guid>
      <description>&lt;p&gt;libpcap驱动了tcpdump,和wireshark这类抓包工具.提供了高度灵活的包过滤语言. 据wikipedia,高性能的包过滤最早是在bsd上作为一个问题被解决,被称为bpf,在内核实现了一个解释器,进行包匹配,用户态提供一个字符设备, linux作为后来者,支持与bsd基本相同的packet filter,称为lpf,不同的是,linux是通过在一个raw socket来支持包过滤的,通过setsockopt来SO_ATTACH_FILTER,挂载过滤器. strace 可知,libpcap实际上进行了如下syscall:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;socket(PF_PACKET, SOCK_RAW, 768) = 59 
setsockopt(59, SOL_SOCKET, SO_ATTACH_FILTER, &amp;#34;\1\0\0\0\0\0\0\0\250\327Vc\375\177\0\0&amp;#34;, 16) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;libpcap的api文档和demo代码可以参见&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tcpdump.org/pcap3_man.html&#34;&gt;http://www.tcpdump.org/pcap3_man.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tcpdump.org/sniffex.c&#34;&gt;http://www.tcpdump.org/sniffex.c&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考文档了demo,我写了一个小的sniffer,&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开始写博客</title>
      <link>https://blog.helong.info/post/2013/07/11/begin-blog/</link>
      <pubDate>Thu, 11 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2013/07/11/begin-blog/</guid>
      <description>我开始在这写博客了。 这个博客专注在技术方面，C++，Linux，等等，务求原创，务求深度。 可能还会有一些文字。 早于此的，是从cnblogs上</description>
    </item>
    
    <item>
      <title>圆形坠落模拟算法设计</title>
      <link>https://blog.helong.info/post/2012/07/25/simulate-object-falling/</link>
      <pubDate>Wed, 25 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2012/07/25/simulate-object-falling/</guid>
      <description>&lt;p&gt;目标：实现一个算法，模拟在一个封闭二维区域，圆形小球朝给定方向坠落的过程，实现二维区域的紧密填充。&lt;/p&gt;
&lt;p&gt;像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.helong.info/images/2012072600504753.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;难点，及其简单解决：&lt;/p&gt;
&lt;p&gt;1.如何把粒子移动尽可能远？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.helong.info/images/2012072601011361.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中的粒子i，能往下移动多远？一般情况,碰撞？边界？&lt;/p&gt;
&lt;p&gt;一个简单解法：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[翻译]轻松7步，导出Y结合子</title>
      <link>https://blog.helong.info/post/2012/04/09/translation-Y-conbinator-in-seven-steps/</link>
      <pubDate>Mon, 09 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2012/04/09/translation-Y-conbinator-in-seven-steps/</guid>
      <description>&lt;p&gt;本文译自 “&lt;em&gt;Deriving the Y Combinator in 7 Easy Steps&lt;/em&gt;“，&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;http://igstan.ro/posts/2010-12-01-deriving-the-y-combinator-in-7-easy-steps.html&#34;&gt;http://igstan.ro/posts/2010-12-01-deriving-the-y-combinator-in-7-easy-steps.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在没有原生递归支持的语言中，Y结合子（&lt;a href=&#34;http://en.wikipedia.org/wiki/Fixed_point_combinator&#34;&gt;Y Combinator&lt;/a&gt;）是一种实现递归的方式（事实上，它更常被作为一种锻炼程序思维的方式）。要实现Y结合子，要求这种语言支持匿名函数。&lt;/p&gt;
&lt;p&gt;此处，我选择JavaScript来推导Y结合子，从递归阶乘函数的定义开始，一步一步进行变换。&lt;/p&gt;
&lt;h2 id=&#34;step-1&#34;&gt;Step 1&lt;/h2&gt;
&lt;p&gt;最初的实现，使用JavaScript内建的递归机制。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fact&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&#34;step-2&#34;&gt;Step 2&lt;/h2&gt;
&lt;p&gt;获得递归的最简单方法是什么？我们可以定义一个函数，它接受它自身作为参数，并且用这个参数作为参数，调用这个参数。当然，这是一个无限循环，会导致栈溢出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;})(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们的阶乘函数套用上面的模板，再做点改动，阶乘函数接受一个我们还不知道的参数，所以我们要的是返回一个接受该参数的函数。然后这个函数可以被用于计算阶乘。同时，这可以让我们的阶乘函数不会无限循环下去。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fact&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 终止条件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;//因为f返回一个函数，所以这有一个双重调用。 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;})(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 终止条件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 因为f返回一个函数，所以这有一个双重调用。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>一个基于约束传播的微型计算语言的设计和实现</title>
      <link>https://blog.helong.info/post/2012/04/09/Propagation-of-Constraints-lang-in-py/</link>
      <pubDate>Mon, 09 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2012/04/09/Propagation-of-Constraints-lang-in-py/</guid>
      <description>&lt;p&gt;一个基于约束传播的，玩具级微型计算语言的设计和简单实现。&lt;/p&gt;
&lt;p&gt;这个程序就是做来玩和练习的，代码是玩具级别的，用的python，基本可以正常工作了。&lt;/p&gt;
&lt;p&gt;先介绍应用背景：&lt;/p&gt;
&lt;p&gt;在流体机械设计中，通常根据性能参数进行设计，算出其它变量，但问题是，在设计过程中，需要进行变量的&lt;strong&gt;手工调整&lt;/strong&gt;，例如圆整，修正到某一范围，校核等等。&lt;/p&gt;
&lt;p&gt;其计算模式举例如下：&lt;/p&gt;
&lt;p&gt;1.定义变量，如输入压力P&lt;!-- raw HTML omitted --&gt;in&lt;!-- raw HTML omitted --&gt;=0.98，输入温度T&lt;!-- raw HTML omitted --&gt;in&lt;!-- raw HTML omitted --&gt;=27,输入流量Q&lt;!-- raw HTML omitted --&gt;vin&lt;!-- raw HTML omitted --&gt;=400,k&lt;!-- raw HTML omitted --&gt;v2，&lt;!-- raw HTML omitted --&gt;φ&lt;!-- raw HTML omitted --&gt;2r，&lt;!-- raw HTML omitted --&gt;b2，D2，u2，qin等等。。。&lt;/p&gt;
&lt;p&gt;2.根据某些物理公式，算出几个新的量，如转速 &lt;em&gt;n=33.9*sqrt(k&lt;!-- raw HTML omitted --&gt;v2&lt;!-- raw HTML omitted --&gt;*φ&lt;!-- raw HTML omitted --&gt;2r*&lt;!-- raw HTML omitted --&gt;b2/D2*(u2^3)/qin)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3.把n从8296.93圆整为整数8300，&lt;/p&gt;
&lt;p&gt;4.重新计算b2/D2=0.06455，校核可知0.02&amp;lt;0.06455&amp;lt;0.065，符合要求&lt;/p&gt;
&lt;p&gt;5.根据n计算出其它新的变量，修正，校核。。。&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;p&gt;观察可以发现，这种计算模式，和《计算机程序的构造与解释》中提到的约束传播系统很像，如果把一个变量看作一个对象，那么，当它位于一个公式的左侧，例如n，也就意味着，右侧变量例如k&lt;!-- raw HTML omitted --&gt;v2&lt;!-- raw HTML omitted --&gt;更新时，应该给它发送一个消息，让它重新计算自己的值，当n更新后，如果它发现有别的变量依赖于自己，它应该发消息通知它们更新自己的值。&lt;/p&gt;
&lt;p&gt;还可以看出，这种依赖关系形成了一个图，例如应该有一条从k&lt;!-- raw HTML omitted --&gt;v2&lt;!-- raw HTML omitted --&gt;到n的边，把n称为k&lt;!-- raw HTML omitted --&gt;v2&lt;!-- raw HTML omitted --&gt;的订阅者。&lt;/p&gt;
&lt;p&gt;所以这种计算模式可以用约束传播系统建模，但是此处和书里的约束传播系统有差异：此处的约束传播系统是&lt;strong&gt;有向图&lt;/strong&gt;，而书里是无向图，设计成有向图主要是为了简单，无向图的消息发送顺序是难以控制的，而且构造的时候公式中的每个变量都要持有其它对象的引用，太麻烦，有向图只需要在公式左侧的那个变量哪里保存公式右侧的每个变量的引用。&lt;/p&gt;
&lt;p&gt;形成有向图后，每个变量的状态设为invaild，这种状态下，不会向它的会订阅者发送更新消息，收到获取值的消息时报错。&lt;/p&gt;
&lt;p&gt;有向图中，还有一些源点，是最初给定值的变量。&lt;/p&gt;
&lt;p&gt;当某个变量被赋值时，它把自己设为新值，同时向它的订阅者发送更新消息。订阅者计算自己的新值，如果和旧值相同，就沉默；否则，更新自己，通知订阅者更新。&lt;/p&gt;
&lt;p&gt;so，想象一下，在你的面前，虚空之中漂浮着一张有向图， 由k&lt;!-- raw HTML omitted --&gt;v2&lt;!-- raw HTML omitted --&gt;—&amp;gt;n这样的一条条边练成，当一个点被赋予值，从这点荡出一圈圈涟漪，传到它的下一级，再从更新过的点荡出新的波纹，传开，传开。。。直到所有的点都收敛，水面恢复宁静。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>sicp练习2.42 [解8皇后问题的Scheme语言实现]</title>
      <link>https://blog.helong.info/post/2011/12/22/sicp-02.42-eight-queue/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/12/22/sicp-02.42-eight-queue/</guid>
      <description>代码框架来自sicp 练习2.42。算是作业吧。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</description>
    </item>
    
    <item>
      <title>符号求导，scheme实现</title>
      <link>https://blog.helong.info/post/2011/12/22/symbol-deriv/</link>
      <pubDate>Thu, 22 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/12/22/symbol-deriv/</guid>
      <description>sicp练习2.57 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60</description>
    </item>
    
    <item>
      <title>Church计数</title>
      <link>https://blog.helong.info/post/2011/11/20/church-encoding/</link>
      <pubDate>Sun, 20 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/20/church-encoding/</guid>
      <description>my code： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ;Church计数 (define zero (lambda (f) (lambda (x) x))) (define (add-1 n) (lambda (f) (lambda (x) (f ((n</description>
    </item>
    
    <item>
      <title>java多线程网页下载代码</title>
      <link>https://blog.helong.info/post/2011/11/15/java-multithread-download-webpage/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/java-multithread-download-webpage/</guid>
      <description>小项目，练手的。 1.使用了java.util.concurrent包里的线程池，可以飙升到满带宽，在100M带宽上，可以达到10MB/s。 2</description>
    </item>
    
    <item>
      <title>jdbc使用DataSource连接mysql,postgresql,oracle的代码</title>
      <link>https://blog.helong.info/post/2011/11/15/jdbc-DataSource-connect-mysql-pgsql-oracle/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/jdbc-DataSource-connect-mysql-pgsql-oracle/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>【旧代码】2010年用matlab做的几张理想流场的图</title>
      <link>https://blog.helong.info/post/2011/11/15/matlab-flow-field/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/matlab-flow-field/</guid>
      <description>&lt;p&gt;就不贴matlab代码了，图比较大。&lt;/p&gt;
&lt;p&gt;分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无环量流动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有环量流动,两个滞止点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有环量流动,一个滞止点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有环量流动,柱面外一个滞止点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.helong.info/images/2012041000071160.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【旧代码】fortran中的指针实现链表的代码</title>
      <link>https://blog.helong.info/post/2011/11/15/linked-list-in-fortran-with-pointer/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/linked-list-in-fortran-with-pointer/</guid>
      <description>我不喜欢fortran， 奇怪的词法规则（竟然不用空格分开token）， io操作竟然是语言的一部分（这种非本质的东西像C那样用库来扩展多好） 。</description>
    </item>
    
    <item>
      <title>【旧代码】mysql备份的shell脚本</title>
      <link>https://blog.helong.info/post/2011/11/15/mysql-backup-script/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/mysql-backup-script/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/sh bk_to=&amp;#34;/var/mysql-backup-`date +%Y-%m-%d-%k-%M-%S |tr -d &amp;#39; &amp;#39;`&amp;#34; user_name=&amp;#34;root&amp;#34; user_pw=&amp;#34;dev&amp;#34; sql=&amp;#34; flush tables with read lock; system cp -pR /var/lib/mysql $bk_to; unlock tables; &amp;#34; mysql -u $user_name -p$user_pw -e &amp;#34;$sql&amp;#34; echo $sql tar cjf $bk_to.bz2 $bk_to rm -rf $bk_to</description>
    </item>
    
    <item>
      <title>【旧代码】传热过程数值模拟</title>
      <link>https://blog.helong.info/post/2011/11/15/heat-grid/</link>
      <pubDate>Tue, 15 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/15/heat-grid/</guid>
      <description>&lt;p&gt;传热过程数值模拟（《传热学》实验指导书第四部分第一题，第一，第二类边界条件）&lt;/p&gt;
&lt;p&gt;2010年十月写的旧代码。&lt;/p&gt;
&lt;p&gt;第一类边界条件是给定边界温度。&lt;/p&gt;
&lt;p&gt;第二类是对流边界。&lt;/p&gt;
&lt;p&gt;区域都是如下形状的:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt; &lt;span class=&#34;o&#34;&gt;--------------------------------&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                               &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                               &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;                               &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;          &lt;span class=&#34;o&#34;&gt;----------------------&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;     
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;     
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;     
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;     
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;     
&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;---------&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;用C++纯属蛋疼。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>visual studio静态，动态链接库开发工具简单使用</title>
      <link>https://blog.helong.info/post/2011/11/13/visual-studio-static-dynamic-lib-dev-tools-usage/</link>
      <pubDate>Sun, 13 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/11/13/visual-studio-static-dynamic-lib-dev-tools-usage/</guid>
      <description>这是2011年8月份做过的一点实验，查了MSDN等等很多资料，基本搞明白了。 这里我不会使用visual studio的图形界面工具，作为专业人</description>
    </item>
    
    <item>
      <title>递增子序列数目计算的算法</title>
      <link>https://blog.helong.info/post/2011/10/17/inc-sub-seq-count-algo/</link>
      <pubDate>Mon, 17 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/10/17/inc-sub-seq-count-algo/</guid>
      <description>这是前几天笔试时，考场上想出来的算法，但是算了两次都不一样，最后只好蒙了一个选项，悲催！ 问题如下： 给定一个整数序列，例如 4,2,6,3,7,1 ，该序列有多少个递</description>
    </item>
    
    <item>
      <title>找出平面上的特殊无向图中的所有三角形的算法</title>
      <link>https://blog.helong.info/post/2011/08/22/find-uniqPointOfTriangle/</link>
      <pubDate>Mon, 22 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/08/22/find-uniqPointOfTriangle/</guid>
      <description>&lt;p&gt;问题提出背景：在非结构化三角形网格生成过程中，若采用前沿推进法，在推进过程中是不好构造三角形的（而且也没有要），最好在把所有的边都连好以后再找出所有三角形，于是提出了问题：在由三角形构成的平面无向图中如何找出所有三角形？&lt;/p&gt;
&lt;p&gt;网格如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.helong.info/images/2012041000563687.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要注意的是，这个无向图很特殊，&lt;/p&gt;
&lt;p&gt;1.这个图在平面上。&lt;/p&gt;
&lt;p&gt;2.这个图是由三角形构成的（如果不是由三角行构成，那这个网格就没有用处了）。&lt;/p&gt;
&lt;p&gt;我的算法如下，伪代码表示:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;foreach(点 p in所有的点){
    foreach(点 np in p的所有邻居点){
        foreach(点 nnpin np的所有邻居点){
            if(   p,np,nnp三点两两不重合
               &amp;amp;&amp;amp; p,np,nnp三点两两相连
               &amp;amp;&amp;amp; p==uniqPointOfTriangle(p,np,nnp)
               &amp;amp;&amp;amp; uniqPointOf2Points(np,nnp)==np)  ){
                   输出p,np,nnp构成的三角形。
               }
       }
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;算法的关键在于uniqPointOfTriangle( )和uniqPointOf2Points( )这两个函数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Codeblocks配合gfortran作为fortran开发环境的配置方法</title>
      <link>https://blog.helong.info/post/2011/05/12/codeblocks-with-gfortran-for-fortran-dev/</link>
      <pubDate>Thu, 12 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2011/05/12/codeblocks-with-gfortran-for-fortran-dev/</guid>
      <description>（以前在bmy bbs发过一次） 这个方法试过在64位win7和32位winxp上可用。 1，首先安装codeblockes，必须选完全安装（Fu</description>
    </item>
    
    <item>
      <title>一个用inotify监控apache的脚本</title>
      <link>https://blog.helong.info/post/2010/08/29/apache-monitor-inotify-script/</link>
      <pubDate>Sun, 29 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2010/08/29/apache-monitor-inotify-script/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/bin/bash #Author:windydays #Date : 2010/8/29 #用于监控apache，如果退出就自动重启apache，原理是在如果apach</description>
    </item>
    
    <item>
      <title>apache的安全增强配置(使用mod_chroot,mod_security)</title>
      <link>https://blog.helong.info/post/2010/08/17/apache-security-enhancement-using-mod_chroot-mod_security/</link>
      <pubDate>Tue, 17 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>https://blog.helong.info/post/2010/08/17/apache-security-enhancement-using-mod_chroot-mod_security/</guid>
      <description>LAMP环境的一般入侵，大致经过sql注入，上传webshell，本地提权至root，安装rootkit等步骤。 采用如下的配置，mod_ch</description>
    </item>
    
  </channel>
</rss>