<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Search | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/search/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2020-03-03T07:32:19+00:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 自动翻译成 C++ ，彻底保证离线在线特征一致]]></title>
    <link href="https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/"/>
    <updated>2019-11-29T13:54:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h1>一，问题背景</h1>

<p>随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。</p>

<p>机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。</p>

<a name="L1............................"></a>
<h3>1.常见的特征工程逻辑</h3>

<p>常见的特征工程逻辑有：</p>

<ol>
<li>分箱/分桶 离散化</li>
<li>log/exp 对数/幂等 math numpy 常见数学运算</li>
<li>特征缩放/归一化/截断</li>
<li>交叉特征生成</li>
<li>分词匹配程度计算</li>
<li>字符串分隔匹配判断tong</li>
<li>缺省值填充等</li>
<li>数据平滑</li>
<li>onehot 编码，hash 编码等</li>
</ol>


<p>这些特征工程代码，当然一般使用深度学习最主要的语言 <strong>python</strong> 实现。</p>

<a name="L.................."></a>
<h1>二，业务痛点</h1>

<p>离线训练完成，模型上线部署后，同样要<strong>用 C++ 重新实现</strong> 这些 python 的特征工程逻辑代码。</p>

<p>我们发现，<strong>“用 C++ 重新实现”</strong> 这个步骤，给实际业务带来了大量的问题：</p>

<ol>
<li>繁琐，费时费力，极容易出现 python 和 C++ 代码<strong>不一致</strong></li>
<li><strong>不一致</strong>会直接影响模型在线上的效果，导致大盘业务指标不如预期，产生各种 bad case</li>
<li><strong>不一致</strong>难以发现，无法测试，无法监控，经常要靠用户投诉反馈，甚至大盘数据异常才能发现</li>
</ol>


<!--more-->


<a name="L1.............."></a>
<h3>1. 业界方案</h3>

<p>针对这些问题，我调研了这些业界方案：</p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<blockquote><p>“模型线上线下一致性问题对于模型效果非常重要，我们使用特征日志来实时记录特征，保证特征的一致性。这样离线处理的时候会把实时的用户反馈，和特征日志做一个结合生成训练样本，然后更新到模型训练平台上，平台更新之后在推送到线上，这样整个排序形成了一个闭环。”</p></blockquote>

<p>总结起来，有几种思路：</p>

<ol>
<li>在线特征存储起来给离线用</li>
<li>在线 C++ 代码编译成 so 导出给离线用</li>
<li>根据一份配置生成离线和在线代码</li>
<li>提取公共代码，加强代码复用，等软件工程手段，减少不一致</li>
</ol>


<a name="L2...................."></a>
<h3>2. 自动翻译方案</h3>

<a name="L.1........................"></a>
<h4>(1) .已有方案的缺点</h4>

<p>但这些思路都有各种缺点：</p>

<ol>
<li>所有在线请求的所有特征，这个存储量数据量很大</li>
<li>算法改代码需要等待后台开发，降低了算法同学的工作效率</li>
<li>特征处理代码的复杂度转移到配置文件中，不一定能充分表达，而且配置格式增加学习成本</li>
<li>就这边真实离线特征处理代码来看，大部分代码都无法抽取出公共代码做复用。</li>
</ol>


<a name="L.2............"></a>
<h4>(2). 翻译器</h4>

<p>回到问题出发点考虑，显而易见，这个问题归根结底就是需要一个 “ python 到 c++ 的翻译器 ” 。</p>

<p>那其实 “翻译器 Transpiler ” ，和编译器解释器类似，也是个古老的热门话题了，比如 <a href="https://webassembly.org/">WebAssembly</a>, <a href="https://coffeescript.org/">CoffeeScript </a>，<a href="https://www.babeljs.cn/docs/">Babel</a> ,
<a href="https://github.com/google/closure-compiler">Google Closure Compiler</a>，<a href="https://www.netlib.org/f2c/f2c.1">f2c</a></p>

<p>于是一番搜索，发现 python 到 C++ 的翻译器也不少，其中 <a href="https://github.com/serge-sans-paille/pythran">Pythran</a> 是新兴比较热门的开源项目。</p>

<p>于是一番尝试后，借助 pythran，我们实现了：</p>

<ol>
<li>一条命令 <strong>全自动把 Python 翻译成等价 C++</strong></li>
<li>严格等价保证改写，彻底消除不一致</li>
<li><strong>完全去掉重新实现</strong> 这块工作量，后台开发成本降到 0 ，彻底解放生产力</li>
<li>算法同学继续使用纯 python，开发效率无影响，<strong> 无学习成本 </strong></li>
<li>并能推广到其他需要 <strong>python 改写成后台 C++ 代码</strong> 的业务场景，解放生产力</li>
</ol>


<a name="L......pythran................"></a>
<h1>三，pythran 的使用流程</h1>

<a name="L.1........."></a>
<h3>(1). 安装</h3>

<p>一条命令安装：
<code>bash
pip3 install pythran
</code></p>

<a name="L.2.......Python......."></a>
<h3>(2). 写 Python 代码</h3>

<p>下面这个 python demo，是 pythran 官方 demo
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">math</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.matrix_multiply.float.list.list..float.list.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">matrix_multiply</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">):</span>
</span><span class='line'>    <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">)):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
</span><span class='line'>                <span class="n">new_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">m1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">new_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.arc_distance.float....float....float....float...&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">arc_distance</span><span class="p">(</span><span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[])</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">arc_distance</span><span class="p">(</span><span class="n">theta_1</span><span class="p">,</span> <span class="n">phi_1</span><span class="p">,</span> <span class="n">theta_2</span><span class="p">,</span> <span class="n">phi_2</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Calculates</span> <span class="n">the</span> <span class="n">pairwise</span> <span class="n">arc</span> <span class="n">distance</span>
</span><span class='line'>    <span class="n">between</span> <span class="nb">all</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">vector</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">theta_2</span><span class="o">-</span><span class="n">theta_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span>
</span><span class='line'>           <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">phi_2</span><span class="o">-</span><span class="n">phi_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">temp</span><span class="p">))</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">distance_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.dprod.int.list..int.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">dprod</span><span class="p">(</span><span class="nb">int</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">dprod</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">WoW</span><span class="p">,</span> <span class="n">generator</span> <span class="n">expression</span><span class="p">,</span> <span class="nb">zip</span> <span class="ow">and</span> <span class="nb">sum</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.get_age.int..&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">get_age</span><span class="p">(</span><span class="nb">int</span> <span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">get_age</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">20</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">0</span><span class="n">_20</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">25</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">21</span><span class="n">_25</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">30</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">26</span><span class="n">_30</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">35</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">31</span><span class="n">_35</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">40</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">36</span><span class="n">_40</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">45</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">41</span><span class="n">_45</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">50</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">46</span><span class="n">_50</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">50</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">age_x</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c">### (3). Python 转成 C++</span>
</span><span class='line'><span class="err">一条命令完成翻译</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="o">-</span><span class="n">e</span> <span class="n">demo</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">o</span>  <span class="n">demo</span><span class="o">.</span><span class="n">hpp</span>
</span></code></pre></td></tr></table></div></figure></p>

<a name="L.4.......C..............."></a>
<h3>(4). 写 C++ 代码调用</h3>

<p>pythran/pythonic/ 目录下是 python 标准库的 C++ 等价实现，翻译出来的C++ 代码需要 include 这些头文件</p>

<p>写个 C++ 代码调用</p>

<pre><code class="cpp">
#include "demo.hpp"
#include "pythonic/numpy/random/rand.hpp"
#include &lt;iostream&gt;

using std::cout;
using std::endl;

int main() {
  pythonic::types::list&lt;pythonic::types::list&lt;double&gt;&gt; m0 = { {2.0, 3.0},
                                                             {4.0, 5.0} },
                                                       m1 = { {1.0, 2.0},
                                                             {3.0, 4.0} };
  cout &lt;&lt; m0 &lt;&lt; "*" &lt;&lt; m1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::matrix_multiply()(m0, m1) &lt;&lt; endl
       &lt;&lt; endl;

  auto theta_1 = pythonic::numpy::random::rand(3),
       phi_1 = pythonic::numpy::random::rand(3),
       theta_2 = pythonic::numpy::random::rand(3),
       phi_2 = pythonic::numpy::random::rand(3);
  cout &lt;&lt; "arc_distance " &lt;&lt; theta_1 &lt;&lt; "," &lt;&lt; phi_1 &lt;&lt; "," &lt;&lt; theta_2 &lt;&lt; ","
       &lt;&lt; phi_2 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::arc_distance()(theta_1, phi_1, theta_2, phi_2) &lt;&lt; endl
       &lt;&lt; endl;

  pythonic::types::list&lt;int&gt; l0 = {2, 3}, l1 = {4, 5};
  cout &lt;&lt; "dprod " &lt;&lt; l0 &lt;&lt; "," &lt;&lt; l1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::dprod()(l0, l1) &lt;&lt; endl
       &lt;&lt; endl;

  cout &lt;&lt; "get_age 30 = " &lt;&lt; __pythran_demo::get_age()(30) &lt;&lt; endl &lt;&lt; endl;

  return 0;
}
</code></pre>

<a name="L.5..............."></a>
<h3>(5). 编译运行</h3>

<pre><code class="sh">g++ -g -std=c++11 main.cpp -fopenmp -march=native -DUSE_XSIMD -I /usr/local/lib/python3.6/site-packages/pythran/ -o pythran_demo  

./pythran_demo
</code></pre>

<a name="L......pythran..................."></a>
<h1>四，pythran 的功能与特性</h1>

<a name="L.1........."></a>
<h3>(1). 介绍</h3>

<p>按官方定义，Pythran 是一个 AOT (Ahead-Of-Time - 预先编译) 编译器。 给科学计算的 python 加注解后，pythran 可以把 python 代码变成接口相同的原生 python 模块，大幅度提升性能。</p>

<p>并且 pythran 也可以利用 OpenMP 多核和 SIMD 指令集。</p>

<p>支持 python 3 和 Python 2.7 。</p>

<p>pythran 的 manual 挺详细：
<a href="https://pythran.readthedocs.io/en/latest/MANUAL.html">https://pythran.readthedocs.io/en/latest/MANUAL.html</a></p>

<a name="L.2........."></a>
<h3>(2). 功能</h3>

<p>pythran 并不支持完整的python， 只支持 python 语言特性的一个子集:</p>

<ul>
<li>polymorphic functions 多态函数(翻译成 C++ 的泛型模板函数)</li>
<li>lambda</li>
<li>list comprehension  列表推导式</li>
<li>map, reduce 等函数</li>
<li>dictionary, set, list 等数据结构</li>
<li>exceptions 异常</li>
<li>file handling 文件处理</li>
<li>部分 numpy</li>
</ul>


<p>不支持的功能：</p>

<ul>
<li>classes 类</li>
<li>polymorphic variables 可变类型变量</li>
</ul>


<a name="L.3................................."></a>
<h3>(3). 支持的数据类型和函数</h3>

<p>pythran export  可以导出函数和全局变量。
支持导出的数据类型，BNF 定义是：</p>

<pre><code class="antlr">    argument_type = basic_type
                  | (argument_type+)    # this is a tuple
                  | argument_type list    # this is a list
                  | argument_type set    # this is a set
                  | argument_type []+    # this is a ndarray, C-style
                  | argument_type [::]+    # this is a strided ndarray
                  | argument_type [:,...,:]+ # this is a ndarray, Cython style
                  | argument_type [:,...,3]+ # this is a ndarray, some dimension fixed
                  | argument_type:argument_type dict    # this is a dictionary

    basic_type = bool | byte | int | float | str | None | slice
               | uint8 | uint16 | uint32 | uint64 | uintp
               | int8 | int16 | int32 | int64 | intp
               | float32 | float64 | float128
               | complex64 | complex128 | complex256
</code></pre>

<p>可以看到基础类型相当全面，支持各种 整数，浮点数，字符串，复数</p>

<p>复合类型支持 tuple, list, set, dict, numpy.ndarray 等，</p>

<p>对应 C++ 代码的类型实现在  pythran/pythonic/include/types/  下面，可以看到比如 dict 实际就是封装了一下 std::unordered_map
<a href="https://pythran.readthedocs.io/en/latest/SUPPORT.html">https://pythran.readthedocs.io/en/latest/SUPPORT.html</a>
可以看到支持的 python 基础库，其中常用于机器学习的 numpy 支持算比较完善。</p>

<a name="L......pythran................"></a>
<h1>五，pythran 的基本原理</h1>

<p>和常见的编译器/解释器类似， pythran 的架构是分成 3 层：</p>

<ol>
<li>python 代码解析成抽象语法树 AST 。用 python 标准库自带的的 ast 模块实现</li>
<li>代码优化。
 在 AST 上做优化，有多种 transformation pass，比如 deadcode_elimination 死代码消除，loop_full_unrolling  循环展开 等。还有 Function/Module/Node 级别的 Analysis，用来遍历 AST 供 transformation 利用。</li>
<li>后端，实现代码生成。目前有2个后端，Cxx / Python，  Cxx 后端可以把 AST 转成 C++ 代码（ Python 后端用来调试）。</li>
</ol>


<p>目前看起来 ，pythran 还欠缺的：</p>

<ol>
<li>字符串处理能力欠缺，缺少 str.encode()/str.decode() 对 utf8 的支持</li>
<li>缺少正则表达式 regex 支持</li>
<li>缺少 json 支持</li>
</ol>


<p>看文档要自己加也不麻烦，看业务需要可以加。</p>

<a name="L.................."></a>
<h1>六，相关文章</h1>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>numba
<a href="http://numba.pydata.org">http://numba.pydata.org</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗]]></title>
    <link href="https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/"/>
    <updated>2019-11-25T12:34:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>中文分词应用比较广泛的开源算法，是 <a href="https://github.com/fxsjy/jieba">jieba 结巴分词</a>，结巴分词较高性能的实现是 C++ 版本的 CppJieba :
<a href="https://github.com/yanyiwu/cppjieba">https://github.com/yanyiwu/cppjieba</a></p>

<p>在实际使用 CppJieba 的过程中，我们发现 CppJieba 的内存占用比较高。</p>

<p>比如对一个 76W 词 大小 11MB 的词典 ，加载 2份 （比如为了支持平滑改动用户词典）就需要耗费 505MB内存。</p>

<p>这对一些多进程的后台服务，浪费大量内存，难以接受，因此这里希望削减内存耗费。</p>

<p>经过初步调查，确定改进方法，然后动手改造，<strong>最终把 505MB 缩减到了 4.7MB ，实现了 99% 内存降低</strong>。</p>

<p>此处也有 issue 讨论 <a href="https://github.com/yanyiwu/cppjieba/issues/3">https://github.com/yanyiwu/cppjieba/issues/3</a></p>

<p>代码稍后可能会开源出来。</p>

<!--more-->


<a name="L.................."></a>
<h2>二，实现过程</h2>

<a name="L....1................."></a>
<h3>二.1  查内存分布</h3>

<p>第一步先用 jemalloc 的 memory profiler 工具查看内存耗费在哪里，</p>

<ol>
<li>改一下 CppJieba  的  test/demo.cpp， 链接 jemalloc，编译成二进制  jieba_test</li>
<li>然后设置环境变量
 <code>export MALLOC_CONF="prof:true,prof_prefix:mem_prof/mem_profile_je.out,lg_prof_interval:20,lg_prof_sample:20"</code></li>
<li>然后  mkdir mem_prof， 并运行测试程序</li>
<li>jeprof &ndash;pdf ./jieba_test mem_prof/mem_profile_je.out.xxx.heap > mem_profile.pdf</li>
</ol>


<p>打开 mem_profile.pdf ，就可以看到内存分布了</p>

<a name="L....2............."></a>
<h3>二.2 优化方案</h3>

<p>显而易见，内存主要耗费在:
1. Trie.hpp 中的 Trie 树构建
2. KeywordExtractor.hpp 加载  idf 词典文件。</p>

<p>因此方案:</p>

<a name="L1..Double.Array.Trie.........cppjieba::Trie"></a>
<h4>1. Double Array Trie 代替  cppjieba::Trie</h4>

<p>引入 Double Array Trie  (简称  DAT ,<a href="https://github.com/s-yata/darts-clone">https://github.com/s-yata/darts-clone</a>) , 代替 Trie.hpp 中的简单内存 Trie，并把 darts 生成的  DAT 保存到文件中，在启动时，如果已经有和词典对应的 DAT ，直接 mmap() attach 上去，即可启动。</p>

<p>经过实测发现，75万词词典，dart-clone 生成的 DAT 文件，大小只有 24MB，而且可以 mmap 挂载，多进程共享。</p>

<a name="L2..KeywordExtractor"></a>
<h4>2. KeywordExtractor</h4>

<p>KeywordExtractor 是个不常用功能，直接改成支持传入空的 idfPath 和 stopWordPath, 此时不加载数据即可。</p>

<a name="L....3............."></a>
<h3>二.3 其他问题</h3>

<a name="L1...................................DAT......"></a>
<h4>1. 支持热更新，保证词典和DAT一致</h4>

<p>这里一个问题是，词典可能热更新，那怎么知道 DAT 文件和当前词典的内容对应？</p>

<p>我的做法是，对 默认词典文件+自定义词典文件，用文件内容算 MD5，写入 DAT 文件头部，这样打开 DAT 文件发现 MD5 不一致，就知道 DAT文件过时了，即可重建 DAT 。</p>

<p>实测发现算 MD5 还是很快的，启动时间都在 1秒 左右。</p>

<a name="L2.............."></a>
<h4>2. 代码清理</h4>

<p>另外，清理了一下代码，删掉了 Unicode.hpp 中的无用代码。
清理了 FullSegment.hpp HMMSegment.hpp MixSegment.hpp MPSegment.hpp QuerySegment.hpp 等中的重复代码。</p>

<a name="L3................."></a>
<h4>3. 不兼容改动</h4>

<ul>
<li>由于 Double Array Trie 无法支持动态插入词，删除 InsertUserWord() 方法</li>
<li>FullSegment.hpp 中 maxId 的计算有 bug，做了 fix。</li>
</ul>


<p>整体改造后，代码量比原来减少 100 多行。</p>

<p>上线后效果显著。</p>

<p>当内存降低到 2-3MB 的水平后，这意味着 75W 词这种规模的大词典，可以用在手机环境。</p>

<p>比如可以在 ios 或者 Android 上做 中文/英文的切词，
这意味着可能在客户端实现体验相当良好的搜索引擎。</p>

<p>ios 上也有可用于中文的分词器 <a href="https://developer.apple.com/documentation/corefoundation/cfstringtokenizer-rf8">CFStringTokenizer</a> ，但貌似不开源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GB 规模语料上的高性能新词发现算法]]></title>
    <link href="https://blog.helong.info//blog/2019/09/18/newwords_discovery/"/>
    <updated>2019-09-18T22:19:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/09/18/newwords_discovery</id>
    <content type="html"><![CDATA[<hr />

<p>分词是中文搜索的重要环节，目前分词算法已经比较成熟，分词错误的主要是由于未登录词。</p>

<p>因此发现业务领域语料库中的新词，减少未登录词，对改善搜索引擎的用户体验有重要意义。</p>

<p>新词发现的一种常用算法，是 matrix67 大神 2012 年提出的 《互联网时代的社会语言学：基于SNS的文本数据挖掘》
<a href="https://www.matrix67.com/blog/archives/5044">https://www.matrix67.com/blog/archives/5044</a></p>

<p>其主要思路，是统计语料中出现的所有 ngram 子字符串的凝固度，自由度，信息熵。</p>

<p>算法中需要统计所有 ngram 子字符串的 左熵右熵，实现该算法时，一般以子字符串为 key，用哈希表来存。</p>

<p>但随着语料库变大时，内存消耗变大，</p>

<p>比如之前的 python 版本实现，对 200MB 的语料，就需要约 30G 内存来存哈希表，</p>

<p>导致单机内存不足无法运行，而且对这样规模的语料库，算法需要跑一两天才能出结果。</p>

<p>这里我应用一些工程实现方面的技巧，
把用哈希表统计左熵右熵的计算，拆分成多个子哈希表，分批计算，并利用多核并行，大幅度优化了算法的性能。</p>

<p>最终实现了 GB 大小语料上的新词发现，并把运行时间缩减到了 30 分钟左右 。</p>

<p><a href="https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB">https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB</a></p>
]]></content>
  </entry>
  
</feed>
