<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm Design | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/algorithm-design/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2019-09-22T21:40:25+08:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[圆形坠落模拟算法设计]]></title>
    <link href="https://blog.helong.info//2012/07/25/%e5%9c%86%e5%bd%a2%e5%9d%a0%e8%90%bd%e6%a8%a1%e6%8b%9f%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1/"/>
    <updated>2012-07-25T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2012/07/25/%e5%9c%86%e5%bd%a2%e5%9d%a0%e8%90%bd%e6%a8%a1%e6%8b%9f%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1</id>
    <content type="html"><![CDATA[<p>目标：实现一个算法，模拟在一个封闭二维区域，圆形小球朝给定方向坠落的过程，实现二维区域的紧密填充。</p>

<p>像下面这样：</p>

<p><img src="/images/blog/2012072600504753.png"></p>

<p>难点，及其简单解决：</p>

<p>1.如何把粒子移动尽可能远？</p>

<p><img src="/images/blog/2012072601011361.png"></p>

<p>图中的粒子i，能往下移动多远？一般情况,碰撞？边界？</p>

<p>一个简单解法：</p>

<!--more-->


<p>注意如下事实：判断两个粒子是否重叠，判断粒子是否和边 界线重叠，都是十分容易的。</p>

<p>据此定义函数 f &reg; 如下</p>

<p><img src="/images/blog/2012072601024742.png"></p>

<p>考虑把粒子往前推的过程，最开始 f &reg; = 1，当推进到一个临界值后，f &reg; = 0,</p>

<p>因此，f &reg; 的函数图像是：</p>

<p><img src="/images/blog/2012072601032995.png"></p>

<p>代码如下：</p>

<pre><code class="cpp">//找出一个点，在一个方向上最远可以前进多远，限于一步之内，该点可以不属于这个mesh，如果不能前进，返回false
bool most_advance(Point* p,double direc_x,double direc_y,Mesh *mesh,double &amp;x,double &amp;y,double &amp;best){
        //二分法求根。
        if(!(p-&gt;can_move))
                return false;
        double low_radio=0.0;
        double high_radio=1.0;//mesh-&gt;x_num + mesh-&gt;y_num;
        best=low_radio;
        bool at_least_one_success=false;
        double mid;
        double step=mesh-&gt;get_step();
        Point new_point;
        while(fabs(low_radio-high_radio)&gt;0.000001){
                mid=(low_radio+high_radio)/2;
                new_point.x=p-&gt;x + direc_x * step * mid;
                new_point.y=p-&gt;y + direc_y * step * mid;
                bool result=mesh-&gt;can_move_point(p,new_point);
                if(result){
                        low_radio=mid;
                        best=max(best,mid);
                        at_least_one_success=true;
                }else{
                        high_radio=mid;
                }
                //cout&lt;&lt;"mid="&lt;&lt;mid&lt;&lt;" best="&lt;&lt;best&lt;&lt;" result="&lt;&lt;result&lt;&lt;endl;
        }

        if(!at_least_one_success)
                return false;

        x=p-&gt;x + direc_x * step * best;
        y=p-&gt;y + direc_y * step * best;
        return true;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[递增子序列数目计算的算法]]></title>
    <link href="https://blog.helong.info//2011/10/17/%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97%e6%95%b0%e7%9b%ae%e8%ae%a1%e7%ae%97%e7%9a%84%e7%ae%97%e6%b3%95/"/>
    <updated>2011-10-17T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2011/10/17/%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97%e6%95%b0%e7%9b%ae%e8%ae%a1%e7%ae%97%e7%9a%84%e7%ae%97%e6%b3%95</id>
    <content type="html"><![CDATA[<p>这是前几天笔试时，考场上想出来的算法，但是算了两次都不一样，最后只好蒙了一个选项，悲催！</p>

<p>问题如下：</p>

<p>给定一个整数序列，例如 4,2,6,3,7,1  ，该序列有多少个递增子序列？</p>

<p>我的算法如下：</p>

<p>记第i个元素为arr[i] ，记以第i个元素结尾的递增子序列有N[i]个，</p>

<p>则，考虑以第i+1个元素结尾的所有递增子序列，
```</p>

<p>首先置N[i+1]=1;//表示只有第i+1个元素一个元素的子序列。</p>

<p>对j=1&hellip;i</p>

<pre><code>       如果arr[j]&lt;arr[i+1]

              N[i+1]+=N[j]
</code></pre>

<p>```
最后结果等于N数组里所有元素之和。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[找出平面上的特殊无向图中的所有三角形的算法]]></title>
    <link href="https://blog.helong.info//2011/08/22/%e6%89%be%e5%87%ba%e5%b9%b3%e9%9d%a2%e4%b8%8a%e7%9a%84%e7%89%b9%e6%ae%8a%e6%97%a0%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e4%b8%89%e8%a7%92%e5%bd%a2%e7%9a%84%e7%ae%97%e6%b3%95/"/>
    <updated>2011-08-22T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2011/08/22/%e6%89%be%e5%87%ba%e5%b9%b3%e9%9d%a2%e4%b8%8a%e7%9a%84%e7%89%b9%e6%ae%8a%e6%97%a0%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e4%b8%89%e8%a7%92%e5%bd%a2%e7%9a%84%e7%ae%97%e6%b3%95</id>
    <content type="html"><![CDATA[<p>  问题提出背景：在非结构化三角形网格生成过程中，若采用前沿推进法，在推进过程中是不好构造三角形的（而且也没有要），最好在把所有的边都连好以后再找出所有三角形，于是提出了问题：在由三角形构成的平面无向图中如何找出所有三角形？</p>

<p>网格如图：</p>

<p><img src="/images/blog/2012041000563687.png"></p>

<p>要注意的是，这个无向图很特殊，</p>

<p>1.这个图在平面上。</p>

<p>2.这个图是由三角形构成的（如果不是由三角行构成，那这个网格就没有用处了）。</p>

<p>我的算法如下，伪代码表示:</p>

<pre><code>foreach(点 p in所有的点){
    foreach(点 np in p的所有邻居点){
        foreach(点 nnpin np的所有邻居点){
            if(   p,np,nnp三点两两不重合
               &amp;&amp; p,np,nnp三点两两相连
               &amp;&amp; p==uniqPointOfTriangle(p,np,nnp)
               &amp;&amp; uniqPointOf2Points(np,nnp)==np)  ){
                   输出p,np,nnp构成的三角形。
               }
       }
   }
}
</code></pre>

<p>算法的关键在于uniqPointOfTriangle( )和uniqPointOf2Points( )这两个函数。</p>

<!--more-->


<p>这两个函数的原理相同， uniqPointOfTriangle( )uniqPointOf2Points（）唯一的作用是</p>

<p>它的一个性质：    输出和输入参数的顺序无关。</p>

<p>如果没有这两个函数的判断，每个三角形会被输出6次，而有了这两个函数的限制后，强制在3个元素的6中排列中指定1种，</p>

<p>就消除了重复。</p>

<p>uniqPointOfTriangle的实现我想了一个邪恶的办法:</p>

<pre><code class="cpp">struct point * uniqPointOfTriangle(struct point * a,struct point * b ,struct point * c){
        /*返回一个3个点的特征点，即不管a,b,c的次序，这个函数返回结果唯一*/
        struct point * p=NULL;

        //我直接比较指针大小，O(∩_∩)O哈哈~
        p=(a &gt; b?a:b);
        return p &gt; c?p:c;
}
</code></pre>

<p>还有一种正常一点的办法：</p>

<p>思路是：对三个点，先在x方向找出最小的点，若有一个，直接返回；若有两个，找出y方向小的那个返回。</p>

<p>另外，这样输出的三角形中其内部可能有其他的点，若要消除，再加上一层过滤，去除掉那些&#8221;p有邻点在p,np,nnp三角形中的&#8221;情况即可，</p>

<p>这是因为这个图由三角形构成的特殊性质，如果有在p&#8211;np&#8211;nnp中有点，假设这些点都不和p相连，那么，</p>

<p>这些点和p-np, p-nnp构成的区域必然不是三角形！所以可以这样干。</p>
]]></content>
  </entry>
  
</feed>
