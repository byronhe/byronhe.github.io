<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Server | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/server/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2019-11-25T13:49:41+08:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗]]></title>
    <link href="https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/"/>
    <updated>2019-11-25T12:34:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>中文分词应用比较广泛的开源算法，是 <a href="https://github.com/fxsjy/jieba">jieba 结巴分词</a>，结巴分词较高性能的实现是 C++ 版本的 CppJieba :
<a href="https://github.com/yanyiwu/cppjieba">https://github.com/yanyiwu/cppjieba</a></p>

<p>在实际使用 CppJieba 的过程中，我们发现 CppJieba 的内存占用比较高。</p>

<p>比如对一个 76W 词 大小 11MB 的词典 ，加载 2份 （比如为了支持平滑改动用户词典）就需要耗费 505MB内存。</p>

<p>这对一些多进程的后台服务，浪费大量内存，难以接受，因此这里希望削减内存耗费。</p>

<p>经过初步调查，确定改进方法，然后动手改造，<strong>最终把 505MB 缩减到了 4.7MB ，实现了 99% 内存降低</strong>。</p>

<p>此处也有 issue 讨论 <a href="https://github.com/yanyiwu/cppjieba/issues/3">https://github.com/yanyiwu/cppjieba/issues/3</a></p>

<p>代码稍后可能会开源出来。</p>

<!--more-->


<a name="L.................."></a>
<h2>二，实现过程</h2>

<a name="L....1................."></a>
<h3>二.1  查内存分布</h3>

<p>第一步先用 jemalloc 的 memory profiler 工具查看内存耗费在哪里，</p>

<ol>
<li>改一下 CppJieba  的  test/demo.cpp， 链接 jemalloc，编译成二进制  jieba_test</li>
<li>然后设置环境变量
 <code>export MALLOC_CONF="prof:true,prof_prefix:mem_prof/mem_profile_je.out,lg_prof_interval:20,lg_prof_sample:20"</code></li>
<li>然后  mkdir mem_prof， 并运行测试程序</li>
<li>jeprof &ndash;pdf ./jieba_test mem_prof/mem_profile_je.out.xxx.heap > mem_profile.pdf</li>
</ol>


<p>打开 mem_profile.pdf ，就可以看到内存分布了</p>

<a name="L....2............."></a>
<h3>二.2 优化方案</h3>

<p>显而易见，内存主要耗费在:
1. Trie.hpp 中的 Trie 树构建
2. KeywordExtractor.hpp 加载  idf 词典文件。</p>

<p>因此方案:</p>

<a name="L1..Double.Array.Trie.........cppjieba::Trie"></a>
<h4>1. Double Array Trie 代替  cppjieba::Trie</h4>

<p>引入 Double Array Trie  (简称  DAT ,<a href="https://github.com/s-yata/darts-clone">https://github.com/s-yata/darts-clone</a>) , 代替 Trie.hpp 中的简单内存 Trie，并把 darts 生成的  DAT 保存到文件中，在启动时，如果已经有和词典对应的 DAT ，直接 mmap() attach 上去，即可启动。</p>

<p>经过实测发现，75万词词典，dart-clone 生成的 DAT 文件，大小只有 24MB，而且可以 mmap 挂载，多进程共享。</p>

<a name="L2..KeywordExtractor"></a>
<h4>2. KeywordExtractor</h4>

<p>KeywordExtractor 是个不常用功能，直接改成支持传入空的 idfPath 和 stopWordPath, 此时不加载数据即可。</p>

<a name="L....3............."></a>
<h3>二.3 其他问题</h3>

<a name="L1...................................DAT......"></a>
<h4>1. 支持热更新，保证词典和DAT一致</h4>

<p>这里一个问题是，词典可能热更新，那怎么知道 DAT 文件和当前词典的内容对应？</p>

<p>我的做法是，对 默认词典文件+自定义词典文件，用文件内容算 MD5，写入 DAT 文件头部，这样打开 DAT 文件发现 MD5 不一致，就知道 DAT文件过时了，即可重建 DAT 。</p>

<p>实测发现算 MD5 还是很快的，启动时间都在 1秒 左右。</p>

<a name="L2.............."></a>
<h4>2. 代码清理</h4>

<p>另外，清理了一下代码，删掉了 Unicode.hpp 中的无用代码。
清理了 FullSegment.hpp HMMSegment.hpp MixSegment.hpp MPSegment.hpp QuerySegment.hpp 等中的重复代码。</p>

<a name="L3................."></a>
<h4>3. 不兼容改动</h4>

<ul>
<li>由于 Double Array Trie 无法支持动态插入词，删除 InsertUserWord() 方法</li>
<li>FullSegment.hpp 中 maxId 的计算有 bug，做了 fix。</li>
</ul>


<p>整体改造后，代码量比原来减少 100 多行。</p>

<p>上线后效果显著。</p>

<p>当内存降低到 2-3MB 的水平后，这意味着 75W 词这种规模的大词典，可以用在手机环境。</p>

<p>比如可以在 ios 或者 Android 上做 中文/英文的切词，
这意味着可能在客户端实现体验相当良好的搜索引擎。</p>

<p>ios 上也有可用于中文的分词器 <a href="https://developer.apple.com/documentation/corefoundation/cfstringtokenizer-rf8">CFStringTokenizer</a> ，但貌似不开源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GB 规模语料上的高性能新词发现算法]]></title>
    <link href="https://blog.helong.info//blog/2019/09/18/newwords_discovery/"/>
    <updated>2019-09-18T22:19:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/09/18/newwords_discovery</id>
    <content type="html"><![CDATA[<hr />

<p>分词是中文搜索的重要环节，目前分词算法已经比较成熟，分词错误的主要是由于未登录词。</p>

<p>因此发现业务领域语料库中的新词，减少未登录词，对改善搜索引擎的用户体验有重要意义。</p>

<p>新词发现的一种常用算法，是 matrix67 大神 2012 年提出的 《互联网时代的社会语言学：基于SNS的文本数据挖掘》
<a href="https://www.matrix67.com/blog/archives/5044">https://www.matrix67.com/blog/archives/5044</a></p>

<p>其主要思路，是统计语料中出现的所有 ngram 子字符串的凝固度，自由度，信息熵。</p>

<p>算法中需要统计所有 ngram 子字符串的 左熵右熵，实现该算法时，一般以子字符串为 key，用哈希表来存。</p>

<p>但随着语料库变大时，内存消耗变大，</p>

<p>比如之前的 python 版本实现，对 200MB 的语料，就需要约 30G 内存来存哈希表，</p>

<p>导致单机内存不足无法运行，而且对这样规模的语料库，算法需要跑一两天才能出结果。</p>

<p>这里我应用一些工程实现方面的技巧，
把用哈希表统计左熵右熵的计算，拆分成多个子哈希表，分批计算，并利用多核并行，大幅度优化了算法的性能。</p>

<p>最终实现了 GB 大小语料上的新词发现，并把运行时间缩减到了 30 分钟左右 。</p>

<p><a href="https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB">https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[现代密码学实践指南[2015年]]]></title>
    <link href="https://blog.helong.info//blog/2015/06/05/modern-crypto/"/>
    <updated>2015-06-05T22:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/06/05/modern-crypto</id>
    <content type="html"><![CDATA[<hr />

<p>本文介绍目前现代密码学的最先进技术，
前半部分主要翻译自  <a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad">《Cryptographic Right Answers》</a>，附上收集的资料，和byron个人的理解。</p>

<p>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</p>

<hr />

<a name="L...................................................................................."></a>
<h5>下文分类介绍在各种适用场景下，你应该使用的现代密码学算法</h5>

<a name="L1....strong...............strong..:"></a>
<h3>1.  <strong>加密数据</strong> :</h3>

<p>按照优先级，应该选择:</p>

<p>(1)   首选 NaCl库，或者libsodium库，使用里面的crypto_secretbox()/crypto_secretbox_open() 函数
(2)   Chacha20-Poly1305 算法
(3)   AES-GCM 算法</p>

<p>适用场景:当你需要避免把明文数据在网络上传输的时候。</p>

<p>以上3种算法，都是AEAD类的算法，AEAD是2015年最好的选择。
其中的(2)和(3)在结构上类似：一个流加密模式的算法，配合一个多项式结构的MAC。
(2)是一个流加密算法，配合一个为通用cpu优化的MAC算法，
对密码学库的实现者来说，Poly1305也比GCM更容易安全地实现。
AES-GCM是工业标准(TLS目前主要用的就是AES-GCM)，现代CPU通常都有专门为AES-GCM设计的硬件指令，但是在没有硬件指令支持的CPU上(比如32位的arm)，(3)性能低于(2)。</p>

<!--more-->


<p>此外，应该</p>

<ul>
<li>避免AES-CBC(说来话长，后文有解释)</li>
<li>避免AES-CTR</li>
<li>避免64bit块大小的块加密算法&ndash;(说的就是你&ndash;BlowFish)</li>
<li>避免OFB模式</li>
<li>不要使用RC4，RC4已经被攻破</li>
</ul>


<a name="L2....strong.....................strong..:"></a>
<h3>2.  <strong>对称密钥长度</strong> :</h3>

<p>选择使用256bit长度的密钥</p>

<p>适用场景：只要你在使用密码学，你就应该注意<strong>对称密钥长度</strong></p>

<p>请记住：不要把对称加密（如AES）的key长度，和非对称加密(如RSA)的key长度搞混淆了，对称加密的key通常比非对称加密的key短多了。</p>

<p>下表对比了相同安全程度时，不同算法的密钥长度，单位:bit</p>

<table>
<thead>
<tr>
<th> Symmetric</th>
<th>   ECC   </th>
<th>DH/DSA/RSA</th>
</tr>
</thead>
<tbody>
<tr>
<td>   80     </td>
<td>   163   </td>
<td>     1024 </td>
</tr>
<tr>
<td>  112     </td>
<td>   233   </td>
<td>     2048 </td>
</tr>
<tr>
<td>  128     </td>
<td>   283   </td>
<td>     3072 </td>
</tr>
<tr>
<td>  192     </td>
<td>   409   </td>
<td>     7680 </td>
</tr>
<tr>
<td>  256     </td>
<td>   571   </td>
<td>    15360 </td>
</tr>
</tbody>
</table>


<p>此外，应该</p>

<ul>
<li>避免使用巨大key的算法(使用远大于256的key，只能说明使用者没有安全概念)</li>
<li>避免把多个加密算法串联叠加起来使用，这并没有什么卵用</li>
<li>避免128bit以下的key长度(比如，哥们求你别再提DES这种56bit密钥的古董了)</li>
</ul>


<a name="L3....strong...............strong.:"></a>
<h3>3.  <strong>对称签名</strong>:</h3>

<p>应该选择 HMAC 类的算法</p>

<p>适用场景：安全加固一个API，如各种开放API的调用方认证</p>

<p>如果对一个API，你需要做认证(authenticating)，但是不需要做加密(encrypting)，记得千万不要自己发明算法，你自己发明的MAC算法基本都有安全漏洞，如果不信，请Google一下 &ldquo;长度扩展攻击&rdquo;
<a href="http://en.wikipedia.org/wiki/Length_extension_attack">长度扩展攻击</a>
<a href="http://netifera.com/research/flickr_api_signature_forgery.pdf">Flickr的漏洞案例</a></p>

<p>同时，必须要注意的是，要使用一个<strong>常数时间字符串对比算法</strong>（这个地方和码农的常识完全相反，请务必留意）</p>

<p>此外，应该</p>

<ul>
<li>避免自行设计的“带密码的hash”结构，你的设计基本都是有安全漏洞的</li>
<li>避免HMAC-MD5，避免HMAC-SHA1，使用HMAC-SHA256, HMAC-SHA512等</li>
<li>避免复杂的多项式MAC</li>
<li>避免加密hash值的结构</li>
<li>避免CRC</li>
</ul>


<a name="L4....strong.Hashing.HMAC.........strong."></a>
<h3>4.  <strong>Hashing/HMAC 算法</strong></h3>

<p>应该选择<a href="http://en.wikipedia.org/wiki/SHA-2">SHA2</a>类的算法:: SHA-256, SHA-384, SHA-512, SHA-512/256</p>

<p>优先使用 SHA-512/256，SHA-512/256这个算法把 SHA-512 的512bit输出截短到256bit，避开了length extension 攻击。
同时，目前SHA-2是很安全可靠的，你不需要升级到SHA-3.</p>

<p>此外，应该</p>

<ul>
<li>避免SHA-1</li>
<li>避免MD5</li>
<li>避免MD6</li>
</ul>


<a name="L5....strong.......ID..strong."></a>
<h3>5.  <strong>随机ID</strong></h3>

<p>应该使用256 bit的随机值</p>

<p>一定要使用 /dev/urandom，请认准这个</p>

<p>此外，应该</p>

<ul>
<li>避免用户空间的随机数生成器如:havaged,prngs,egd,等</li>
<li>避免/dev/random</li>
</ul>


<a name="L6....strong...............strong."></a>
<h3>6.  <strong>密码处理</strong></h3>

<p>按照优先级顺序,选择：</p>

<ul>
<li>scrypt</li>
<li>bcrypt</li>
<li>如果以上2个都没有，那就用PBKDF2</li>
</ul>


<p>此外，应该</p>

<ul>
<li>避免直接SHA-2</li>
<li>避免直接SHA-1</li>
<li>避免直接MD5</li>
</ul>


<a name="L7....strong..................strong."></a>
<h3>7.  <strong>非对称加密</strong></h3>

<p>应该使用NaCl库</p>

<p>适用场景：当你需要加密消息，发给陌生人，并且对方异步接收消息，做离线解密时。这是一个很窄的应用案例，这种用法有个名字叫<em>电子信封(digital envelope)</em>，典型比如gpg加密文件后发送。</p>

<p>这条是几条之中最难做正确的，不要使用底层的密码学库，比如OpenSSL或者BouncyCastle。</p>

<p>你应该停止使用RSA，并且切换到椭圆曲线类体制，原因是：</p>

<ul>
<li>对RSA的攻击能力的进步 &mdash; 定义在传统质数域上的乘法运算(应用包括DH,DSA,ElGamal等)，要比椭圆曲线域上的乘法运算快得多。这是由于质数域上数域筛法（number field sieve,NFS）的进展，而在椭圆曲线域上，没有NFS这类算法。</li>
<li>RSA (和DH) 或迫使你考虑“向后兼容性”，而椭圆曲线体制没有这种兼容性包袱。TLS最近的几个安全漏洞，部分愿意也是由于这种向后兼容性，导致已经被破解的陈旧算法存在</li>
<li>RSA在一般场景中，都是直接用公钥做非对称加密，这种用法丧失了<strong>前向安全性(Perfect Forward Secrecy)</strong>。而椭圆曲线就不提倡，也很难这样使用，这样你就不会害死自己了。</li>
<li>在椭圆曲线体制下，保证正确性和安全性的重任，主要由密码学家承担，密码学家会提供一组曲线参数，在某一性能水平下，针对安全性和性能做优化。这样程序员不容易误用而害死自己。在RSA体制下，正好相反，程序员必须提供参数来保证正确性和安全性，就算是RSA-OAEP这种很好的设计，程序员也必须知道怎么提供参数，这样程序员很容易搞错。</li>
</ul>


<p>如果你必须使用RSA，一定要使用RSA-OAEP with SHA256，指数使用 65537</p>

<ul>
<li>避免 RSA-PKCS1v15</li>
<li>避免 ElGamal</li>
<li>避免 RSA</li>
</ul>


<a name="L8....strong..................strong."></a>
<h3>8.  <strong>非对称签名</strong></h3>

<p>应该使用NaCl，Ed25519，或者RFC6979</p>

<p>应用场景：如果你在设计一种新的比特币，或者一个给Ruby Gems或者Vagrant imges文件签名的系统，或者数字版权保护系统(DRM)，其中一系列的文件需要离线做认证；
或者你在设计一个加密消息传输层</p>

<p>上一条的内容在此处全部适用。</p>

<p>在10+年做付费软件安全评估的工作经历中，我只有屈指可数的几次，遇到使用RSA-PSS的用户，RSA-PSS是一个学术界的推荐算法。</p>

<p>过去10年，非对称签名最主要的应用场景是比特币，和前向安全的密钥协商（TLS协议里面的ECDHE）。
其中最主要的算法全都是基于椭圆曲线体制的。务必警惕新出现的使用RSA签名的系统，很有可能有问题。</p>

<p>在过去几年中，业界有一种趋势：放弃传统DSA签名，改为难以误用的<strong>确定性签名体制</strong>，其中的EdDSA(不要和ECDSA搞混了喂！)和RFC6979是最好的例子。这种趋势的主要是受到2010年索尼PlayStation 3的 ECDSA私钥被破解事件的影响，在这个案例中，索尼公司的码农错误地把一个随机数重复使用来做ECDSA签名，形成了漏洞，使得破解者据此直接把私钥算出来了。<strong>确定性签名体制</strong>在设计中不再依赖随机数生成器，因此彻底避开此类误用。所以你应该优先使用确定性签名体制。</p>

<ul>
<li>避免RSA-PKCS1v15，避免RSA，避免ECDSA，避免DSA</li>
<li>特别要避免常规的DSA和ECDSA</li>
</ul>


<a name="L9....strong.Diffie-Hellman...............strong."></a>
<h3>9.  <strong>Diffie-Hellman 密钥交换</strong></h3>

<p>应该使用NaCl，Curve25519，或者DH-2048</p>

<p>适用场景:<em>如果你在设计加密消息传输系统，并且无法使用固定对称密码</em></p>

<p>这是很棘手的一条，主要考量如下：</p>

<ul>
<li>如果你能使用NaCl库，那就使用NaCl库。你甚至不需要管NaCl是什么。</li>
<li>如果你能使用一个可信赖的第三方库，那就使用Curve25519，这是一条现代的ECDH曲线，有丰富的开源代码，性能经过高度优化，被彻底地安全分析过。并且Curve25519即将进入TLS 1.3版本标准。</li>
<li>但是绝对不要自己实现Curve25519，也绝对不要自己移植Curve25519的C代码</li>
<li>如果你不能使用第三方ECDH库，但是可以使用DH库，那就使用DH-2048，使用1个标准的2048 bit的群。</li>
<li>但是不要使用传统的DH，如果你需要协商DH参数，或者和其他实现互操作</li>
<li>如果你一定要做握手协商，或者和旧软件互操作，那么考虑使用NIST P-256, NIST P-256 有广泛的软件支持。</li>
<li>写死在代码里的DH-2048参数，比NIST P-256更安全。NIST P-256比协商出来的DH更安全。</li>
<li>但是，由于NIST P-256的实现有一些陷阱，所以一定要谨慎选择可信赖的，广泛使用使的第三方库</li>
<li>P-256 可能是NIST曲线中最安全的，不要使用P-224。</li>
</ul>


<p>DH（密钥协商）算法确实很难用，但是它很重要。</p>

<ul>
<li>避免，传统常规的 DH, SRP, J-PAKE 握手和协商</li>
<li>避开任何只使用了块加密算法和srand(time())的密钥协商模式（肯定有漏洞）</li>
</ul>


<a name="L10....strong...............strong."></a>
<h3>10.  <strong>网站安全</strong></h3>

<p>应该使用OpenSSL，或者Google的BoringSSL，或者直接使用 AWS的 ELB</p>

<p>此处网站安全，指的是让网站支持HTTPS协议。
如果你不能把这个任务交给Amazon的云服务去做，把难题留给Amazon去解决，那么OpenSSL目前仍然是正确选择。</p>

<ul>
<li>避免不常见的TLS库，例如polarssl，GnuTLS，MatrixSSL等</li>
</ul>


<a name="L11....strong..........-.........................................strong...."></a>
<h3>11.  <strong>客户端-服务器结构的应用程序的安全</strong>：</h3>

<p>应该使用TLS</p>

<p>适用场景：如果你以为自己理解了前面关于公钥加密的介绍。。。</p>

<p>通常，在你设计了自己的RSA协议之后的1至18个月，你肯定会发现，你犯了某个错误，使你的协议没有任何安全性。
比如Salt Stack，Salt Stack的协议使用了 e=1 的RSA 公钥。。。</p>

<p>听起来，TLS有下面这些黑历史：</p>

<ul>
<li>The Logjam DH negotiation attack</li>
<li>The FREAK export cipher attack</li>
<li>The POODLE CBC oracle attack</li>
<li>The RC4 fiasco</li>
<li>The CRIME compression attack</li>
<li>The Lucky13 CBC padding oracle timing attack</li>
<li>The BEAST CBC chained IV attack</li>
<li>Heartbleed</li>
<li>Renegotiation</li>
<li>Triple Handshakes</li>
<li>Compromised CAs</li>
</ul>


<p>但是，你仍然应该使用TLS做传输协议，因为：</p>

<ul>
<li>这些漏洞中的大部分，仅仅是针对浏览器的，因为他们依赖受害者执行攻击者控制的JavaScript脚本，这些JavaScript脚本生成重复的明文，或特定的明文。</li>
<li>这些漏洞中的大部分，其影响都可以被减轻，只需要你在代码和配置里面写死 TLS v1.2, ECDHE，和 AES-GCM就行。这听起来很棘手，但是这远远没有你自己设计使用ECDHE和AES-GCM的传输协议棘手。</li>
<li><p>在一个自定义的传输协议的场景中，你并不需要依赖CA，你可以用一个自签名证书，嵌入到你的客户端里面。</p></li>
<li><p>不要自己设计加密传输协议，这是<strong>极其困难而易错的工程难题</strong></p></li>
<li>使用TLS，但是不要使用默认配置</li>
</ul>


<a name="L12....strong...............strong."></a>
<h3>12.  <strong>在线备份</strong></h3>

<p>应该使用Tarsnap</p>

<hr />

<a name="L............"></a>
<h1>名词解释</h1>

<p>本文的内容比较新，相关中文资料极少，因此文中的名词对读者可能有点陌生，故byron这里介绍一下文中提到的一些名词：</p>

<a name="L1...NaCl...:"></a>
<h3>1.  NaCl库:</h3>

<p><a href="http://nacl.cr.yp.to/">http://nacl.cr.yp.to/</a>
是密码学学术权威 Daniel J. Bernstein教授 设计的一个密码学算法库，2008年发开始公布。NaCl的特点是：api简洁而易用，高性能，高安全性，主要用于网络通信，加密，解密，签名等，NaCl提供了构建高层密码学工具的核心功能。</p>

<a name="L2...libsodium...:"></a>
<h3>2.  libsodium库:</h3>

<p><a href="https://download.libsodium.org/doc/">https://download.libsodium.org/doc/</a>
libsodium是对NaCl库的一个分支，进一步改进接口易用性，和可移植性。</p>

<a name="L3...AEAD:"></a>
<h3>3.  AEAD:</h3>

<p><a href="https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html">https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html</a>
AEAD的概念:
在通常的密码学应用中，Confidentiality  (保密) 用加密实现，Message authentication (消息认证) 用MAC实现。这两种算法的配合方式，引发了很多安全漏洞，过去曾经有3种方法：1. Encrypt-and-MAC  2.MAC-then-Encrypt 3.Encrypt-then-MAC ，后来发现，1和2都是有安全问题的，所以，2008年起，
逐渐提出了“用一个算法在内部同时实现cipher+MAC”的idea，称为AEAD(Authenticated encryption with additional data)。
在AEAD这种概念里，cipher+MAC 被 一个AEAD算法替换。
<a href="http://en.wikipedia.org/wiki/Authenticated_encryption">http://en.wikipedia.org/wiki/Authenticated_encryption</a></p>

<a name="L4...ChaCha20-poly1305"></a>
<h3>4.  ChaCha20-poly1305</h3>

<p>ChaCha20-poly1305是一种AEAD，提出者是Daniel J. Bernstein教授，针对移动互联网优化，目前Google对移动客户端的所有流量都使用ChaCha20-Poly1305</p>

<a name="L5...AES-GCM"></a>
<h3>5.  AES-GCM</h3>

<p>AES-GCM是一种AEAD，是目前TLS的主力算法，互联网上https流量的大部分依赖使用AES-GCM。</p>

<a name="L6...AES-GCM...ChaCha20-Poly1305...........................:"></a>
<h3>6.  AES-GCM和ChaCha20-Poly1305的性能对比测试结果:</h3>

<table>
<thead>
<tr>
<th> Chip  </th>
<th style="text-align:center;"> AES-128-GCM speed </th>
<th style="text-align:center;"> ChaCha20-Poly1305 speed   </th>
</tr>
</thead>
<tbody>
<tr>
<td> OMAP 4460 </td>
<td style="text-align:center;"> 24.1 MB/s     </td>
<td style="text-align:center;"> 75.3 MB/s </td>
</tr>
<tr>
<td> Snapdragon S4 Pro </td>
<td style="text-align:center;">41.5 MB/s  </td>
<td style="text-align:center;">   130.9 MB/s  </td>
</tr>
<tr>
<td> Sandy Bridge Xeon (AESNI) </td>
<td style="text-align:center;">900 MB/s   </td>
<td style="text-align:center;">   500 MB/s    </td>
</tr>
</tbody>
</table>


<a name="L7...AES-CBC"></a>
<h3>7.  AES-CBC</h3>

<p>关于AES-CBC，在AES-GCM流行之前，TLS主要依赖AES-CBC，而由于历史原因，TLS在设计之初固定选择了MAC-then-Encrypt结构，AES-CBC和MAC-then-encrypt结合，为选择密文攻击(CCA)创造了便利条件，TLS历史上有多个漏洞都和CBC模式有关：</p>

<ul>
<li>The POODLE CBC oracle attack:参考:
<a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">1.POODLE的一个分析</a>
<a href="https://www.openssl.org/~bodo/tls-cbc.txt">2.openssl的分析</a>
<a href="http://drops.wooyun.org/papers/3194">3.乌云的文章</a></li>
<li>The CRIME compression attack:</li>
<li>The Lucky13 CBC padding oracle timing attack:</li>
<li>The BEAST CBC chained IV attack:</li>
</ul>


<a name="L8...SHA2"></a>
<h3>8.  SHA2</h3>

<p><a href="http://en.wikipedia.org/wiki/SHA-2">http://en.wikipedia.org/wiki/SHA-2</a></p>

<a name="L9...Curve25519"></a>
<h3>9.  Curve25519</h3>

<p><a href="http://cr.yp.to/ecdh.html">http://cr.yp.to/ecdh.html</a>
Curve25519 是目前最高水平的 Diffie-Hellman函数，适用于广泛的场景，由Daniel J. Bernstein教授设计。由于NIST P-256的设计过程不透明，有来历不明的参数，被广泛怀疑有后门，所以设计了Curve25519，Curve25519的设计过程完全公开，没有任何来历不明的参数。
部署情况：<a href="http://ianix.com/pub/curve25519-deployment.html">http://ianix.com/pub/curve25519-deployment.html</a></p>

<a name="L10...Ed25519"></a>
<h3>10.  Ed25519</h3>

<p><a href="http://ed25519.cr.yp.to/">http://ed25519.cr.yp.to/</a>
Ed25519是一个数字签名算法，</p>

<ul>
<li>签名和验证的性能都极高， 一个4核2.4GHz 的 Westmere cpu，每秒可以验证 71000 个签名</li>
<li>安全性极高，等价于RSA约3000-bit</li>
<li>签名过程不依赖随机数生成器，不依赖hash函数的防碰撞性，没有时间通道攻击的问题</li>
<li>并且签名很小，只有64字节，公钥也很小，只有32字节。
部署情况：<a href="http://ianix.com/pub/ed25519-deployment.html">http://ianix.com/pub/ed25519-deployment.html</a></li>
</ul>


<a name="L11.................."></a>
<h3>11.  前向安全性</h3>

<p>前向安全性( Perfect Forward Secrecy )
<a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html</a>
前向安全性指的是，如果攻击者抓取并保存流量，那么将来私钥泄露后，攻击者也无法利用泄露的私钥解密这些流量。</p>

<a name="L12...Diffie-Hellman............."></a>
<h3>12.  Diffie-Hellman 密钥交换</h3>

<p><a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a>
在任何一本密码学教材里面都会重点介绍的</p>

<a name="L13...constant.time.compare"></a>
<h3>13.  constant time compare</h3>

<p>针对Timing attack，<a href="http://en.wikipedia.org/wiki/Timing_attack">http://en.wikipedia.org/wiki/Timing_attack</a> （这种攻击真是脑洞大开！）
当一个算法的运行时间和输入数据有关的时候，可以根据运行时间这一信息，破解出密钥等。
典型的，比如要验证一个对称签名，如果你用了C库里面的memcmp()，那你就会被timing attack方式攻击。
因此，涉及到密码学数据的memcmp，必须要用运行时间和输入无关的函数，比如OpenSSL库里面的<code>CRYPTO_memcmp()</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx下配置高性能，高安全性的https TLS服务]]></title>
    <link href="https://blog.helong.info//blog/2015/05/08/https-config-optimize-in-nginx/"/>
    <updated>2015-05-08T20:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/05/08/https-config-optimize-in-nginx</id>
    <content type="html"><![CDATA[<p>下文以nginx为例，介绍如何部署一个高性能，高安全性的https服务器。</p>

<p>并附送一个优化出来的openssl编译脚本，可以编译出一个高性能，高安全性的openssl库，您可以直接复制粘贴使用。</p>

<p>此处直接给出实践指导，后续再写文章解释tls协议的这些原理细节。</p>

<p>nginx下https配置的优化点，主要有:</p>

<ol>
<li>session ticket</li>
<li>session id cache</li>
<li>ocsp stapling</li>
<li>http KeepAlive</li>
<li>ECDHE等ciphersuite优化</li>
<li>openssl 编译优化</li>
</ol>


<a name="L.......nginx.https........."></a>
<h3>一， nginx https的配置</h3>

<p>先贴一下nginx配置，如下。</p>

<p>是根据<a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx">mozilla的权威文档</a>
,和<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">生成工具</a>(选择 nginx，intermediate ) 生成的配置为基础，加入session ticket等配置的结果</p>

<!--more-->


<pre><code class="c tls_nginx.conf">server {
    listen 443 ssl;

    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
    ssl_certificate /path/to/signed_cert_plus_intermediates;
    ssl_certificate_key /path/to/private_key;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;

    ssl_session_ticket_key /etc/nginx/conf.d/tls_session_ticket.key;
    ssl_session_tickets on;

    keepalive_timeout 75s;

    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
    ssl_dhparam /path/to/dhparam.pem;

    # intermediate configuration. tweak to your needs.
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';
    ssl_prefer_server_ciphers on;

    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
    add_header Strict-Transport-Security max-age=15768000;

    # OCSP Stapling ---
    # fetch OCSP records from URL in ssl_certificate and cache them
    ssl_stapling on;
    ssl_stapling_verify on;

    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
    ssl_trusted_certificate /path/to/signed_cert_plus_intermediates;

    resolver 114.114.114.114;

    ....
}
</code></pre>

<a name="L..............................."></a>
<h3>二， 其中的几个配置项</h3>

<a name="L1...path.to.signed_cert_plus_intermediates"></a>
<h5>1. /path/to/signed_cert_plus_intermediates</h5>

<p>是你的证书链，就是ca签署之后发给你的文件，是一串这样的内容</p>

<pre><code>-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
...
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
</code></pre>

<a name="L2...path.to.private_key"></a>
<h5>2. /path/to/private_key</h5>

<p>是你的私钥，一定要保密，最好chown+chmod限制只有http server可以读取！内容大致是：
<code>
-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----
</code></p>

<a name="L3...path.to.dhparam.pem"></a>
<h5>3. /path/to/dhparam.pem</h5>

<p>是dhe密钥协商的参数，生成方法：</p>

<pre><code>     openssl  dhparam -out dhparam.pem 2048
</code></pre>

<a name="L4...etc.nginx.conf.d.tls_session_ticket.key"></a>
<h5>4. /etc/nginx/conf.d/tls_session_ticket.key</h5>

<p>是用来加解密session ticket的密码文件，这个文件的安全等级应该和私钥一样，最好chmod+chown限制只有http server能读取。 生成方法:</p>

<pre><code>     openssl rand 48 &gt; tls_session_ticket.key
</code></pre>

<p>最好定期（比如2天一次）轮换，配置文件里把新的key文件放在最前面，旧的在下面，如下</p>

<pre><code>    ssl_session_ticket_key current.key;
    ssl_session_ticket_key previous.key;
</code></pre>

<a name="L5..ssl_trusted_certificate..path.to.signed_cert_plus_intermediates"></a>
<h5>5. ssl_trusted_certificate /path/to/signed_cert_plus_intermediates</h5>

<p>ssl_trusted_certificate，是用来验证ocsp响应的各个ca证书+中级证书，和信任的ca根证书列表。当用来验证ocsp响应的时候，应该配置为你的ca根证书+和中级ca证书的列表，此处可以简单和ssl_certificate使用同一个证书列表文件。<br/>
其中当需要使用tls的客户端认证的时候（大多数https server都用不到客户端认证），需要指定信任的ca根证书列表文件, 这个文件在centos里面是/etc/ssl/certs/ca-bundle.trust.crt 这个文件。</p>

<p>配置完成之后，使用ssllabs的这个在线检查工具<a href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a> 做检查，里面提出的警告，都需要改正。</p>

<a name="L........openssl............"></a>
<h3>三，  openssl编译优化</h3>

<p>主流的https server，都是依赖openssl来提供tls协议，openssl本身代码复杂，概念繁多，最近对这方面做了研究，下面是一个深入分析过后的最优化编译配置，可以编译出一个高性能，高安全性的openssl版本，您可以直接复制粘贴使用。</p>

<p>openssl请使用最新的1.0.2a版本，这个版本有intel针对ecdh p256曲线的优化，编译脚本见本文末尾。</p>

<p>编译好之后，需要让nginx使用我们编译的这个openssl库，在centos下，可以用LD_LIBRARY_PATH的办法：</p>

<pre><code>sudo vim /usr/lib/systemd/system/nginx.service
</code></pre>

<p>在其中添加一行Environment，如下：</p>

<pre><code>[Service]
...
Environment=LD_LIBRARY_PATH=/usr/local/bin/openssl-1.0.2a_64_build/lib/
ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf
...
</code></pre>

<p>其中的路径，请自行修改。</p>

<p>还需要创建软连接，解决so库版本号的问题，如下</p>

<pre><code>ln -s libcrypto.so.1.0.0 libcrypto.so.10
ln -s libssl.so.1.0.0 libssl.so.10
</code></pre>

<p>脚本中包含了一个cloudflare的patch，增加chacha20_poly1305 cipher，使用了这个patch之后，可以使用<a href="https://github.com/cloudflare/sslconfig/blob/master/conf">cloudflare的ciphers配置</a></p>

<p><a href="https://github.com/byronhe/modern-crypto-toolbox/blob/master/build_openssl.sh">https://github.com/byronhe/modern-crypto-toolbox/blob/master/build_openssl.sh</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache的安全增强配置(使用mod_chroot,mod_security)]]></title>
    <link href="https://blog.helong.info//2010/08/17/apache%e7%9a%84%e5%ae%89%e5%85%a8%e5%a2%9e%e5%bc%ba%e9%85%8d%e7%bd%ae%e4%bd%bf%e7%94%a8mod_chrootmod_security/"/>
    <updated>2010-08-17T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2010/08/17/apache%e7%9a%84%e5%ae%89%e5%85%a8%e5%a2%9e%e5%bc%ba%e9%85%8d%e7%bd%ae%e4%bd%bf%e7%94%a8mod_chrootmod_security</id>
    <content type="html"><![CDATA[<address>
  <span lang="EN-US"><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">                                                  </span><span style="line-height: 1.714285714; font-size: 1rem;">作者：</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">windydays      </span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">2010/8/17  </span></span>
</address>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">LAMP</span><span style="line-height: 1.714285714; font-size: 1rem;">环境的一般入侵，大致经过</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">sql</span><span style="line-height: 1.714285714; font-size: 1rem;">注入，上传</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">webshell</span><span style="line-height: 1.714285714; font-size: 1rem;">，本地提权至</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">root</span><span style="line-height: 1.714285714; font-size: 1rem;">，安装</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">rootkit</span><span style="line-height: 1.714285714; font-size: 1rem;">等步骤。采用如下的配置，</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">mod_chroot</span><span style="line-height: 1.714285714; font-size: 1rem;">和单独分区挂载可以让本地提权变得极为困难，而</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">mod-security</span><span style="line-height: 1.714285714; font-size: 1rem;">可以封堵一般的</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">sql</span><span style="line-height: 1.714285714; font-size: 1rem;">注入等应用层攻击。</span></p>

<p>以下内容是在<span lang="EN-US">ubuntu10.04</span>上实践以后总结出来的<span lang="EN-US">,</span>直接上命令，就不做过多解释了，水平有限，错误在所难免，欢迎指正。</p>

<p>首先确保<span lang="EN-US">apache,php,mysql</span>已经正常工作<span lang="EN-US">,</span>出现问题的话，查看<span lang="EN-US">/var/log/apache2,</span><span lang="EN-US">/var/log/syslog,/var/log/mysql/error.log ,</span>尤其是<span lang="EN-US">apparmor</span>导致的权限错误，不易发现。</p>

<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">1.mod_chroot</span><span style="line-height: 1.714285714; font-size: 1rem;">的安装，配置</span>目标是<span lang="EN-US">chroot</span>到<span lang="EN-US">/var/www</span>。</p>

<p><span lang="EN-US">(1) </span>安装<span lang="EN-US">:</span></p>

<pre class="lang:sh decode:true">sudo service apache2 stop
sudo apt-get libapache2-mod-chroot
sudo vi /etc/apache2/mod-available/mod_chroot.conf</pre>


<p><span style="line-height: 1.714285714; font-size: 1rem;">内容为</span></p>

<pre class="lang:xhtml decode:true">&lt;IfModulemod_chroot.c&gt;
    LoadFile /lib/libgcc_s.so.1
    ChrootDir /var/www
&lt;/IfModule&gt;</pre>




<pre class="lang:sh decode:true">sudo a2enmod mod_chroot</pre>


<p><span lang="EN-US">/etc/apache2/site-enabled/000-default </span>中 <span lang="EN-US">DocumentRoot </span>改为 <span lang="EN-US">/</span><span lang="EN-US">          </span></p>

<pre class="lang:sh decode:true">sudo ln -s /var/www/var/run/apache2.pid /var/run/apache2.pid</pre>


<p><span lang="EN-US"> </span>并把<span lang="EN-US">                    </span></p>

<pre class="lang:sh decode:true"> ln -s /var/www/var/run/apache2.pid /var/run/apache2.pid</pre>


<p>加到<span lang="EN-US">/etc/rc.local</span>中</p>

<!--more-->


<pre class="lang:sh decode:true">sudo mkdir /var/www/tmp #放session
sudo chmod 1777tmp
sudo mkdir -p /var/www/var/run/mysqld
sudo ln -s / /var/www/var/www</pre>


<p>&nbsp;</p>

<p><span style="line-height: 1.714285714; font-size: 1rem;">安装好</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">apache,</span><span style="line-height: 1.714285714; font-size: 1rem;">静态页面和</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">php</span><span style="line-height: 1.714285714; font-size: 1rem;">正常后，弄</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">mysql</span></p>

<p><span lang="EN-US">1),</span></p>

<pre class="lang:sh decode:true">sudo service mysql stop</pre>


<p><span lang="EN-US">2).</span>改<span lang="EN-US">/etc/apparmor.d/usr.sbin.mysqld</span>，</p>

<p>把<span lang="EN-US">&#8220;/var/run/mysqld.sock w,&#8221; </span>那一行复制并改为</p>

<pre class="lang:ini decode:true">/var/www/var/run/mysqld.sock w,</pre>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">3),</span><span style="line-height: 1.714285714; font-size: 1rem;">改 </span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">/etc/mysql/my.cnf</span></p>

<p><span lang="EN-US">        </span>在<span lang="EN-US">[client],[mysqld_safe],[mysqld]</span>每一节里<span lang="EN-US">socket</span>路径改为<span lang="EN-US">       </span></p>

<pre class="lang:ini decode:true">socket = /var/www/var/run/mysqld/mysqld.sock</pre>


<p><span lang="EN-US">4),</span></p>

<pre class="lang:sh decode:true">sudo service mysql start</pre>


<p>&nbsp;</p>

<p>&nbsp;</p>

<p>一些其他问题</p>

<p><span lang="EN-US">       date()</span>不正常，解决办法：</p>

<pre class="lang:sh decode:true">sudo mkdir -p /var/www/usr/share /var/www/etc
sudo cp -rp /usr/share/zoneinfo /var/www/usr/share/
sudo cp /etc/localtime/var/www/etc/</pre>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">        DNS</span><span style="line-height: 1.714285714; font-size: 1rem;">可能出问题</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">(</span><span style="line-height: 1.714285714; font-size: 1rem;">没试过</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">)</span></p>

<pre class="lang:sh decode:true">sudo cp /etc/resolv.conf/var/www/etc/resolv.conf</pre>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">        </span><span style="line-height: 1.714285714; font-size: 1rem;">找不到错误页面</span><span lang="EN-US">        </span></p>

<pre class="lang:sh decode:true">sudo cp -rp /usr/share/apache2//var/www/usr/share/</pre>


<p>&nbsp;</p>

<p><span lang="EN-US"> </span></p>

<p><span lang="EN-US">2.mod_security</span>的安装，配置</p>

<p><span lang="EN-US">        </span>安装</p>

<pre class="lang:sh decode:true">sudo aptitude install libapache2-mod-security2
sudo cp/usr/share/doc/mod-security-common/examples/rules/modsecurity_crs_10_config.conf  /etc/apache2/mods-enabled/mod-security.conf
sudo a2enmod mod-security
sudo apache2ctl stop</pre>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">        </span><span style="line-height: 1.714285714; font-size: 1rem;">修改</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">/etc/apache2/mods-available/mod-security.conf</span><span style="line-height: 1.714285714; font-size: 1rem;">中的</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">debug_log</span><span style="line-height: 1.714285714; font-size: 1rem;">和</span><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">audit_log</span><span style="line-height: 1.714285714; font-size: 1rem;">路径到合适的位置，并添加如下两行</span></p>

<pre class="lang:xhtml decode:true">Include/usr/share/doc/mod-security-common/examples/rules/modsecurity_crs_10_global_config.conf

Include/usr/share/doc/mod-security-common/examples/rules/base_rules/*.conf</pre>




<pre class="lang:sh decode:true">sudo apache2ctl start</pre>


<p><span lang="EN-US" style="line-height: 1.714285714; font-size: 1rem;">        #/usr/share/doc/mod-security-common/examples/rules/</span><span style="line-height: 1.714285714; font-size: 1rem;">目录下还有一些规则可用</span></p>

<p><span lang="EN-US">        </span>参照<span lang="EN-US">gentoo</span>的<span lang="EN-US">ebuild</span>中的如下内容（<span lang="EN-US"><a href="http://gentoo-portage.com/www-apache/mod_security/ChangeLog">http://gentoo-portage.com/www-apache/mod_security/ChangeLog</a></span>）<span lang="EN-US"> </span></p>

<div>
  <pre class="lang:sh decode:true">if !use vanilla; then
    mv "${D}"${APACHE_MODULES_CONFDIR}/mod_security/modsecurity_*{41_phpids,50_outbound}* "${D}"${APACHE_MODULES_CONFDIR}/mod_security/optional_rules || die
fi</pre>
</div>


<p><span lang="EN-US">       modsecurity_<em>{41_phpids,50_outbound}</em></span>的这几个规则还是不要用比较好。</p>

<p><span lang="EN-US">       </span>另外，<span lang="EN-US"><a href="http://www.gotroot.com/tiki-index.php?page=mod_security+rules">http://www.gotroot.com/tiki-index.php?page=mod_security+rules</a>  </span>提供一些规则<span lang="EN-US">  </span></p>

<p><span lang="EN-US"> 3.</span>另外，可以把<span lang="EN-US">/var/www/</span>放在一个单独的分区上，用<span lang="EN-US">noexec,nosuid,nodev</span>参数挂载<span lang="EN-US">,</span>打开<span lang="EN-US">mysql</span>的<span lang="EN-US">apparmor</span><span lang="EN-US">,</span>可以极大增强安全性。</p>

<p><span lang="EN-US"> </span></p>

<p>参考资料：</p>

<ul>
<li>        /usr/share/doc/mod-chroot-common/</li>
<li>       <a href="http://core.segfault.pl/~hobbit/mod_chroot/index.html">http://core.segfault.pl/~hobbit/mod_chroot/index.html</a></li>
<li>       <a href="http://server.it168.com/a2010/0714/1077/000001077357.shtml">http://server.it168.com/a2010/0714/1077/000001077357.shtml</a></li>
<li>       <a href="http://www.howtoforge.com/chrooting-apache2-mod-chroot-debian-etch">http://www.howtoforge.com/chrooting-apache2-mod-chroot-debian-etch</a></li>
<li>        /usr/share/doc/mod-security-common<span lang="EN-US">  </span></li>
</ul>


<p><span lang="EN-US">后期补充：</span></p>

<p><span lang="EN-US"> chroot的关键是确保/var/www/ ,/var/www/var/www都存在，并且/var/<wbr />www/var/www<br /> 是指向/的符号连接</span></p>

<p><span lang="EN-US">对apache chroot的过程，我的理解（如有不对，欢迎指正）是<br /> </span><span lang="EN-US">1，先初始化其他模块<br /> </span><span lang="EN-US">2，chroot到/var/www<br /> </span><span lang="EN-US">3,   改变当前目录到/var/www(此时实际上是改变到/var/<wbr />www/var/www目录下)<br /> </span><span lang="EN-US">4，当http请求到来时，比如 <a href="http://127.0.0.">http://127.0.0.</a><wbr />1/index.php , 根据vhost的配置（</span><span lang="EN-US">如果documentroot是/，网页实际放在/var/<wbr />www/下的话），apache寻找/index.php(<wbr />实际上是/var/www/index.php)</span></p>

<p><span lang="EN-US">    另外，还有个诊断方法是查看/proc/<apache pid>/root和/proc/<apache pid>/cwd，一个是apache的root路径，<wbr />一个是apache的当前目录（&lt;apache<br /> pid>是apache的pid ），再看看apache的访问日志</span></p>
]]></content>
  </entry>
  
</feed>
