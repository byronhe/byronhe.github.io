<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Server | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/server/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2020-03-03T07:35:29+00:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Abstract Unix Socket 实现进程单实例运行]]></title>
    <link href="https://blog.helong.info//blog/2020/03/03/abstract-unix-socket-single-instance/"/>
    <updated>2020-03-03T11:06:00+00:00</updated>
    <id>https://blog.helong.info//blog/2020/03/03/abstract-unix-socket-single-instance</id>
    <content type="html"><![CDATA[<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>很多时候，我们需要<strong>确保进程只有一个实例运行</strong>。</p>

<p>有几种方法：</p>

<p><a href="http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux">http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux</a></p>

<p><a href="http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c">http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c</a></p>

<p><a href="https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src">https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src</a></p>

<p>比较常规的做法，是对一个文件加文件锁 flock，比如对 pid 文件 flock( LOCK_EX|LOCK_NB )</p>

<p>但是这种方法有些弊端：</p>

<ol>
<li>如果文件被 mv 或者 rm，是会被绕过的。</li>
<li>如果磁盘故障比如磁盘满，目录没有写权限，会失败。</li>
</ol>


<a name="L......abstract.namespace.unix.socket"></a>
<h2>二，abstract namespace unix socket</h2>

<p><a href="http://linux.die.net/man/7/unix">http://linux.die.net/man/7/unix</a></p>

<p>unix socket 有3种：</p>

<ol>
<li>基于文件的</li>
<li>socketpair 创建的，匿名的</li>
<li>abstract namespace 的，Linux特有</li>
</ol>


<p>Linux 下， AF_UNIX socket 支持一种特殊的
abstract namespace unix socket 。</p>

<p>相比 普通的基于文件系统的 unix socket，abstract namespace unix socket ：</p>

<ol>
<li>没有磁盘文件</li>
<li>进程挂了以后自动删除，无残留文件</li>
<li>无需担心与 文件系统上的文件冲突，不需要关心文件系统上的绝对路径是否存在的问题</li>
</ol>


<!--more-->


<p>在 lsof 的结果里面看起来，就是有一些 类似 @test_abstract_ns 这样的 文件项</p>

<p>代码中使用也很简单，  abstract namespace  unix socket 在 bind 之前，sockaddr_un.sun_path[0] 设成 0x0 即可。</p>

<a name="L............"></a>
<h2>三，代码</h2>

<p>于是我用 abstract unix socket 实现了一个 SysSem 工具类（ 一个 system 范围的 semaphore ），
用来：</p>

<ol>
<li>让一个程序只启动一个实例。</li>
<li>让 x 进程等待 y 进程执行完 yyy 操作后，才能执行 xxx 操作。</li>
</ol>


<p>特点：</p>

<ol>
<li>多进程/线程 并发安全。</li>
<li>当持有的进程被 kill ，OS自动释放，无残留。</li>
<li>没有磁盘文件，没有文件意外被删的各种情况。</li>
<li>不占用 tcp/udp 端口。</li>
<li>简单，不到 60行代码。</li>
</ol>


<pre><code class="cpp">
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;

#include &lt;algorithm&gt;
#include &lt;string&gt;

//
// a semaphore with system scope.
//
// 1. no race conditions between Post() / GetValue() , better than flock().
// 2. when a running process be killed, automatically release all.
// 3. no file on disk, no accidently delete .
// 4. no tcp/udp socket, no confliction, no port consumption.
//
class SysSem {
public:
    SysSem() : _fd(-1) { memset(&amp;_addr, 0, sizeof(_addr)); }
    ~SysSem();

    void Init(std::string id);

    bool Post();
    bool GetValue();

    const char* GetID() const;

private:
    struct sockaddr_un _addr;
    int _fd;
};

void SysSem::Init(std::string id) {
    _addr.sun_family = AF_UNIX;
    const size_t len = std::min(id.size(), sizeof(_addr.sun_path) - 2);  // 2 = start null and end null byte
    // abstract namespace socket address , _addr.sun_path[0] is a null byte ('\0')
    memcpy(_addr.sun_path + 1, id.c_str(), len);
    // memcpy(_addr.sun_path + 0, id.c_str(), len);
}

const char* SysSem::GetID() const { return &amp;_addr.sun_path[1]; }

SysSem::~SysSem() {
    if (_fd &gt;= 0) {
        ::close(_fd);
        _fd = -1;
    }
}

bool SysSem::Post() {
    _fd = ::socket(AF_UNIX, SOCK_STREAM, 0);
    if (_fd &lt; 0) {
        return false;
    }

    if ((0 != ::bind(_fd, (struct sockaddr*)&amp;_addr, sizeof(_addr))) || (0 != listen(_fd, 65536))) {
        return false;
    }
    return true;
}

bool SysSem::GetValue() {
    const int clientFD = ::socket(AF_UNIX, SOCK_STREAM, 0);
    if (clientFD &lt; 0) {
        return false;
    }
    const bool ret = (0 == ::connect(clientFD, (struct sockaddr*)&amp;_addr, sizeof(_addr)));
    ::close(clientFD);
    return ret;
}

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "usage: %s abstract-path post/get\n", argv[0]);
        exit(1);
    }

    SysSem inst;
    inst.Init(argv[1]);

    if (0 == strcasecmp(argv[2], "post")) {
        assert(inst.Post());
        SysSem check;
        check.Init(argv[1]);
        assert(check.GetValue());
        printf("ok, i am the only one under %s. running ...\n", inst.GetID());
        pause();

    } else if (0 == strcasecmp(argv[2], "get")) {
        assert(inst.GetValue());
        printf("a process is running under %s. \n", inst.GetID());
    } else {
        printf("unknown cmd \n");
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 自动翻译成 C++ ，彻底保证离线在线特征一致]]></title>
    <link href="https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/"/>
    <updated>2019-11-29T13:54:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h1>一，问题背景</h1>

<p>随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。</p>

<p>机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。</p>

<a name="L1............................"></a>
<h3>1.常见的特征工程逻辑</h3>

<p>常见的特征工程逻辑有：</p>

<ol>
<li>分箱/分桶 离散化</li>
<li>log/exp 对数/幂等 math numpy 常见数学运算</li>
<li>特征缩放/归一化/截断</li>
<li>交叉特征生成</li>
<li>分词匹配程度计算</li>
<li>字符串分隔匹配判断tong</li>
<li>缺省值填充等</li>
<li>数据平滑</li>
<li>onehot 编码，hash 编码等</li>
</ol>


<p>这些特征工程代码，当然一般使用深度学习最主要的语言 <strong>python</strong> 实现。</p>

<a name="L.................."></a>
<h1>二，业务痛点</h1>

<p>离线训练完成，模型上线部署后，同样要<strong>用 C++ 重新实现</strong> 这些 python 的特征工程逻辑代码。</p>

<p>我们发现，<strong>“用 C++ 重新实现”</strong> 这个步骤，给实际业务带来了大量的问题：</p>

<ol>
<li>繁琐，费时费力，极容易出现 python 和 C++ 代码<strong>不一致</strong></li>
<li><strong>不一致</strong>会直接影响模型在线上的效果，导致大盘业务指标不如预期，产生各种 bad case</li>
<li><strong>不一致</strong>难以发现，无法测试，无法监控，经常要靠用户投诉反馈，甚至大盘数据异常才能发现</li>
</ol>


<!--more-->


<a name="L1.............."></a>
<h3>1. 业界方案</h3>

<p>针对这些问题，我调研了这些业界方案：</p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<blockquote><p>“模型线上线下一致性问题对于模型效果非常重要，我们使用特征日志来实时记录特征，保证特征的一致性。这样离线处理的时候会把实时的用户反馈，和特征日志做一个结合生成训练样本，然后更新到模型训练平台上，平台更新之后在推送到线上，这样整个排序形成了一个闭环。”</p></blockquote>

<p>总结起来，有几种思路：</p>

<ol>
<li>在线特征存储起来给离线用</li>
<li>在线 C++ 代码编译成 so 导出给离线用</li>
<li>根据一份配置生成离线和在线代码</li>
<li>提取公共代码，加强代码复用，等软件工程手段，减少不一致</li>
</ol>


<a name="L2...................."></a>
<h3>2. 自动翻译方案</h3>

<a name="L.1........................"></a>
<h4>(1) .已有方案的缺点</h4>

<p>但这些思路都有各种缺点：</p>

<ol>
<li>所有在线请求的所有特征，这个存储量数据量很大</li>
<li>算法改代码需要等待后台开发，降低了算法同学的工作效率</li>
<li>特征处理代码的复杂度转移到配置文件中，不一定能充分表达，而且配置格式增加学习成本</li>
<li>就这边真实离线特征处理代码来看，大部分代码都无法抽取出公共代码做复用。</li>
</ol>


<a name="L.2............"></a>
<h4>(2). 翻译器</h4>

<p>回到问题出发点考虑，显而易见，这个问题归根结底就是需要一个 “ python 到 c++ 的翻译器 ” 。</p>

<p>那其实 “翻译器 Transpiler ” ，和编译器解释器类似，也是个古老的热门话题了，比如 <a href="https://webassembly.org/">WebAssembly</a>, <a href="https://coffeescript.org/">CoffeeScript </a>，<a href="https://www.babeljs.cn/docs/">Babel</a> ,
<a href="https://github.com/google/closure-compiler">Google Closure Compiler</a>，<a href="https://www.netlib.org/f2c/f2c.1">f2c</a></p>

<p>于是一番搜索，发现 python 到 C++ 的翻译器也不少，其中 <a href="https://github.com/serge-sans-paille/pythran">Pythran</a> 是新兴比较热门的开源项目。</p>

<p>于是一番尝试后，借助 pythran，我们实现了：</p>

<ol>
<li>一条命令 <strong>全自动把 Python 翻译成等价 C++</strong></li>
<li>严格等价保证改写，彻底消除不一致</li>
<li><strong>完全去掉重新实现</strong> 这块工作量，后台开发成本降到 0 ，彻底解放生产力</li>
<li>算法同学继续使用纯 python，开发效率无影响，<strong> 无学习成本 </strong></li>
<li>并能推广到其他需要 <strong>python 改写成后台 C++ 代码</strong> 的业务场景，解放生产力</li>
</ol>


<a name="L......pythran................"></a>
<h1>三，pythran 的使用流程</h1>

<a name="L.1........."></a>
<h3>(1). 安装</h3>

<p>一条命令安装：
<code>bash
pip3 install pythran
</code></p>

<a name="L.2.......Python......."></a>
<h3>(2). 写 Python 代码</h3>

<p>下面这个 python demo，是 pythran 官方 demo
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">math</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.matrix_multiply.float.list.list..float.list.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">matrix_multiply</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">):</span>
</span><span class='line'>    <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">)):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
</span><span class='line'>                <span class="n">new_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">m1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">new_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.arc_distance.float....float....float....float...&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">arc_distance</span><span class="p">(</span><span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[])</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">arc_distance</span><span class="p">(</span><span class="n">theta_1</span><span class="p">,</span> <span class="n">phi_1</span><span class="p">,</span> <span class="n">theta_2</span><span class="p">,</span> <span class="n">phi_2</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Calculates</span> <span class="n">the</span> <span class="n">pairwise</span> <span class="n">arc</span> <span class="n">distance</span>
</span><span class='line'>    <span class="n">between</span> <span class="nb">all</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">vector</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">theta_2</span><span class="o">-</span><span class="n">theta_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span>
</span><span class='line'>           <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">phi_2</span><span class="o">-</span><span class="n">phi_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">temp</span><span class="p">))</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">distance_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.dprod.int.list..int.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">dprod</span><span class="p">(</span><span class="nb">int</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">dprod</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">WoW</span><span class="p">,</span> <span class="n">generator</span> <span class="n">expression</span><span class="p">,</span> <span class="nb">zip</span> <span class="ow">and</span> <span class="nb">sum</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.get_age.int..&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">get_age</span><span class="p">(</span><span class="nb">int</span> <span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">get_age</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">20</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">0</span><span class="n">_20</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">25</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">21</span><span class="n">_25</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">30</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">26</span><span class="n">_30</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">35</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">31</span><span class="n">_35</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">40</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">36</span><span class="n">_40</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">45</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">41</span><span class="n">_45</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">50</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">46</span><span class="n">_50</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">50</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">age_x</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c">### (3). Python 转成 C++</span>
</span><span class='line'><span class="err">一条命令完成翻译</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="o">-</span><span class="n">e</span> <span class="n">demo</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">o</span>  <span class="n">demo</span><span class="o">.</span><span class="n">hpp</span>
</span></code></pre></td></tr></table></div></figure></p>

<a name="L.4.......C..............."></a>
<h3>(4). 写 C++ 代码调用</h3>

<p>pythran/pythonic/ 目录下是 python 标准库的 C++ 等价实现，翻译出来的C++ 代码需要 include 这些头文件</p>

<p>写个 C++ 代码调用</p>

<pre><code class="cpp">
#include "demo.hpp"
#include "pythonic/numpy/random/rand.hpp"
#include &lt;iostream&gt;

using std::cout;
using std::endl;

int main() {
  pythonic::types::list&lt;pythonic::types::list&lt;double&gt;&gt; m0 = { {2.0, 3.0},
                                                             {4.0, 5.0} },
                                                       m1 = { {1.0, 2.0},
                                                             {3.0, 4.0} };
  cout &lt;&lt; m0 &lt;&lt; "*" &lt;&lt; m1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::matrix_multiply()(m0, m1) &lt;&lt; endl
       &lt;&lt; endl;

  auto theta_1 = pythonic::numpy::random::rand(3),
       phi_1 = pythonic::numpy::random::rand(3),
       theta_2 = pythonic::numpy::random::rand(3),
       phi_2 = pythonic::numpy::random::rand(3);
  cout &lt;&lt; "arc_distance " &lt;&lt; theta_1 &lt;&lt; "," &lt;&lt; phi_1 &lt;&lt; "," &lt;&lt; theta_2 &lt;&lt; ","
       &lt;&lt; phi_2 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::arc_distance()(theta_1, phi_1, theta_2, phi_2) &lt;&lt; endl
       &lt;&lt; endl;

  pythonic::types::list&lt;int&gt; l0 = {2, 3}, l1 = {4, 5};
  cout &lt;&lt; "dprod " &lt;&lt; l0 &lt;&lt; "," &lt;&lt; l1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::dprod()(l0, l1) &lt;&lt; endl
       &lt;&lt; endl;

  cout &lt;&lt; "get_age 30 = " &lt;&lt; __pythran_demo::get_age()(30) &lt;&lt; endl &lt;&lt; endl;

  return 0;
}
</code></pre>

<a name="L.5..............."></a>
<h3>(5). 编译运行</h3>

<pre><code class="sh">g++ -g -std=c++11 main.cpp -fopenmp -march=native -DUSE_XSIMD -I /usr/local/lib/python3.6/site-packages/pythran/ -o pythran_demo  

./pythran_demo
</code></pre>

<a name="L......pythran..................."></a>
<h1>四，pythran 的功能与特性</h1>

<a name="L.1........."></a>
<h3>(1). 介绍</h3>

<p>按官方定义，Pythran 是一个 AOT (Ahead-Of-Time - 预先编译) 编译器。 给科学计算的 python 加注解后，pythran 可以把 python 代码变成接口相同的原生 python 模块，大幅度提升性能。</p>

<p>并且 pythran 也可以利用 OpenMP 多核和 SIMD 指令集。</p>

<p>支持 python 3 和 Python 2.7 。</p>

<p>pythran 的 manual 挺详细：
<a href="https://pythran.readthedocs.io/en/latest/MANUAL.html">https://pythran.readthedocs.io/en/latest/MANUAL.html</a></p>

<a name="L.2........."></a>
<h3>(2). 功能</h3>

<p>pythran 并不支持完整的python， 只支持 python 语言特性的一个子集:</p>

<ul>
<li>polymorphic functions 多态函数(翻译成 C++ 的泛型模板函数)</li>
<li>lambda</li>
<li>list comprehension  列表推导式</li>
<li>map, reduce 等函数</li>
<li>dictionary, set, list 等数据结构</li>
<li>exceptions 异常</li>
<li>file handling 文件处理</li>
<li>部分 numpy</li>
</ul>


<p>不支持的功能：</p>

<ul>
<li>classes 类</li>
<li>polymorphic variables 可变类型变量</li>
</ul>


<a name="L.3................................."></a>
<h3>(3). 支持的数据类型和函数</h3>

<p>pythran export  可以导出函数和全局变量。
支持导出的数据类型，BNF 定义是：</p>

<pre><code class="antlr">    argument_type = basic_type
                  | (argument_type+)    # this is a tuple
                  | argument_type list    # this is a list
                  | argument_type set    # this is a set
                  | argument_type []+    # this is a ndarray, C-style
                  | argument_type [::]+    # this is a strided ndarray
                  | argument_type [:,...,:]+ # this is a ndarray, Cython style
                  | argument_type [:,...,3]+ # this is a ndarray, some dimension fixed
                  | argument_type:argument_type dict    # this is a dictionary

    basic_type = bool | byte | int | float | str | None | slice
               | uint8 | uint16 | uint32 | uint64 | uintp
               | int8 | int16 | int32 | int64 | intp
               | float32 | float64 | float128
               | complex64 | complex128 | complex256
</code></pre>

<p>可以看到基础类型相当全面，支持各种 整数，浮点数，字符串，复数</p>

<p>复合类型支持 tuple, list, set, dict, numpy.ndarray 等，</p>

<p>对应 C++ 代码的类型实现在  pythran/pythonic/include/types/  下面，可以看到比如 dict 实际就是封装了一下 std::unordered_map
<a href="https://pythran.readthedocs.io/en/latest/SUPPORT.html">https://pythran.readthedocs.io/en/latest/SUPPORT.html</a>
可以看到支持的 python 基础库，其中常用于机器学习的 numpy 支持算比较完善。</p>

<a name="L......pythran................"></a>
<h1>五，pythran 的基本原理</h1>

<p>和常见的编译器/解释器类似， pythran 的架构是分成 3 层：</p>

<ol>
<li>python 代码解析成抽象语法树 AST 。用 python 标准库自带的的 ast 模块实现</li>
<li>代码优化。
 在 AST 上做优化，有多种 transformation pass，比如 deadcode_elimination 死代码消除，loop_full_unrolling  循环展开 等。还有 Function/Module/Node 级别的 Analysis，用来遍历 AST 供 transformation 利用。</li>
<li>后端，实现代码生成。目前有2个后端，Cxx / Python，  Cxx 后端可以把 AST 转成 C++ 代码（ Python 后端用来调试）。</li>
</ol>


<p>目前看起来 ，pythran 还欠缺的：</p>

<ol>
<li>字符串处理能力欠缺，缺少 str.encode()/str.decode() 对 utf8 的支持</li>
<li>缺少正则表达式 regex 支持</li>
<li>缺少 json 支持</li>
</ol>


<p>看文档要自己加也不麻烦，看业务需要可以加。</p>

<a name="L.................."></a>
<h1>六，相关文章</h1>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>numba
<a href="http://numba.pydata.org">http://numba.pydata.org</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗]]></title>
    <link href="https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/"/>
    <updated>2019-11-25T12:34:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/25/cppjieba-darts-DAT-memory_optimize</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>中文分词应用比较广泛的开源算法，是 <a href="https://github.com/fxsjy/jieba">jieba 结巴分词</a>，结巴分词较高性能的实现是 C++ 版本的 CppJieba :
<a href="https://github.com/yanyiwu/cppjieba">https://github.com/yanyiwu/cppjieba</a></p>

<p>在实际使用 CppJieba 的过程中，我们发现 CppJieba 的内存占用比较高。</p>

<p>比如对一个 76W 词 大小 11MB 的词典 ，加载 2份 （比如为了支持平滑改动用户词典）就需要耗费 505MB内存。</p>

<p>这对一些多进程的后台服务，浪费大量内存，难以接受，因此这里希望削减内存耗费。</p>

<p>经过初步调查，确定改进方法，然后动手改造，<strong>最终把 505MB 缩减到了 4.7MB ，实现了 99% 内存降低</strong>。</p>

<p>此处也有 issue 讨论 <a href="https://github.com/yanyiwu/cppjieba/issues/3">https://github.com/yanyiwu/cppjieba/issues/3</a></p>

<p>代码稍后可能会开源出来。</p>

<!--more-->


<a name="L.................."></a>
<h2>二，实现过程</h2>

<a name="L....1................."></a>
<h3>二.1  查内存分布</h3>

<p>第一步先用 jemalloc 的 memory profiler 工具查看内存耗费在哪里，</p>

<ol>
<li>改一下 CppJieba  的  test/demo.cpp， 链接 jemalloc，编译成二进制  jieba_test</li>
<li>然后设置环境变量
 <code>export MALLOC_CONF="prof:true,prof_prefix:mem_prof/mem_profile_je.out,lg_prof_interval:20,lg_prof_sample:20"</code></li>
<li>然后  mkdir mem_prof， 并运行测试程序</li>
<li>jeprof &ndash;pdf ./jieba_test mem_prof/mem_profile_je.out.xxx.heap > mem_profile.pdf</li>
</ol>


<p>打开 mem_profile.pdf ，就可以看到内存分布了</p>

<a name="L....2............."></a>
<h3>二.2 优化方案</h3>

<p>显而易见，内存主要耗费在:
1. Trie.hpp 中的 Trie 树构建
2. KeywordExtractor.hpp 加载  idf 词典文件。</p>

<p>因此方案:</p>

<a name="L1..Double.Array.Trie.........cppjieba::Trie"></a>
<h4>1. Double Array Trie 代替  cppjieba::Trie</h4>

<p>引入 Double Array Trie  (简称  DAT ,<a href="https://github.com/s-yata/darts-clone">https://github.com/s-yata/darts-clone</a>) , 代替 Trie.hpp 中的简单内存 Trie，并把 darts 生成的  DAT 保存到文件中，在启动时，如果已经有和词典对应的 DAT ，直接 mmap() attach 上去，即可启动。</p>

<p>经过实测发现，75万词词典，dart-clone 生成的 DAT 文件，大小只有 24MB，而且可以 mmap 挂载，多进程共享。</p>

<a name="L2..KeywordExtractor"></a>
<h4>2. KeywordExtractor</h4>

<p>KeywordExtractor 是个不常用功能，直接改成支持传入空的 idfPath 和 stopWordPath, 此时不加载数据即可。</p>

<a name="L....3............."></a>
<h3>二.3 其他问题</h3>

<a name="L1...................................DAT......"></a>
<h4>1. 支持热更新，保证词典和DAT一致</h4>

<p>这里一个问题是，词典可能热更新，那怎么知道 DAT 文件和当前词典的内容对应？</p>

<p>我的做法是，对 默认词典文件+自定义词典文件，用文件内容算 MD5，写入 DAT 文件头部，这样打开 DAT 文件发现 MD5 不一致，就知道 DAT文件过时了，即可重建 DAT 。</p>

<p>实测发现算 MD5 还是很快的，启动时间都在 1秒 左右。</p>

<a name="L2.............."></a>
<h4>2. 代码清理</h4>

<p>另外，清理了一下代码，删掉了 Unicode.hpp 中的无用代码。
清理了 FullSegment.hpp HMMSegment.hpp MixSegment.hpp MPSegment.hpp QuerySegment.hpp 等中的重复代码。</p>

<a name="L3................."></a>
<h4>3. 不兼容改动</h4>

<ul>
<li>由于 Double Array Trie 无法支持动态插入词，删除 InsertUserWord() 方法</li>
<li>FullSegment.hpp 中 maxId 的计算有 bug，做了 fix。</li>
</ul>


<p>整体改造后，代码量比原来减少 100 多行。</p>

<p>上线后效果显著。</p>

<p>当内存降低到 2-3MB 的水平后，这意味着 75W 词这种规模的大词典，可以用在手机环境。</p>

<p>比如可以在 ios 或者 Android 上做 中文/英文的切词，
这意味着可能在客户端实现体验相当良好的搜索引擎。</p>

<p>ios 上也有可用于中文的分词器 <a href="https://developer.apple.com/documentation/corefoundation/cfstringtokenizer-rf8">CFStringTokenizer</a> ，但貌似不开源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GB 规模语料上的高性能新词发现算法]]></title>
    <link href="https://blog.helong.info//blog/2019/09/18/newwords_discovery/"/>
    <updated>2019-09-18T22:19:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/09/18/newwords_discovery</id>
    <content type="html"><![CDATA[<hr />

<p>分词是中文搜索的重要环节，目前分词算法已经比较成熟，分词错误的主要是由于未登录词。</p>

<p>因此发现业务领域语料库中的新词，减少未登录词，对改善搜索引擎的用户体验有重要意义。</p>

<p>新词发现的一种常用算法，是 matrix67 大神 2012 年提出的 《互联网时代的社会语言学：基于SNS的文本数据挖掘》
<a href="https://www.matrix67.com/blog/archives/5044">https://www.matrix67.com/blog/archives/5044</a></p>

<p>其主要思路，是统计语料中出现的所有 ngram 子字符串的凝固度，自由度，信息熵。</p>

<p>算法中需要统计所有 ngram 子字符串的 左熵右熵，实现该算法时，一般以子字符串为 key，用哈希表来存。</p>

<p>但随着语料库变大时，内存消耗变大，</p>

<p>比如之前的 python 版本实现，对 200MB 的语料，就需要约 30G 内存来存哈希表，</p>

<p>导致单机内存不足无法运行，而且对这样规模的语料库，算法需要跑一两天才能出结果。</p>

<p>这里我应用一些工程实现方面的技巧，
把用哈希表统计左熵右熵的计算，拆分成多个子哈希表，分批计算，并利用多核并行，大幅度优化了算法的性能。</p>

<p>最终实现了 GB 大小语料上的新词发现，并把运行时间缩减到了 30 分钟左右 。</p>

<p><a href="https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB">https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[现代密码学实践指南[2015年]]]></title>
    <link href="https://blog.helong.info//blog/2015/06/05/modern-crypto/"/>
    <updated>2015-06-05T22:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/06/05/modern-crypto</id>
    <content type="html"><![CDATA[<hr />

<p>本文介绍目前现代密码学的最先进技术，
前半部分主要翻译自  <a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad">《Cryptographic Right Answers》</a>，附上收集的资料，和byron个人的理解。</p>

<p>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</p>

<hr />

<a name="L...................................................................................."></a>
<h5>下文分类介绍在各种适用场景下，你应该使用的现代密码学算法</h5>

<a name="L1....strong...............strong..:"></a>
<h3>1.  <strong>加密数据</strong> :</h3>

<p>按照优先级，应该选择:</p>

<p>(1)   首选 NaCl库，或者libsodium库，使用里面的crypto_secretbox()/crypto_secretbox_open() 函数
(2)   Chacha20-Poly1305 算法
(3)   AES-GCM 算法</p>

<p>适用场景:当你需要避免把明文数据在网络上传输的时候。</p>

<p>以上3种算法，都是AEAD类的算法，AEAD是2015年最好的选择。
其中的(2)和(3)在结构上类似：一个流加密模式的算法，配合一个多项式结构的MAC。
(2)是一个流加密算法，配合一个为通用cpu优化的MAC算法，
对密码学库的实现者来说，Poly1305也比GCM更容易安全地实现。
AES-GCM是工业标准(TLS目前主要用的就是AES-GCM)，现代CPU通常都有专门为AES-GCM设计的硬件指令，但是在没有硬件指令支持的CPU上(比如32位的arm)，(3)性能低于(2)。</p>

<!--more-->


<p>此外，应该</p>

<ul>
<li>避免AES-CBC(说来话长，后文有解释)</li>
<li>避免AES-CTR</li>
<li>避免64bit块大小的块加密算法&ndash;(说的就是你&ndash;BlowFish)</li>
<li>避免OFB模式</li>
<li>不要使用RC4，RC4已经被攻破</li>
</ul>


<a name="L2....strong.....................strong..:"></a>
<h3>2.  <strong>对称密钥长度</strong> :</h3>

<p>选择使用256bit长度的密钥</p>

<p>适用场景：只要你在使用密码学，你就应该注意<strong>对称密钥长度</strong></p>

<p>请记住：不要把对称加密（如AES）的key长度，和非对称加密(如RSA)的key长度搞混淆了，对称加密的key通常比非对称加密的key短多了。</p>

<p>下表对比了相同安全程度时，不同算法的密钥长度，单位:bit</p>

<table>
<thead>
<tr>
<th> Symmetric</th>
<th>   ECC   </th>
<th>DH/DSA/RSA</th>
</tr>
</thead>
<tbody>
<tr>
<td>   80     </td>
<td>   163   </td>
<td>     1024 </td>
</tr>
<tr>
<td>  112     </td>
<td>   233   </td>
<td>     2048 </td>
</tr>
<tr>
<td>  128     </td>
<td>   283   </td>
<td>     3072 </td>
</tr>
<tr>
<td>  192     </td>
<td>   409   </td>
<td>     7680 </td>
</tr>
<tr>
<td>  256     </td>
<td>   571   </td>
<td>    15360 </td>
</tr>
</tbody>
</table>


<p>此外，应该</p>

<ul>
<li>避免使用巨大key的算法(使用远大于256的key，只能说明使用者没有安全概念)</li>
<li>避免把多个加密算法串联叠加起来使用，这并没有什么卵用</li>
<li>避免128bit以下的key长度(比如，哥们求你别再提DES这种56bit密钥的古董了)</li>
</ul>


<a name="L3....strong...............strong.:"></a>
<h3>3.  <strong>对称签名</strong>:</h3>

<p>应该选择 HMAC 类的算法</p>

<p>适用场景：安全加固一个API，如各种开放API的调用方认证</p>

<p>如果对一个API，你需要做认证(authenticating)，但是不需要做加密(encrypting)，记得千万不要自己发明算法，你自己发明的MAC算法基本都有安全漏洞，如果不信，请Google一下 &ldquo;长度扩展攻击&rdquo;
<a href="http://en.wikipedia.org/wiki/Length_extension_attack">长度扩展攻击</a>
<a href="http://netifera.com/research/flickr_api_signature_forgery.pdf">Flickr的漏洞案例</a></p>

<p>同时，必须要注意的是，要使用一个<strong>常数时间字符串对比算法</strong>（这个地方和码农的常识完全相反，请务必留意）</p>

<p>此外，应该</p>

<ul>
<li>避免自行设计的“带密码的hash”结构，你的设计基本都是有安全漏洞的</li>
<li>避免HMAC-MD5，避免HMAC-SHA1，使用HMAC-SHA256, HMAC-SHA512等</li>
<li>避免复杂的多项式MAC</li>
<li>避免加密hash值的结构</li>
<li>避免CRC</li>
</ul>


<a name="L4....strong.Hashing.HMAC.........strong."></a>
<h3>4.  <strong>Hashing/HMAC 算法</strong></h3>

<p>应该选择<a href="http://en.wikipedia.org/wiki/SHA-2">SHA2</a>类的算法:: SHA-256, SHA-384, SHA-512, SHA-512/256</p>

<p>优先使用 SHA-512/256，SHA-512/256这个算法把 SHA-512 的512bit输出截短到256bit，避开了length extension 攻击。
同时，目前SHA-2是很安全可靠的，你不需要升级到SHA-3.</p>

<p>此外，应该</p>

<ul>
<li>避免SHA-1</li>
<li>避免MD5</li>
<li>避免MD6</li>
</ul>


<a name="L5....strong.......ID..strong."></a>
<h3>5.  <strong>随机ID</strong></h3>

<p>应该使用256 bit的随机值</p>

<p>一定要使用 /dev/urandom，请认准这个</p>

<p>此外，应该</p>

<ul>
<li>避免用户空间的随机数生成器如:havaged,prngs,egd,等</li>
<li>避免/dev/random</li>
</ul>


<a name="L6....strong...............strong."></a>
<h3>6.  <strong>密码处理</strong></h3>

<p>按照优先级顺序,选择：</p>

<ul>
<li>scrypt</li>
<li>bcrypt</li>
<li>如果以上2个都没有，那就用PBKDF2</li>
</ul>


<p>此外，应该</p>

<ul>
<li>避免直接SHA-2</li>
<li>避免直接SHA-1</li>
<li>避免直接MD5</li>
</ul>


<a name="L7....strong..................strong."></a>
<h3>7.  <strong>非对称加密</strong></h3>

<p>应该使用NaCl库</p>

<p>适用场景：当你需要加密消息，发给陌生人，并且对方异步接收消息，做离线解密时。这是一个很窄的应用案例，这种用法有个名字叫<em>电子信封(digital envelope)</em>，典型比如gpg加密文件后发送。</p>

<p>这条是几条之中最难做正确的，不要使用底层的密码学库，比如OpenSSL或者BouncyCastle。</p>

<p>你应该停止使用RSA，并且切换到椭圆曲线类体制，原因是：</p>

<ul>
<li>对RSA的攻击能力的进步 &mdash; 定义在传统质数域上的乘法运算(应用包括DH,DSA,ElGamal等)，要比椭圆曲线域上的乘法运算快得多。这是由于质数域上数域筛法（number field sieve,NFS）的进展，而在椭圆曲线域上，没有NFS这类算法。</li>
<li>RSA (和DH) 或迫使你考虑“向后兼容性”，而椭圆曲线体制没有这种兼容性包袱。TLS最近的几个安全漏洞，部分愿意也是由于这种向后兼容性，导致已经被破解的陈旧算法存在</li>
<li>RSA在一般场景中，都是直接用公钥做非对称加密，这种用法丧失了<strong>前向安全性(Perfect Forward Secrecy)</strong>。而椭圆曲线就不提倡，也很难这样使用，这样你就不会害死自己了。</li>
<li>在椭圆曲线体制下，保证正确性和安全性的重任，主要由密码学家承担，密码学家会提供一组曲线参数，在某一性能水平下，针对安全性和性能做优化。这样程序员不容易误用而害死自己。在RSA体制下，正好相反，程序员必须提供参数来保证正确性和安全性，就算是RSA-OAEP这种很好的设计，程序员也必须知道怎么提供参数，这样程序员很容易搞错。</li>
</ul>


<p>如果你必须使用RSA，一定要使用RSA-OAEP with SHA256，指数使用 65537</p>

<ul>
<li>避免 RSA-PKCS1v15</li>
<li>避免 ElGamal</li>
<li>避免 RSA</li>
</ul>


<a name="L8....strong..................strong."></a>
<h3>8.  <strong>非对称签名</strong></h3>

<p>应该使用NaCl，Ed25519，或者RFC6979</p>

<p>应用场景：如果你在设计一种新的比特币，或者一个给Ruby Gems或者Vagrant imges文件签名的系统，或者数字版权保护系统(DRM)，其中一系列的文件需要离线做认证；
或者你在设计一个加密消息传输层</p>

<p>上一条的内容在此处全部适用。</p>

<p>在10+年做付费软件安全评估的工作经历中，我只有屈指可数的几次，遇到使用RSA-PSS的用户，RSA-PSS是一个学术界的推荐算法。</p>

<p>过去10年，非对称签名最主要的应用场景是比特币，和前向安全的密钥协商（TLS协议里面的ECDHE）。
其中最主要的算法全都是基于椭圆曲线体制的。务必警惕新出现的使用RSA签名的系统，很有可能有问题。</p>

<p>在过去几年中，业界有一种趋势：放弃传统DSA签名，改为难以误用的<strong>确定性签名体制</strong>，其中的EdDSA(不要和ECDSA搞混了喂！)和RFC6979是最好的例子。这种趋势的主要是受到2010年索尼PlayStation 3的 ECDSA私钥被破解事件的影响，在这个案例中，索尼公司的码农错误地把一个随机数重复使用来做ECDSA签名，形成了漏洞，使得破解者据此直接把私钥算出来了。<strong>确定性签名体制</strong>在设计中不再依赖随机数生成器，因此彻底避开此类误用。所以你应该优先使用确定性签名体制。</p>

<ul>
<li>避免RSA-PKCS1v15，避免RSA，避免ECDSA，避免DSA</li>
<li>特别要避免常规的DSA和ECDSA</li>
</ul>


<a name="L9....strong.Diffie-Hellman...............strong."></a>
<h3>9.  <strong>Diffie-Hellman 密钥交换</strong></h3>

<p>应该使用NaCl，Curve25519，或者DH-2048</p>

<p>适用场景:<em>如果你在设计加密消息传输系统，并且无法使用固定对称密码</em></p>

<p>这是很棘手的一条，主要考量如下：</p>

<ul>
<li>如果你能使用NaCl库，那就使用NaCl库。你甚至不需要管NaCl是什么。</li>
<li>如果你能使用一个可信赖的第三方库，那就使用Curve25519，这是一条现代的ECDH曲线，有丰富的开源代码，性能经过高度优化，被彻底地安全分析过。并且Curve25519即将进入TLS 1.3版本标准。</li>
<li>但是绝对不要自己实现Curve25519，也绝对不要自己移植Curve25519的C代码</li>
<li>如果你不能使用第三方ECDH库，但是可以使用DH库，那就使用DH-2048，使用1个标准的2048 bit的群。</li>
<li>但是不要使用传统的DH，如果你需要协商DH参数，或者和其他实现互操作</li>
<li>如果你一定要做握手协商，或者和旧软件互操作，那么考虑使用NIST P-256, NIST P-256 有广泛的软件支持。</li>
<li>写死在代码里的DH-2048参数，比NIST P-256更安全。NIST P-256比协商出来的DH更安全。</li>
<li>但是，由于NIST P-256的实现有一些陷阱，所以一定要谨慎选择可信赖的，广泛使用使的第三方库</li>
<li>P-256 可能是NIST曲线中最安全的，不要使用P-224。</li>
</ul>


<p>DH（密钥协商）算法确实很难用，但是它很重要。</p>

<ul>
<li>避免，传统常规的 DH, SRP, J-PAKE 握手和协商</li>
<li>避开任何只使用了块加密算法和srand(time())的密钥协商模式（肯定有漏洞）</li>
</ul>


<a name="L10....strong...............strong."></a>
<h3>10.  <strong>网站安全</strong></h3>

<p>应该使用OpenSSL，或者Google的BoringSSL，或者直接使用 AWS的 ELB</p>

<p>此处网站安全，指的是让网站支持HTTPS协议。
如果你不能把这个任务交给Amazon的云服务去做，把难题留给Amazon去解决，那么OpenSSL目前仍然是正确选择。</p>

<ul>
<li>避免不常见的TLS库，例如polarssl，GnuTLS，MatrixSSL等</li>
</ul>


<a name="L11....strong..........-.........................................strong...."></a>
<h3>11.  <strong>客户端-服务器结构的应用程序的安全</strong>：</h3>

<p>应该使用TLS</p>

<p>适用场景：如果你以为自己理解了前面关于公钥加密的介绍。。。</p>

<p>通常，在你设计了自己的RSA协议之后的1至18个月，你肯定会发现，你犯了某个错误，使你的协议没有任何安全性。
比如Salt Stack，Salt Stack的协议使用了 e=1 的RSA 公钥。。。</p>

<p>听起来，TLS有下面这些黑历史：</p>

<ul>
<li>The Logjam DH negotiation attack</li>
<li>The FREAK export cipher attack</li>
<li>The POODLE CBC oracle attack</li>
<li>The RC4 fiasco</li>
<li>The CRIME compression attack</li>
<li>The Lucky13 CBC padding oracle timing attack</li>
<li>The BEAST CBC chained IV attack</li>
<li>Heartbleed</li>
<li>Renegotiation</li>
<li>Triple Handshakes</li>
<li>Compromised CAs</li>
</ul>


<p>但是，你仍然应该使用TLS做传输协议，因为：</p>

<ul>
<li>这些漏洞中的大部分，仅仅是针对浏览器的，因为他们依赖受害者执行攻击者控制的JavaScript脚本，这些JavaScript脚本生成重复的明文，或特定的明文。</li>
<li>这些漏洞中的大部分，其影响都可以被减轻，只需要你在代码和配置里面写死 TLS v1.2, ECDHE，和 AES-GCM就行。这听起来很棘手，但是这远远没有你自己设计使用ECDHE和AES-GCM的传输协议棘手。</li>
<li><p>在一个自定义的传输协议的场景中，你并不需要依赖CA，你可以用一个自签名证书，嵌入到你的客户端里面。</p></li>
<li><p>不要自己设计加密传输协议，这是<strong>极其困难而易错的工程难题</strong></p></li>
<li>使用TLS，但是不要使用默认配置</li>
</ul>


<a name="L12....strong...............strong."></a>
<h3>12.  <strong>在线备份</strong></h3>

<p>应该使用Tarsnap</p>

<hr />

<a name="L............"></a>
<h1>名词解释</h1>

<p>本文的内容比较新，相关中文资料极少，因此文中的名词对读者可能有点陌生，故byron这里介绍一下文中提到的一些名词：</p>

<a name="L1...NaCl...:"></a>
<h3>1.  NaCl库:</h3>

<p><a href="http://nacl.cr.yp.to/">http://nacl.cr.yp.to/</a>
是密码学学术权威 Daniel J. Bernstein教授 设计的一个密码学算法库，2008年发开始公布。NaCl的特点是：api简洁而易用，高性能，高安全性，主要用于网络通信，加密，解密，签名等，NaCl提供了构建高层密码学工具的核心功能。</p>

<a name="L2...libsodium...:"></a>
<h3>2.  libsodium库:</h3>

<p><a href="https://download.libsodium.org/doc/">https://download.libsodium.org/doc/</a>
libsodium是对NaCl库的一个分支，进一步改进接口易用性，和可移植性。</p>

<a name="L3...AEAD:"></a>
<h3>3.  AEAD:</h3>

<p><a href="https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html">https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html</a>
AEAD的概念:
在通常的密码学应用中，Confidentiality  (保密) 用加密实现，Message authentication (消息认证) 用MAC实现。这两种算法的配合方式，引发了很多安全漏洞，过去曾经有3种方法：1. Encrypt-and-MAC  2.MAC-then-Encrypt 3.Encrypt-then-MAC ，后来发现，1和2都是有安全问题的，所以，2008年起，
逐渐提出了“用一个算法在内部同时实现cipher+MAC”的idea，称为AEAD(Authenticated encryption with additional data)。
在AEAD这种概念里，cipher+MAC 被 一个AEAD算法替换。
<a href="http://en.wikipedia.org/wiki/Authenticated_encryption">http://en.wikipedia.org/wiki/Authenticated_encryption</a></p>

<a name="L4...ChaCha20-poly1305"></a>
<h3>4.  ChaCha20-poly1305</h3>

<p>ChaCha20-poly1305是一种AEAD，提出者是Daniel J. Bernstein教授，针对移动互联网优化，目前Google对移动客户端的所有流量都使用ChaCha20-Poly1305</p>

<a name="L5...AES-GCM"></a>
<h3>5.  AES-GCM</h3>

<p>AES-GCM是一种AEAD，是目前TLS的主力算法，互联网上https流量的大部分依赖使用AES-GCM。</p>

<a name="L6...AES-GCM...ChaCha20-Poly1305...........................:"></a>
<h3>6.  AES-GCM和ChaCha20-Poly1305的性能对比测试结果:</h3>

<table>
<thead>
<tr>
<th> Chip  </th>
<th style="text-align:center;"> AES-128-GCM speed </th>
<th style="text-align:center;"> ChaCha20-Poly1305 speed   </th>
</tr>
</thead>
<tbody>
<tr>
<td> OMAP 4460 </td>
<td style="text-align:center;"> 24.1 MB/s     </td>
<td style="text-align:center;"> 75.3 MB/s </td>
</tr>
<tr>
<td> Snapdragon S4 Pro </td>
<td style="text-align:center;">41.5 MB/s  </td>
<td style="text-align:center;">   130.9 MB/s  </td>
</tr>
<tr>
<td> Sandy Bridge Xeon (AESNI) </td>
<td style="text-align:center;">900 MB/s   </td>
<td style="text-align:center;">   500 MB/s    </td>
</tr>
</tbody>
</table>


<a name="L7...AES-CBC"></a>
<h3>7.  AES-CBC</h3>

<p>关于AES-CBC，在AES-GCM流行之前，TLS主要依赖AES-CBC，而由于历史原因，TLS在设计之初固定选择了MAC-then-Encrypt结构，AES-CBC和MAC-then-encrypt结合，为选择密文攻击(CCA)创造了便利条件，TLS历史上有多个漏洞都和CBC模式有关：</p>

<ul>
<li>The POODLE CBC oracle attack:参考:
<a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">1.POODLE的一个分析</a>
<a href="https://www.openssl.org/~bodo/tls-cbc.txt">2.openssl的分析</a>
<a href="http://drops.wooyun.org/papers/3194">3.乌云的文章</a></li>
<li>The CRIME compression attack:</li>
<li>The Lucky13 CBC padding oracle timing attack:</li>
<li>The BEAST CBC chained IV attack:</li>
</ul>


<a name="L8...SHA2"></a>
<h3>8.  SHA2</h3>

<p><a href="http://en.wikipedia.org/wiki/SHA-2">http://en.wikipedia.org/wiki/SHA-2</a></p>

<a name="L9...Curve25519"></a>
<h3>9.  Curve25519</h3>

<p><a href="http://cr.yp.to/ecdh.html">http://cr.yp.to/ecdh.html</a>
Curve25519 是目前最高水平的 Diffie-Hellman函数，适用于广泛的场景，由Daniel J. Bernstein教授设计。由于NIST P-256的设计过程不透明，有来历不明的参数，被广泛怀疑有后门，所以设计了Curve25519，Curve25519的设计过程完全公开，没有任何来历不明的参数。
部署情况：<a href="http://ianix.com/pub/curve25519-deployment.html">http://ianix.com/pub/curve25519-deployment.html</a></p>

<a name="L10...Ed25519"></a>
<h3>10.  Ed25519</h3>

<p><a href="http://ed25519.cr.yp.to/">http://ed25519.cr.yp.to/</a>
Ed25519是一个数字签名算法，</p>

<ul>
<li>签名和验证的性能都极高， 一个4核2.4GHz 的 Westmere cpu，每秒可以验证 71000 个签名</li>
<li>安全性极高，等价于RSA约3000-bit</li>
<li>签名过程不依赖随机数生成器，不依赖hash函数的防碰撞性，没有时间通道攻击的问题</li>
<li>并且签名很小，只有64字节，公钥也很小，只有32字节。
部署情况：<a href="http://ianix.com/pub/ed25519-deployment.html">http://ianix.com/pub/ed25519-deployment.html</a></li>
</ul>


<a name="L11.................."></a>
<h3>11.  前向安全性</h3>

<p>前向安全性( Perfect Forward Secrecy )
<a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html</a>
前向安全性指的是，如果攻击者抓取并保存流量，那么将来私钥泄露后，攻击者也无法利用泄露的私钥解密这些流量。</p>

<a name="L12...Diffie-Hellman............."></a>
<h3>12.  Diffie-Hellman 密钥交换</h3>

<p><a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a>
在任何一本密码学教材里面都会重点介绍的</p>

<a name="L13...constant.time.compare"></a>
<h3>13.  constant time compare</h3>

<p>针对Timing attack，<a href="http://en.wikipedia.org/wiki/Timing_attack">http://en.wikipedia.org/wiki/Timing_attack</a> （这种攻击真是脑洞大开！）
当一个算法的运行时间和输入数据有关的时候，可以根据运行时间这一信息，破解出密钥等。
典型的，比如要验证一个对称签名，如果你用了C库里面的memcmp()，那你就会被timing attack方式攻击。
因此，涉及到密码学数据的memcmp，必须要用运行时间和输入无关的函数，比如OpenSSL库里面的<code>CRYPTO_memcmp()</code></p>
]]></content>
  </entry>
  
</feed>
