<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/python/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2019-12-07T15:08:08+00:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 自动翻译成 C++ ，彻底保证离线在线特征一致]]></title>
    <link href="https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/"/>
    <updated>2019-11-29T13:54:00+00:00</updated>
    <id>https://blog.helong.info//blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering</id>
    <content type="html"><![CDATA[<hr />

<a name="L.................."></a>
<h1>一，问题背景</h1>

<p>随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。</p>

<p>机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。</p>

<a name="L1............................"></a>
<h3>1.常见的特征工程逻辑</h3>

<p>常见的特征工程逻辑有：</p>

<ol>
<li>分箱/分桶 离散化</li>
<li>log/exp 对数/幂等 math numpy 常见数学运算</li>
<li>特征缩放/归一化/截断</li>
<li>交叉特征生成</li>
<li>分词匹配程度计算</li>
<li>字符串分隔匹配判断tong</li>
<li>缺省值填充等</li>
<li>数据平滑</li>
<li>onehot 编码，hash 编码等</li>
</ol>


<p>这些特征工程代码，当然一般使用深度学习最主要的语言 <strong>python</strong> 实现。</p>

<a name="L.................."></a>
<h1>二，业务痛点</h1>

<p>离线训练完成，模型上线部署后，同样要<strong>用 C++ 重新实现</strong> 这些 python 的特征工程逻辑代码。</p>

<p>我们发现，<strong>“用 C++ 重新实现”</strong> 这个步骤，给实际业务带来了大量的问题：</p>

<ol>
<li>繁琐，费时费力，极容易出现 python 和 C++ 代码<strong>不一致</strong></li>
<li><strong>不一致</strong>会直接影响模型在线上的效果，导致大盘业务指标不如预期，产生各种 bad case</li>
<li><strong>不一致</strong>难以发现，无法测试，无法监控，经常要靠用户投诉反馈，甚至大盘数据异常才能发现</li>
</ol>


<!--more-->


<a name="L1.............."></a>
<h3>1. 业界方案</h3>

<p>针对这些问题，我调研了这些业界方案：</p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<blockquote><p>“模型线上线下一致性问题对于模型效果非常重要，我们使用特征日志来实时记录特征，保证特征的一致性。这样离线处理的时候会把实时的用户反馈，和特征日志做一个结合生成训练样本，然后更新到模型训练平台上，平台更新之后在推送到线上，这样整个排序形成了一个闭环。”</p></blockquote>

<p>总结起来，有几种思路：</p>

<ol>
<li>在线特征存储起来给离线用</li>
<li>在线 C++ 代码编译成 so 导出给离线用</li>
<li>根据一份配置生成离线和在线代码</li>
<li>提取公共代码，加强代码复用，等软件工程手段，减少不一致</li>
</ol>


<a name="L2...................."></a>
<h3>2. 自动翻译方案</h3>

<a name="L.1........................"></a>
<h4>(1) .已有方案的缺点</h4>

<p>但这些思路都有各种缺点：</p>

<ol>
<li>所有在线请求的所有特征，这个存储量数据量很大</li>
<li>算法改代码需要等待后台开发，降低了算法同学的工作效率</li>
<li>特征处理代码的复杂度转移到配置文件中，不一定能充分表达，而且配置格式增加学习成本</li>
<li>就这边真实离线特征处理代码来看，大部分代码都无法抽取出公共代码做复用。</li>
</ol>


<a name="L.2............"></a>
<h4>(2). 翻译器</h4>

<p>回到问题出发点考虑，显而易见，这个问题归根结底就是需要一个 “ python 到 c++ 的翻译器 ” 。</p>

<p>那其实 “翻译器 Transpiler ” ，和编译器解释器类似，也是个古老的热门话题了，比如 <a href="https://webassembly.org/">WebAssembly</a>, <a href="https://coffeescript.org/">CoffeeScript </a>，<a href="https://www.babeljs.cn/docs/">Babel</a> ,
<a href="https://github.com/google/closure-compiler">Google Closure Compiler</a>，<a href="https://www.netlib.org/f2c/f2c.1">f2c</a></p>

<p>于是一番搜索，发现 python 到 C++ 的翻译器也不少，其中 <a href="https://github.com/serge-sans-paille/pythran">Pythran</a> 是新兴比较热门的开源项目。</p>

<p>于是一番尝试后，借助 pythran，我们实现了：</p>

<ol>
<li>一条命令 <strong>全自动把 Python 翻译成等价 C++</strong></li>
<li>严格等价保证改写，彻底消除不一致</li>
<li><strong>完全去掉重新实现</strong> 这块工作量，后台开发成本降到 0 ，彻底解放生产力</li>
<li>算法同学继续使用纯 python，开发效率无影响，<strong> 无学习成本 </strong></li>
<li>并能推广到其他需要 <strong>python 改写成后台 C++ 代码</strong> 的业务场景，解放生产力</li>
</ol>


<a name="L......pythran................"></a>
<h1>三，pythran 的使用流程</h1>

<a name="L.1........."></a>
<h3>(1). 安装</h3>

<p>一条命令安装：
<code>bash
pip3 install pythran
</code></p>

<a name="L.2.......Python......."></a>
<h3>(2). 写 Python 代码</h3>

<p>下面这个 python demo，是 pythran 官方 demo
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">math</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.matrix_multiply.float.list.list..float.list.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">matrix_multiply</span><span class="p">(</span><span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">float</span> <span class="nb">list</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">matrix_multiply</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">):</span>
</span><span class='line'>    <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">)):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span><span class='line'>            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
</span><span class='line'>                <span class="n">new_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">m0</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">m1</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">new_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.arc_distance.float....float....float....float...&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">arc_distance</span><span class="p">(</span><span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[],</span> <span class="nb">float</span><span class="p">[])</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">arc_distance</span><span class="p">(</span><span class="n">theta_1</span><span class="p">,</span> <span class="n">phi_1</span><span class="p">,</span> <span class="n">theta_2</span><span class="p">,</span> <span class="n">phi_2</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Calculates</span> <span class="n">the</span> <span class="n">pairwise</span> <span class="n">arc</span> <span class="n">distance</span>
</span><span class='line'>    <span class="n">between</span> <span class="nb">all</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">vector</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">theta_2</span><span class="o">-</span><span class="n">theta_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span>
</span><span class='line'>           <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">phi_2</span><span class="o">-</span><span class="n">phi_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="n">distance_matrix</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">temp</span><span class="p">))</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">distance_matrix</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.dprod.int.list..int.list.&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">dprod</span><span class="p">(</span><span class="nb">int</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">dprod</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">):</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">WoW</span><span class="p">,</span> <span class="n">generator</span> <span class="n">expression</span><span class="p">,</span> <span class="nb">zip</span> <span class="ow">and</span> <span class="nb">sum</span><span class="o">.&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="n">l1</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">a</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;pythran.export.get_age.int..&quot;</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="n">export</span> <span class="n">get_age</span><span class="p">(</span><span class="nb">int</span> <span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">get_age</span><span class="p">(</span><span class="n">age</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">20</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">0</span><span class="n">_20</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">25</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">21</span><span class="n">_25</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">30</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">26</span><span class="n">_30</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">35</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">31</span><span class="n">_35</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">40</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">36</span><span class="n">_40</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">45</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">41</span><span class="n">_45</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">age</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="mi">50</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">46</span><span class="n">_50</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">age_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">50</span><span class="o">+&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">age_x</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c">### (3). Python 转成 C++</span>
</span><span class='line'><span class="err">一条命令完成翻译</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">pythran</span> <span class="o">-</span><span class="n">e</span> <span class="n">demo</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">o</span>  <span class="n">demo</span><span class="o">.</span><span class="n">hpp</span>
</span></code></pre></td></tr></table></div></figure></p>

<a name="L.4.......C..............."></a>
<h3>(4). 写 C++ 代码调用</h3>

<p>pythran/pythonic/ 目录下是 python 标准库的 C++ 等价实现，翻译出来的C++ 代码需要 include 这些头文件</p>

<p>写个 C++ 代码调用</p>

<pre><code class="cpp">
#include "demo.hpp"
#include "pythonic/numpy/random/rand.hpp"
#include &lt;iostream&gt;

using std::cout;
using std::endl;

int main() {
  pythonic::types::list&lt;pythonic::types::list&lt;double&gt;&gt; m0 = { {2.0, 3.0},
                                                             {4.0, 5.0} },
                                                       m1 = { {1.0, 2.0},
                                                             {3.0, 4.0} };
  cout &lt;&lt; m0 &lt;&lt; "*" &lt;&lt; m1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::matrix_multiply()(m0, m1) &lt;&lt; endl
       &lt;&lt; endl;

  auto theta_1 = pythonic::numpy::random::rand(3),
       phi_1 = pythonic::numpy::random::rand(3),
       theta_2 = pythonic::numpy::random::rand(3),
       phi_2 = pythonic::numpy::random::rand(3);
  cout &lt;&lt; "arc_distance " &lt;&lt; theta_1 &lt;&lt; "," &lt;&lt; phi_1 &lt;&lt; "," &lt;&lt; theta_2 &lt;&lt; ","
       &lt;&lt; phi_2 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::arc_distance()(theta_1, phi_1, theta_2, phi_2) &lt;&lt; endl
       &lt;&lt; endl;

  pythonic::types::list&lt;int&gt; l0 = {2, 3}, l1 = {4, 5};
  cout &lt;&lt; "dprod " &lt;&lt; l0 &lt;&lt; "," &lt;&lt; l1 &lt;&lt; "\n=\n"
       &lt;&lt; __pythran_demo::dprod()(l0, l1) &lt;&lt; endl
       &lt;&lt; endl;

  cout &lt;&lt; "get_age 30 = " &lt;&lt; __pythran_demo::get_age()(30) &lt;&lt; endl &lt;&lt; endl;

  return 0;
}
</code></pre>

<a name="L.5..............."></a>
<h3>(5). 编译运行</h3>

<pre><code class="sh">g++ -g -std=c++11 main.cpp -fopenmp -march=native -DUSE_XSIMD -I /usr/local/lib/python3.6/site-packages/pythran/ -o pythran_demo  

./pythran_demo
</code></pre>

<a name="L......pythran..................."></a>
<h1>四，pythran 的功能与特性</h1>

<a name="L.1........."></a>
<h3>(1). 介绍</h3>

<p>按官方定义，Pythran 是一个 AOT (Ahead-Of-Time - 预先编译) 编译器。 给科学计算的 python 加注解后，pythran 可以把 python 代码变成接口相同的原生 python 模块，大幅度提升性能。</p>

<p>并且 pythran 也可以利用 OpenMP 多核和 SIMD 指令集。</p>

<p>支持 python 3 和 Python 2.7 。</p>

<p>pythran 的 manual 挺详细：
<a href="https://pythran.readthedocs.io/en/latest/MANUAL.html">https://pythran.readthedocs.io/en/latest/MANUAL.html</a></p>

<a name="L.2........."></a>
<h3>(2). 功能</h3>

<p>pythran 并不支持完整的python， 只支持 python 语言特性的一个子集:</p>

<ul>
<li>polymorphic functions 多态函数(翻译成 C++ 的泛型模板函数)</li>
<li>lambda</li>
<li>list comprehension  列表推导式</li>
<li>map, reduce 等函数</li>
<li>dictionary, set, list 等数据结构</li>
<li>exceptions 异常</li>
<li>file handling 文件处理</li>
<li>部分 numpy</li>
</ul>


<p>不支持的功能：</p>

<ul>
<li>classes 类</li>
<li>polymorphic variables 可变类型变量</li>
</ul>


<a name="L.3................................."></a>
<h3>(3). 支持的数据类型和函数</h3>

<p>pythran export  可以导出函数和全局变量。
支持导出的数据类型，BNF 定义是：</p>

<pre><code class="antlr">    argument_type = basic_type
                  | (argument_type+)    # this is a tuple
                  | argument_type list    # this is a list
                  | argument_type set    # this is a set
                  | argument_type []+    # this is a ndarray, C-style
                  | argument_type [::]+    # this is a strided ndarray
                  | argument_type [:,...,:]+ # this is a ndarray, Cython style
                  | argument_type [:,...,3]+ # this is a ndarray, some dimension fixed
                  | argument_type:argument_type dict    # this is a dictionary

    basic_type = bool | byte | int | float | str | None | slice
               | uint8 | uint16 | uint32 | uint64 | uintp
               | int8 | int16 | int32 | int64 | intp
               | float32 | float64 | float128
               | complex64 | complex128 | complex256
</code></pre>

<p>可以看到基础类型相当全面，支持各种 整数，浮点数，字符串，复数</p>

<p>复合类型支持 tuple, list, set, dict, numpy.ndarray 等，</p>

<p>对应 C++ 代码的类型实现在  pythran/pythonic/include/types/  下面，可以看到比如 dict 实际就是封装了一下 std::unordered_map
<a href="https://pythran.readthedocs.io/en/latest/SUPPORT.html">https://pythran.readthedocs.io/en/latest/SUPPORT.html</a>
可以看到支持的 python 基础库，其中常用于机器学习的 numpy 支持算比较完善。</p>

<a name="L......pythran................"></a>
<h1>五，pythran 的基本原理</h1>

<p>和常见的编译器/解释器类似， pythran 的架构是分成 3 层：</p>

<ol>
<li>python 代码解析成抽象语法树 AST 。用 python 标准库自带的的 ast 模块实现</li>
<li>代码优化。
 在 AST 上做优化，有多种 transformation pass，比如 deadcode_elimination 死代码消除，loop_full_unrolling  循环展开 等。还有 Function/Module/Node 级别的 Analysis，用来遍历 AST 供 transformation 利用。</li>
<li>后端，实现代码生成。目前有2个后端，Cxx / Python，  Cxx 后端可以把 AST 转成 C++ 代码（ Python 后端用来调试）。</li>
</ol>


<p>目前看起来 ，pythran 还欠缺的：</p>

<ol>
<li>字符串处理能力欠缺，缺少 str.encode()/str.decode() 对 utf8 的支持</li>
<li>缺少正则表达式 regex 支持</li>
<li>缺少 json 支持</li>
</ol>


<p>看文档要自己加也不麻烦，看业务需要可以加。</p>

<a name="L.................."></a>
<h1>六，相关文章</h1>

<p>《京东电商推荐系统实践》
<a href="https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW">https://www.infoq.cn/article/1OkKmb_gEYNR3YqC9RcW</a></p>

<p>《自主研发、不断总结经验，美团搜索推荐机器学习平台》
<a href="https://cloud.tencent.com/developer/article/1357309">https://cloud.tencent.com/developer/article/1357309</a></p>

<p>《推荐系统中模型训练及使用流程的标准化》
<a href="https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3">https://www.infoq.cn/article/2E6LCqb1GeqFRAjkkjX3</a></p>

<p>numba
<a href="http://numba.pydata.org">http://numba.pydata.org</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个使用KuaiPan备份linux服务器的脚本]]></title>
    <link href="https://blog.helong.info//blog/2014/02/08/%25e4%25b8%2580%25e4%25b8%25aa%25e4%25bd%25bf%25e7%2594%25a8kuaipan%25e5%25a4%2587%25e4%25bb%25bdlinux%25e6%259c%258d%25e5%258a%25a1%25e5%2599%25a8%25e7%259a%2584%25e8%2584%259a%25e6%259c%25ac/"/>
    <updated>2014-02-08T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2014/02/08/%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8kuaipan%e5%a4%87%e4%bb%bdlinux%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e8%84%9a%e6%9c%ac</id>
    <content type="html"><![CDATA[<p>近日需要给服务器做备份，在网上找到了一个现成的金山快盘的api：<a href="https://github.com/deren/python-kuaipan" target="_blank"><a href="https://github.com/deren/python-kuaipan">https://github.com/deren/python-kuaipan</a></a> （感谢！）<br/>
试了一下，遂决定备份到金山快盘上。</p>

<p>备份脚本考虑了以下几个方面的要求：<br/>
1.上传之前一定要加密，对比之后，使用了openssl的aes-256-cbc加密算法<br/>
2.增量备份，最开始尝试用<a href="http://duplicity.nongnu.org" target="_blank">duplicity</a> ,写了一个duplicity的backend，然后发现，好复杂！猛然发现，linux上的tar就有<a href="http://www.gnu.org/software/tar/manual/html_node/Incremental-Dumps.html#Incremental-Dumps" target="_blank">增量备份功能</a>，于是直接用了tar<br/>
3.分卷，KuaiPan有文件大小限制，此处用了split把tar文件分卷</p>

<p>代码放在 <a href="https://github.com/windydays/kuaipan_backup" target="_blank"><a href="https://github.com/windydays/kuaipan_backup">https://github.com/windydays/kuaipan_backup</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Http Proxy Script]]></title>
    <link href="https://blog.helong.info//blog/2013/11/18/a-http-proxy-script/"/>
    <updated>2013-11-18T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2013/11/18/a-http-proxy-script</id>
    <content type="html"><![CDATA[<pre><code class="python">#!/usr/local/bin/python
# -*- coding: utf-8 -*-

import base64
import select
import socket
import httplib
import os
import sys
#base64.encodestring("das\120xsdada\s")

def usage ():
    print "connect_to_http_proxy %s"
    print "usage: connect_to_http_proxy &amp;lt;desthost&amp;gt; &amp;lt;destport&amp;gt;"

if len(sys.argv) != 3:
    usage()
    print sys.argv
    sys.exit()

proxy_host="web-proxy-domain.com"
proxy_port="8080"
dest_host=""
dest_port=""
dest_host, dest_port=sys.argv[1:]

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((proxy_host,int(proxy_port)))
sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
req="CONNECT "+dest_host+":"+dest_port + " HTTP/1.0\r\n\r\n"
sock.send(req)
resp=sock.recv(100000)
if resp.find("200") &amp;lt; 0:
    print req,resp
    exit(-1)

ep=select.epoll()
ep.register(sock.fileno(),select.EPOLLIN)
ep.register(sys.stdin.fileno(),select.EPOLLIN)
while True:
    events=ep.poll(1,2)
    for fd,event in events:
        if event &amp; select.EPOLLERR:
            sys.exit(0)
        if event &amp; select.EPOLLIN and fd==sock.fileno():
            os.write(sys.stdout.fileno(),sock.recv(1024*100)) 
        if event &amp; select.EPOLLIN and fd==sys.stdin.fileno():
            os.write(sock.fileno(),sys.stdin.read()) 

#conn=httplib.HTTPConnection(proxy_host+":"+proxy_port)
#conn.request("CONNECT",dest_host+":"+dest_port)
#res=conn.getresponse()
#print res.read()
#if res.status != 200:
#    print res.status,res.reason
#    sys.exit()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个基于约束传播的，玩具级微型计算语言的设计和简单实现]]></title>
    <link href="https://blog.helong.info//blog/2012/04/09/%25e4%25b8%2580%25e4%25b8%25aa%25e5%259f%25ba%25e4%25ba%258e%25e7%25ba%25a6%25e6%259d%259f%25e4%25bc%25a0%25e6%2592%25ad%25e7%259a%2584%25ef%25bc%258c%25e7%258e%25a9%25e5%2585%25b7%25e7%25ba%25a7%25e5%25be%25ae%25e5%259e%258b%25e8%25ae%25a1%25e7%25ae%2597%25e8%25af%25ad%25e8%25a8%2580%25e7%259a%2584%25e8%25ae%25be%25e8%25ae%25a1/"/>
    <updated>2012-04-09T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2012/04/09/%e4%b8%80%e4%b8%aa%e5%9f%ba%e4%ba%8e%e7%ba%a6%e6%9d%9f%e4%bc%a0%e6%92%ad%e7%9a%84%ef%bc%8c%e7%8e%a9%e5%85%b7%e7%ba%a7%e5%be%ae%e5%9e%8b%e8%ae%a1%e7%ae%97%e8%af%ad%e8%a8%80%e7%9a%84%e8%ae%be%e8%ae%a1</id>
    <content type="html"><![CDATA[<p>这个程序就是做来玩和练习的，代码是玩具级别的，用的python，基本可以正常工作了。</p>

<p>先介绍应用背景：</p>

<p>在流体机械设计中，通常根据性能参数进行设计，算出其它变量，但问题是，在设计过程中，需要进行变量的<strong>手工调整</strong>，例如圆整，修正到某一范围，校核等等。</p>

<p>其计算模式举例如下：</p>

<p>1.定义变量，如输入压力P<sub><span style="font-size: 12px;">in</span></sub>=0.98，输入温度T<sub>in</sub>=27,输入流量Q<sub>vin</sub>=400,k<sub>v2，</sub>φ<sub>2r，</sub>b2，D2，u2，qin等等。。。</p>

<p>2.根据某些物理公式，算出几个新的量，如转速 n=33.9<em>sqrt(k<sub>v2</sub></em>φ<sub>2r<em></sub>b2/D2</em>(u2<sup>3</sup>)/qin)</p>

<p>3.把n从8296.93圆整为整数8300，</p>

<p>4.重新计算b2/D2=0.06455，校核可知0.02&lt;0.06455&lt;0.065，符合要求</p>

<p>5.根据n计算出其它新的变量，修正，校核。。。</p>

<p>。。。</p>

<p>观察可以发现，这种计算模式，和《计算机程序的构造与解释》中提到的约束传播系统很像，如果把一个变量看作一个对象，那么，当它位于一个公式的左侧，例如n，也就意味着，右侧变量例如k<sub>v2</sub>更新时，应该给它发送一个消息，让它重新计算自己的值，当n更新后，如果它发现有别的变量依赖于自己，它应该发消息通知它们更新自己的值。</p>

<p>还可以看出，这种依赖关系形成了一个图，例如应该有一条从k<sub>v2</sub>到n的边，把n称为k<sub>v2</sub>的订阅者。</p>

<p>所以这种计算模式可以用约束传播系统建模，但是此处和书里的约束传播系统有差异：此处的约束传播系统是<strong>有向图</strong>，而书里是无向图，设计成有向图主要是为了简单，无向图的消息发送顺序是难以控制的，而且构造的时候公式中的每个变量都要持有其它对象的引用，太麻烦，有向图只需要在公式左侧的那个变量哪里保存公式右侧的每个变量的引用。</p>

<p>形成有向图后，每个变量的状态设为invaild，这种状态下，不会向它的会订阅者发送更新消息，收到获取值的消息时报错。</p>

<p>有向图中，还有一些源点，是最初给定值的变量。</p>

<p>当某个变量被赋值时，它把自己设为新值，同时向它的订阅者发送更新消息。订阅者计算自己的新值，如果和旧值相同，就沉默；否则，更新自己，通知订阅者更新。</p>

<p>so，想象一下，在你的面前，虚空之中漂浮着一张有向图， 由k<sub>v2</sub>&#8212;>n这样的一条条边练成，当一个点被赋予值，从这点荡出一圈圈涟漪，传到它的下一级，再从更新过的点荡出新的波纹，传开，传开。。。直到所有的点都收敛，水面恢复宁静。</p>

<p>&nbsp;</p>

<!--more-->


<p>好了，说代码，每一个变量都要保存它的订阅者，它的表达式，注意到，数字1.1是一种变量，变量a是一种表达式，所以代码如下：</p>

<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
变量is-a表达式
数值is-a表达式
故有如下继承关系

通过env的符号表可以查到Expr的实例
"""
__all__ = ['Expr','Var','Number']

class Expr(object):
    op=""               #a function
    parameters=[]       #Expr list
    desc=""

    def __init__(self,op,paras,desc=""):
        self.op=op
        self.parameters=paras
        self.desc=desc

    def get_value(self):
        pl=[p.get_value() for p in self.parameters]
        return self.op(*pl)

    def set_desc(self,d):
        self.desc=d

    def dump(self):
        pas=[]
        if len(self.parameters):
            pas=[s.dump() for s in self.parameters]
        pas.insert(0, '('+self.op.__name__)
        return ' '.join(pas) + ')'


class Number(Expr):
    value=0.0
    def __init__(self,v):
        self.value=v

    def get_value(self):
        return self.value

    def dump(self):
        return str(self.value)

    def update(self):
        pass

class Var(Expr):
    name=""
    desc=""
    expr=None
    value=0.0
    subscribers=[]
    state="invaild"

    def __init__(self,name,desc=""):
        self.name=name
        self.desc=desc
        self.state="invaild"

    def broadcast(self):
        for s in self.subscribers:
            s.update()

    def update(self):
        self.state="normal"
        new_value=self.expr.get_value()
        if new_value == self.value:
            return
        self.value=new_value
        self.broadcast()

    def set_expr(self,exp):
        self.expr=exp
        if isinstance(exp,Number):
            self.update()

    def set_value(self,v):
        self.value=v
        self.state="normal"
        self.broadcast()

    def get_value(self):
        if self.state=="invaild":
            self.update()
        assert self.state=="normal"
        return self.value

    def subscribe(self,subs):
        for sub in subs:
            self.subscribers.append(sub)

    def dump(self):
        expr_d=""
        if self.expr:
            expr_d=' '+self.expr.dump()
        return str(self.name) +"="+str(self.value)+expr_d#+" "+self.desc


def test():
    a=Var("a","变量a")
    b=Var("b","变量b")

if __name__=="__main__":
    test()
</code></pre>

<p>所有的变量当然是要保存到一个符号表（或称环境）里的，同时，这个环境里还要有加减乘除，sin，sqrt这样的基本运算的定义，pi，e这样的常数的定义，python的operator和math模块就够用了。</p>

<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import math
import operator
from expr import Var,Number,Expr
from parser import Parser

class CmdFilter(object):
    def __init__(self,env,input_file):
        self.env=env
        self.input_file=input_file

    def readline(self):
        while True:
            s=self.input_file.readline()
            if not s:
                return s
            if self.env.filter_cmd(s):
                return s

class Env(object):
    """
    求值环境，提供变量符号表和函数符号表
    """
    symbol_table={} #存放变量
    expr_table=[]   #存放自由表达式
    function_table={}#存放函数，对外只读
    cmds=['dump','run']    #env先于parser处理掉一些命令,如dump
    parser=None

    def __init__(self):
        self.fill_function_table()
        self.fill_symbol_table()
        self.parser=Parser(self)

    def dump(self):
        print "-"*70,"\ndump all variables and expressions:"
        for k,v in self.symbol_table.items():
            print k+":",v.get_value()
        print "\nall checkings:"
        for e in self.expr_table:
            print e.get_value(),"=",e.dump()
        print "-"*70

    def run(self):
        for k,v in self.symbol_table.items():
            v.update()

    def fill_function_table(self):
        #算术运算符
        #1.+,-,*,/,^,=,(,)   算术运算符
        self.function_table['+']=operator.add
        self.function_table['-']=operator.sub
        self.function_table['*']=operator.mul
        self.function_table['/']=operator.div
        self.function_table['^']=operator.pow
        #逻辑运算符
        #2.==,&gt;=,&gt;,&amp;lt;=,&amp;lt;,!=   逻辑运算符
        self.function_table['==']=operator.eq
        self.function_table['&gt;=']=operator.ge
        self.function_table['&gt;']=operator.gt
        self.function_table['&amp;lt;=']=operator.le
        self.function_table['&amp;lt;']=operator.lt
        self.function_table['!=']=operator.ne
        self.function_table['sqrt']=math.sqrt
        self.function_table['sin']=math.sin
        self.function_table['cos']=math.cos
        self.function_table['tan']=math.tan
        self.function_table['asin']=math.asin
        self.function_table['acos']=math.acos
        self.function_table['atan']=math.atan
        self.function_table['exp']=math.exp
        self.function_table['pow']=math.pow
        self.function_table['factorial']=math.factorial
        self.function_table['fabs']=math.fabs
        self.function_table['ln']=math.log
        self.function_table['log10']=math.log10


    def fill_symbol_table(self):
        self.symbol_table['pi']=Number(math.pi)
        self.symbol_table['e'] =Number(math.e)

    def add_expr(self,e):
        if e:
            self.expr_table.append(e)

    def get_function(self,name):
        if self.function_table.has_key(name):
            return self.function_table[name]
        else:
            return None

    def get_variable(self,name):
        if self.symbol_table.has_key(name):
            return self.symbol_table[name]
        else:
            return None

    def set_variable(self,name,var):
        self.symbol_table[name]=var

    def filter_cmd(self,s):
        s=s.strip()
        if s in self.cmds:
            fun=getattr(self,s)
            fun()
            return None
        return s

    def exec_stream(self,in_file):
        input_file=CmdFilter(self,in_file)
        self.parser.parse(input_file)

import sys
def test():
    env=Env()
    env.exec_stream(sys.stdin)

if __name__=="__main__":
    test()
</code></pre>

<p>接下来，词法分析和语法分析，词法分析没有手写，也没有用flex那样的工具，直接用了一排正则表达式，挨个往下匹配，匹配上了就返回。</p>

<p>严格来说，这个是不太好的，此处的词法分析原理上是不能和flex比的，flex里的多个正则表达式是合并到一个NFA里，再转化成一个DFA的，所以它的规则首先是最长优先，其次是长度相同时写在前面的优先，此处只有写在前面的优先，不太好。</p>

<p>语法分析是递归下降文法分析。一行一行地分析，一行是一个token的list。</p>

<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
from math import *
from operator import *
import re
from expr import Var,Number,Expr

""" 把
a=1+b+c^2
c=2
b=c+2
这样的一行一行，分成
ID ASSIGN ADD ID ADD EQ POW 2 EOL
ID ASSIGN 2 EOL
ID ASSIGN ID ADD 2 EOL
这样的一行一行token,
输出是一行一个token list的形式

token分为如下几类:
1.+,-,*,/,^,=,(,),,   算术运算符
2.==,&gt;=,&gt;,&lt;=,&lt;,!=   逻辑运算符
3.[0-9]+\.[0-9]*[Ee][+-]?[0-9]+  [0-9]+ 字面浮点数和整数
4.[a-zA-Z_]+        变量或函数名称标识符
5.[ \\t\\n]           忽略，或结束

由于使用正则表达式直接匹配，所以和flex不同的是:
无法确保当有多个匹配项时，最长优先,因此，只能利用先后顺序解决冲突，
因而必须把==放在=前面。
"""
logic_op_re=re.compile(r'==|&gt;=|&gt;|&lt;=|&lt;|!=')
number_re  =re.compile(r'[+-]?[0-9]+\.?[0-9]*[Ee]?[+-]?[0-9]?') 
arith_op_re=re.compile(r'\+|-|\*|/|\^|=|\(|\)|,')
int_re     =re.compile(r'[0-9]+')
id_re      =re.compile(r'[a-zA-Z_]+')
blank_re   =re.compile(r'[\ |\t|\r]+')
comment_re =re.compile(r'"([^"]*)"')
other_re   =re.compile(r'.+')

def scanner(line):
    result=[]
    while True:
        line=line.strip()
        if not line:
            return result

        m=re.match(logic_op_re,line)
        if m:
            result.append(('logic_op',m.group()))
            line=line[m.end():]
            continue

        m=re.match(number_re  ,line)
        if m:
            result.append(('number',float(m.group())))
            line=line[m.end():]
            continue

        m=re.match(arith_op_re,line)
        if m:
            result.append(('arith_op',m.group()))
            line=line[m.end():]
            continue

        m=re.match(int_re     ,line)
        if m:
            result.append(('number',float(m.group())))
            line=line[m.end():]
            continue

        m=re.match(id_re      ,line)
        if m:
            result.append(('id',m.group()))
            line=line[m.end():]
            continue

        m=re.match(comment_re ,line)
        if m:
            result.append(('comment',m.group()))
            line=line[m.end():]
            continue

        m=re.match(blank_re   ,line)
        if m:
            line=line[m.end():]
            continue

        m=re.match(other_re,line)
        if m:
            print "亲，看看你都塞了一堆什么进来呀？\""+m.group()+"\" 人家好伤心的呀！" 
            line=line[m.end():]
            return result

class Parser(object):
    """ 文法分析： """
    input_file=None
    env=None

    def __init__(self,env):
        self.env=env

    def parse(self,input_file):
        """
        如入可以是sys.stdin,a file,a string
        要求实现readline()方法
        """
        self.input_file=input_file
        self.run()

    def run(self):
        while True:
            line=self.input_file.readline()
            if not line:
                return
            tokens=scanner(line)

            #把字母名称的函数标示出来
            r=[]
            for t in tokens:
                if t[0]=='id' and self.env.get_function(t[1]):
                    r.append(('function',t[1]))
                else:
                    r.append(t)

            tokens=r

            #把comment提取出来
            comments=map(lambda x:x[1],
                         filter(lambda x:x[0]=="comment",tokens))
            comments=' '.join(comments)
            tokens=filter(lambda x:x[0]!="comment",tokens)

            #含有=的表达式是约束方程，其它的都是expr
            c=tokens.count( ('arith_op', '='))
            if c==0:
                #没有约束到变量的表达式
                e=self.parse_expr(tokens)
                #e.set_desc(comments)
                self.env.add_expr(e)
                continue

            if c&gt;1:
                print "亲，赋值一次就够了，你肿么赋值了"+str(c)+"次涅？"
                continue

            #c=1
            if len(tokens)&lt;3 or tokens[0][0]!='id' or \
               tokens[1]!=('arith_op','='):
                print "亲，你给我的表达式格式有问题偶～:"+line
                continue

            var_name=tokens[0][1]
            var=self.env.get_variable(var_name) 
            if var is None:
                var=Var(var_name,comments)
                self.env.set_variable(var_name,var)

            e=self.parse_expr(tokens[2:])
            var.set_expr(e)

    def parse_expr(self,tokens):
        """
        token分为如下几类:
        1.+,-,*,/,^,=,(,),,   算术运算符
        2.==,&gt;=,&gt;,&lt;=,&lt;,!=   逻辑运算符
        3.[0-9]+\.[0-9]*[Ee][+-]?[0-9]+  [0-9]+ 字面浮点数和整数
        4.[a-zA-Z_]+        变量或函数名称标识符
        5.[ \\t\\n]           忽略，或结束

        BNF:
        expr=expr[==|&gt;=|&gt;|&lt;=|&lt;|!=]expr|expr
        expr=expr+expr | expr-expr
        expr=expr*expr | expr/expr
        expr=expr^expr
        expr=function(expr[,expr])
        expr=(expr)
        expr=&lt;float&gt;|&lt;var&gt;
        """
        if len(tokens):
            expr,rest=self.parse_logic_op(tokens)
            return expr

    #能处理就处理，不能处理原样返回。
    def parse_logic_op(self,tokens):
        left,rest=self.parse_add_sub_op(tokens)
        if not len(rest):
            return left,rest

        logic_op_list=["==","&gt;=","&gt;","&lt;=","&lt;","!="]

        if rest[0][1] not in logic_op_list:
            return left,rest

        op=self.env.get_function(rest[0][1])
        right,rest=self.parse_add_sub_op(rest[1:])
        return Expr(op,[left,right]),rest

    def parse_add_sub_op(self,tokens):
        left,rest=self.parse_mul_div_op(tokens)
        add_sub_op_list=["+","-"]

        while len(rest) and rest[0][1] in add_sub_op_list:
            op=self.env.get_function(rest[0][1])
            right,rest=self.parse_mul_div_op(rest[1:])
            left=Expr(op,[left,right])

        return left,rest

    def parse_mul_div_op(self,tokens):
        left,rest=self.parse_pow_op(tokens)
        mul_div_op_list=["*","/"]

        while len(rest) and rest[0][1] in mul_div_op_list:
            op=self.env.get_function(rest[0][1])
            right,rest=self.parse_pow_op(rest[1:])
            left=Expr(op,[left,right])

        return left,rest

    def parse_pow_op(self,tokens):
        left,rest=self.parse_function_op(tokens)
        pow_op_list=["^"]

        while len(rest) and (rest[0][1] in pow_op_list):
            op=self.env.get_function(rest[0][1])
            right,rest=self.parse_pow_op(rest[1:])
            left=Expr(op,[left,right])
        return left,rest

    def parse_function_op(self,tokens):
        if tokens[0][0] in ['number','id']:
            return self.parse_float_var_op(tokens)
        if tokens[0][1]=='(':
            return self.parse_parentheses_op(tokens)

        if tokens[0][0]!='function':
            return None,tokens

        op=self.env.get_function(tokens[0][1])
        if op and tokens[1][1]=='(':
                paras=[]
                tokens=tokens[2:]
                left,tokens=self.parse_add_sub_op(tokens)
                paras.append(left)
                while tokens[0][1]==',':
                    left,tokens=self.parse_add_sub_op(tokens[1:])
                    paras.append(left)
                if tokens[0][1]==')':
                    tokens=tokens[1:]
                else:
                    print "bad syntax. tokens found -&gt;",tokens

                expr=Expr(op,paras)
                return expr,tokens
        else:
            print "error bad syntax -&gt;",tokens
        return None,tokens

    def parse_parentheses_op(self,tokens):
        if tokens[0][1]=='(':
            left,tokens=self.parse_logic_op(tokens[1:])
            if tokens[0][1]==')':
                return left,tokens[1:]
            return left,tokens
        return None,tokens

    def parse_float_var_op(self,tokens):
        if tokens[0][0] == 'number':
            n=Number(tokens[0][1])
            return n,tokens[1:]
        if tokens[0][0] == 'id':
            var=self.env.get_variable(tokens[0][1]) 
            if not var:
                var_name=tokens[0][1]
                var=Var(var_name,'')
                self.env.set_variable(var_name,var)
                var=self.env.get_variable(tokens[0][1]) 
            return var,tokens[1:]
        return None,tokens


import StringIO
from env import *
def test():
    s=""" a=1+(b+c)^2/23.1e-10 "变量a"
    c=2  "变量c" "c是个好变量"
    b=c+2 "变量b" "b也是个好变量" "这是为它写的第三条注释"
    a&gt;c  "检查a是否大于c"
    a&gt;=c  "检查a是否大于等于c"
    run
    dump
    c=3   "change c again."
    "注释也可以在前面" c^2&gt;=sin(pow(a,b)+b)
    run
    dump
    """
    #for l in s.split('\n'):
    #    scanner(l)
    print "+"*80
    print '*'*70
    print s
    print '*'*70
    e=Env()
    i=StringIO.StringIO(s)
    e.exec_stream(i)
    print "+"*80

if __name__=="__main__":
    test()
</code></pre>

<p>  最后是个main.py</p>

<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
from env import Env
import StringIO

e=Env()
e.exec_stream(sys.stdin)

s=""" x=-1"""
i=StringIO.StringIO(s)
e.exec_stream(i)
</code></pre>
]]></content>
  </entry>
  
</feed>
