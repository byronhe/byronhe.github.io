<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/linux/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2019-09-22T20:56:38+08:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[博客迁移到octopress]]></title>
    <link href="https://blog.helong.info//blog/2014/03/24/move-to-octopress/"/>
    <updated>2014-03-24T00:00:00+08:00</updated>
    <id>https://blog.helong.info//blog/2014/03/24/move-to-octopress</id>
    <content type="html"><![CDATA[<p>wordpress的编辑器混淆了 结构 和 表现
而markdown，类似latex，结构和表现分离，更符合我的偏好。</p>

<p>在vim里面写博客，更能激起人的写作欲望，浏览器里面，容易转移注意力。</p>

<p>octopress的博客还可以用git做版本管理，备份。</p>

<p>octopress内置了代码格式化，着色。</p>

<p>这些都比wordpress更适合做技术博客。</p>

<p>从wordpress导出数据使用了  <a href="https://github.com/benbalter/wordpress-to-jekyll-exporter">https://github.com/benbalter/wordpress-to-jekyll-exporter</a></p>

<p>评论使用了 <a href="https://disqus.com">https://disqus.com</a> ，只需要申请一个账号，然后填到_config.yml里面，就行了</p>

<p>google analytics也是，只需要申请，然后把ID填入_config.yml就ok了。</p>

<p>octopress并不适合放在 xxx.com/blog/ 这样的目录下面，一些js脚本不支持目录，
最好放在独立域名下面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个使用KuaiPan备份linux服务器的脚本]]></title>
    <link href="https://blog.helong.info//2014/02/08/%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8kuaipan%e5%a4%87%e4%bb%bdlinux%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e8%84%9a%e6%9c%ac/"/>
    <updated>2014-02-08T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2014/02/08/%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8kuaipan%e5%a4%87%e4%bb%bdlinux%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e8%84%9a%e6%9c%ac</id>
    <content type="html"><![CDATA[<p>近日需要给服务器做备份，在网上找到了一个现成的金山快盘的api：<a href="https://github.com/deren/python-kuaipan" target="_blank"><a href="https://github.com/deren/python-kuaipan">https://github.com/deren/python-kuaipan</a></a> （感谢！）<br/>
试了一下，遂决定备份到金山快盘上。</p>

<p>备份脚本考虑了以下几个方面的要求：<br/>
1.上传之前一定要加密，对比之后，使用了openssl的aes-256-cbc加密算法<br/>
2.增量备份，最开始尝试用<a href="http://duplicity.nongnu.org" target="_blank">duplicity</a> ,写了一个duplicity的backend，然后发现，好复杂！猛然发现，linux上的tar就有<a href="http://www.gnu.org/software/tar/manual/html_node/Incremental-Dumps.html#Incremental-Dumps" target="_blank">增量备份功能</a>，于是直接用了tar<br/>
3.分卷，KuaiPan有文件大小限制，此处用了split把tar文件分卷</p>

<p>代码放在 <a href="https://github.com/windydays/kuaipan_backup" target="_blank"><a href="https://github.com/windydays/kuaipan_backup">https://github.com/windydays/kuaipan_backup</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Http Proxy Script]]></title>
    <link href="https://blog.helong.info//2013/11/18/a-http-proxy-script/"/>
    <updated>2013-11-18T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2013/11/18/a-http-proxy-script</id>
    <content type="html"><![CDATA[<pre><code class="python">#!/usr/local/bin/python
# -*- coding: utf-8 -*-

import base64
import select
import socket
import httplib
import os
import sys
#base64.encodestring("das\120xsdada\s")

def usage ():
    print "connect_to_http_proxy %s"
    print "usage: connect_to_http_proxy &amp;lt;desthost&amp;gt; &amp;lt;destport&amp;gt;"

if len(sys.argv) != 3:
    usage()
    print sys.argv
    sys.exit()

proxy_host="web-proxy-domain.com"
proxy_port="8080"
dest_host=""
dest_port=""
dest_host, dest_port=sys.argv[1:]

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((proxy_host,int(proxy_port)))
sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
req="CONNECT "+dest_host+":"+dest_port + " HTTP/1.0\r\n\r\n"
sock.send(req)
resp=sock.recv(100000)
if resp.find("200") &amp;lt; 0:
    print req,resp
    exit(-1)

ep=select.epoll()
ep.register(sock.fileno(),select.EPOLLIN)
ep.register(sys.stdin.fileno(),select.EPOLLIN)
while True:
    events=ep.poll(1,2)
    for fd,event in events:
        if event &amp; select.EPOLLERR:
            sys.exit(0)
        if event &amp; select.EPOLLIN and fd==sock.fileno():
            os.write(sys.stdout.fileno(),sock.recv(1024*100)) 
        if event &amp; select.EPOLLIN and fd==sys.stdin.fileno():
            os.write(sock.fileno(),sys.stdin.read()) 

#conn=httplib.HTTPConnection(proxy_host+":"+proxy_port)
#conn.request("CONNECT",dest_host+":"+dest_port)
#res=conn.getresponse()
#print res.read()
#if res.status != 200:
#    print res.status,res.reason
#    sys.exit()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libpcap试玩]]></title>
    <link href="https://blog.helong.info//2013/08/04/libpcap%e8%af%95%e7%8e%a9/"/>
    <updated>2013-08-04T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2013/08/04/libpcap%e8%af%95%e7%8e%a9</id>
    <content type="html"><![CDATA[<p>libpcap驱动了tcpdump,和wireshark这类抓包工具.提供了高度灵活的包过滤语言. 据wikipedia,高性能的包过滤最早是在bsd上作为一个问题被解决,被称为bpf,在内核实现了一个解释器,进行包匹配,用户态提供一个字符设备, linux作为后来者,支持与bsd基本相同的packet filter,称为lpf,不同的是,linux是通过在一个raw socket来支持包过滤的,通过setsockopt来SO_ATTACH_FILTER,挂载过滤器. strace 可知,libpcap实际上进行了如下syscall:</p>

<pre>socket(PF_PACKET, SOCK_RAW, 768) = 59 
setsockopt(59, SOL_SOCKET, SO_ATTACH_FILTER, "\1\0\0\0\0\0\0\0\250\327Vc\375\177\0\0", 16) = 0</pre>


<p>libpcap的api文档和demo代码可以参见</p>

<ol>
<li><a href="http://www.tcpdump.org/pcap3_man.html" target="_blank"><a href="http://www.tcpdump.org/pcap3_man.html">http://www.tcpdump.org/pcap3_man.html</a></a></li>
<li><a href="http://www.tcpdump.org/sniffex.c" target="_blank"><a href="http://www.tcpdump.org/sniffex.c">http://www.tcpdump.org/sniffex.c</a></a></li>
</ol>


<p>参考文档了demo,我写了一个小的sniffer,</p>

<!--more-->


<p>如下:</p>

<pre><code class="cpp">class Sniffer{
public:
    Sniffer():handle(NULL),cap_exp(""),net_if("any"),exp_compiled(false){}
    ~Sniffer(){
        if(handle){
            pcap_freecode(&amp;filter_code);
        }
        if(exp_compiled){
            pcap_close(handle);
        }
    }
    string help(){
        string h("avaliable net_interface:");
        pcap_if_t* alldev=NULL;
        if(0==pcap_findalldevs(&amp;alldev, errbuf)){
            for(pcap_if_t * dev =alldev;NULL!=dev;dev=dev-&amp;gt;next){
                h+=dev-&amp;gt;name;
                h+=" ";
            }
            pcap_freealldevs(alldev);
        }
        char * default_if=pcap_lookupdev(errbuf);
        if(default_if){
            h+=" default interface:";
            h+=default_if;
        }
        return h;
    }

    string err(){
        return pcap_geterr(handle);
    }

    bool configure(const string &amp; net_interface,const string &amp; exp){
        if(net_interface!="")
            net_if=net_interface;
        cap_exp=exp;

        if(0!=pcap_lookupnet(net_if.data(),&amp;netp,&amp;maskp,errbuf)){
            return false;
        }

        handle=pcap_create(net_if.data(),errbuf);
        if(NULL==handle){
            return false;
        }
        if(0!=pcap_activate(handle)){
            return false;
        }
        //ignore:?
        //pcap_set_snaplen
        //pcap_set_promisc
        //pcap_set_rfmon
        //pcap_set_timeout
        //pcap_set_buffer_size
        //pcap_set_tstamp_type

        //only cap ethernet packet
        if(DLT_EN10MB!=pcap_datalink(handle)){
            return false;
        }

        if (0!=pcap_compile(handle, &amp;filter_code, cap_exp.data(), 0, maskp)) {
            return false;
        }
        exp_compiled=true;

        if (0!=pcap_setfilter(handle, &amp;filter_code)) {
            return false;
        }
    }

    bool loop(int pkg_num=-1){
        typedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h,
                const u_char *bytes);
        pcap_loop(handle,pkg_num,&amp;(Sniffer::pcap_callback),(u_char*)this);
    }

    static void pcap_callback(u_char *user, const struct pcap_pkthdr *h,
        const u_char *bytes){
    Sniffer * p_this=(Sniffer*) user;
    p_this-&amp;gt;dispatch(h,bytes);
    }

private:

    void dispatch(const struct pcap_pkthdr *h, const u_char *bytes){
        got_packet(NULL,h,bytes);
    }

    private:
    pcap_t *handle;             // packet capture handle 
    string net_if; //e.g. "eth0"
    string cap_exp; //e.g "tcp and dst port 80"
    bool exp_compiled;
    struct bpf_program filter_code;         // compiled filter program (expression) 
    bpf_u_int32 netp;
    bpf_u_int32 maskp;
    char errbuf[PCAP_ERRBUF_SIZE];
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【旧代码】mysql备份的shell脚本]]></title>
    <link href="https://blog.helong.info//2011/11/15/%e3%80%90%e6%97%a7%e4%bb%a3%e7%a0%81%e3%80%91mysql%e5%a4%87%e4%bb%bd%e7%9a%84shell%e8%84%9a%e6%9c%ac/"/>
    <updated>2011-11-15T00:00:00+08:00</updated>
    <id>https://blog.helong.info//2011/11/15/%e3%80%90%e6%97%a7%e4%bb%a3%e7%a0%81%e3%80%91mysql%e5%a4%87%e4%bb%bd%e7%9a%84shell%e8%84%9a%e6%9c%ac</id>
    <content type="html"><![CDATA[<pre><code class="sh">#!/bin/sh
bk_to="/var/mysql-backup-`date +%Y-%m-%d-%k-%M-%S |tr -d ' '`"
user_name="root"
user_pw="dev"

sql="
flush tables with read lock;
system cp -pR /var/lib/mysql $bk_to; 
unlock tables;
"
mysql -u $user_name -p$user_pw -e "$sql"
echo $sql 
tar cjf $bk_to.bz2 $bk_to
rm -rf $bk_to
</code></pre>
]]></content>
  </entry>
  
</feed>
