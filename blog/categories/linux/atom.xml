<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/linux/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2020-03-03T07:35:29+00:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Abstract Unix Socket 实现进程单实例运行]]></title>
    <link href="https://blog.helong.info//blog/2020/03/03/abstract-unix-socket-single-instance/"/>
    <updated>2020-03-03T11:06:00+00:00</updated>
    <id>https://blog.helong.info//blog/2020/03/03/abstract-unix-socket-single-instance</id>
    <content type="html"><![CDATA[<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>很多时候，我们需要<strong>确保进程只有一个实例运行</strong>。</p>

<p>有几种方法：</p>

<p><a href="http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux">http://stackoverflow.com/questions/2964391/preventing-multiple-process-instances-on-linux</a></p>

<p><a href="http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c">http://stackoverflow.com/questions/5339200/how-to-create-a-single-instance-application-in-c-or-c</a></p>

<p><a href="https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src">https://github.com/qtproject/qt-solutions/tree/master/qtsingleapplication/src</a></p>

<p>比较常规的做法，是对一个文件加文件锁 flock，比如对 pid 文件 flock( LOCK_EX|LOCK_NB )</p>

<p>但是这种方法有些弊端：</p>

<ol>
<li>如果文件被 mv 或者 rm，是会被绕过的。</li>
<li>如果磁盘故障比如磁盘满，目录没有写权限，会失败。</li>
</ol>


<a name="L......abstract.namespace.unix.socket"></a>
<h2>二，abstract namespace unix socket</h2>

<p><a href="http://linux.die.net/man/7/unix">http://linux.die.net/man/7/unix</a></p>

<p>unix socket 有3种：</p>

<ol>
<li>基于文件的</li>
<li>socketpair 创建的，匿名的</li>
<li>abstract namespace 的，Linux特有</li>
</ol>


<p>Linux 下， AF_UNIX socket 支持一种特殊的
abstract namespace unix socket 。</p>

<p>相比 普通的基于文件系统的 unix socket，abstract namespace unix socket ：</p>

<ol>
<li>没有磁盘文件</li>
<li>进程挂了以后自动删除，无残留文件</li>
<li>无需担心与 文件系统上的文件冲突，不需要关心文件系统上的绝对路径是否存在的问题</li>
</ol>


<!--more-->


<p>在 lsof 的结果里面看起来，就是有一些 类似 @test_abstract_ns 这样的 文件项</p>

<p>代码中使用也很简单，  abstract namespace  unix socket 在 bind 之前，sockaddr_un.sun_path[0] 设成 0x0 即可。</p>

<a name="L............"></a>
<h2>三，代码</h2>

<p>于是我用 abstract unix socket 实现了一个 SysSem 工具类（ 一个 system 范围的 semaphore ），
用来：</p>

<ol>
<li>让一个程序只启动一个实例。</li>
<li>让 x 进程等待 y 进程执行完 yyy 操作后，才能执行 xxx 操作。</li>
</ol>


<p>特点：</p>

<ol>
<li>多进程/线程 并发安全。</li>
<li>当持有的进程被 kill ，OS自动释放，无残留。</li>
<li>没有磁盘文件，没有文件意外被删的各种情况。</li>
<li>不占用 tcp/udp 端口。</li>
<li>简单，不到 60行代码。</li>
</ol>


<pre><code class="cpp">
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;

#include &lt;algorithm&gt;
#include &lt;string&gt;

//
// a semaphore with system scope.
//
// 1. no race conditions between Post() / GetValue() , better than flock().
// 2. when a running process be killed, automatically release all.
// 3. no file on disk, no accidently delete .
// 4. no tcp/udp socket, no confliction, no port consumption.
//
class SysSem {
public:
    SysSem() : _fd(-1) { memset(&amp;_addr, 0, sizeof(_addr)); }
    ~SysSem();

    void Init(std::string id);

    bool Post();
    bool GetValue();

    const char* GetID() const;

private:
    struct sockaddr_un _addr;
    int _fd;
};

void SysSem::Init(std::string id) {
    _addr.sun_family = AF_UNIX;
    const size_t len = std::min(id.size(), sizeof(_addr.sun_path) - 2);  // 2 = start null and end null byte
    // abstract namespace socket address , _addr.sun_path[0] is a null byte ('\0')
    memcpy(_addr.sun_path + 1, id.c_str(), len);
    // memcpy(_addr.sun_path + 0, id.c_str(), len);
}

const char* SysSem::GetID() const { return &amp;_addr.sun_path[1]; }

SysSem::~SysSem() {
    if (_fd &gt;= 0) {
        ::close(_fd);
        _fd = -1;
    }
}

bool SysSem::Post() {
    _fd = ::socket(AF_UNIX, SOCK_STREAM, 0);
    if (_fd &lt; 0) {
        return false;
    }

    if ((0 != ::bind(_fd, (struct sockaddr*)&amp;_addr, sizeof(_addr))) || (0 != listen(_fd, 65536))) {
        return false;
    }
    return true;
}

bool SysSem::GetValue() {
    const int clientFD = ::socket(AF_UNIX, SOCK_STREAM, 0);
    if (clientFD &lt; 0) {
        return false;
    }
    const bool ret = (0 == ::connect(clientFD, (struct sockaddr*)&amp;_addr, sizeof(_addr)));
    ::close(clientFD);
    return ret;
}

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char** argv) {
    if (argc != 3) {
        fprintf(stderr, "usage: %s abstract-path post/get\n", argv[0]);
        exit(1);
    }

    SysSem inst;
    inst.Init(argv[1]);

    if (0 == strcasecmp(argv[2], "post")) {
        assert(inst.Post());
        SysSem check;
        check.Init(argv[1]);
        assert(check.GetValue());
        printf("ok, i am the only one under %s. running ...\n", inst.GetID());
        pause();

    } else if (0 == strcasecmp(argv[2], "get")) {
        assert(inst.GetValue());
        printf("a process is running under %s. \n", inst.GetID());
    } else {
        printf("unknown cmd \n");
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客迁移到octopress]]></title>
    <link href="https://blog.helong.info//blog/2014/03/24/move-to-octopress/"/>
    <updated>2014-03-24T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2014/03/24/move-to-octopress</id>
    <content type="html"><![CDATA[<p>wordpress的编辑器混淆了 结构 和 表现
而markdown，类似latex，结构和表现分离，更符合我的偏好。</p>

<p>在vim里面写博客，更能激起人的写作欲望，浏览器里面，容易转移注意力。</p>

<p>octopress的博客还可以用git做版本管理，备份。</p>

<p>octopress内置了代码格式化，着色。</p>

<p>这些都比wordpress更适合做技术博客。</p>

<p>从wordpress导出数据使用了  <a href="https://github.com/benbalter/wordpress-to-jekyll-exporter">https://github.com/benbalter/wordpress-to-jekyll-exporter</a></p>

<p>评论使用了 <a href="https://disqus.com">https://disqus.com</a> ，只需要申请一个账号，然后填到_config.yml里面，就行了</p>

<p>google analytics也是，只需要申请，然后把ID填入_config.yml就ok了。</p>

<p>octopress并不适合放在 xxx.com/blog/ 这样的目录下面，一些js脚本不支持目录，
最好放在独立域名下面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个使用KuaiPan备份linux服务器的脚本]]></title>
    <link href="https://blog.helong.info//blog/2014/02/08/%25e4%25b8%2580%25e4%25b8%25aa%25e4%25bd%25bf%25e7%2594%25a8kuaipan%25e5%25a4%2587%25e4%25bb%25bdlinux%25e6%259c%258d%25e5%258a%25a1%25e5%2599%25a8%25e7%259a%2584%25e8%2584%259a%25e6%259c%25ac/"/>
    <updated>2014-02-08T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2014/02/08/%e4%b8%80%e4%b8%aa%e4%bd%bf%e7%94%a8kuaipan%e5%a4%87%e4%bb%bdlinux%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e8%84%9a%e6%9c%ac</id>
    <content type="html"><![CDATA[<p>近日需要给服务器做备份，在网上找到了一个现成的金山快盘的api：<a href="https://github.com/deren/python-kuaipan" target="_blank"><a href="https://github.com/deren/python-kuaipan">https://github.com/deren/python-kuaipan</a></a> （感谢！）<br/>
试了一下，遂决定备份到金山快盘上。</p>

<p>备份脚本考虑了以下几个方面的要求：<br/>
1.上传之前一定要加密，对比之后，使用了openssl的aes-256-cbc加密算法<br/>
2.增量备份，最开始尝试用<a href="http://duplicity.nongnu.org" target="_blank">duplicity</a> ,写了一个duplicity的backend，然后发现，好复杂！猛然发现，linux上的tar就有<a href="http://www.gnu.org/software/tar/manual/html_node/Incremental-Dumps.html#Incremental-Dumps" target="_blank">增量备份功能</a>，于是直接用了tar<br/>
3.分卷，KuaiPan有文件大小限制，此处用了split把tar文件分卷</p>

<p>代码放在 <a href="https://github.com/windydays/kuaipan_backup" target="_blank"><a href="https://github.com/windydays/kuaipan_backup">https://github.com/windydays/kuaipan_backup</a></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Http Proxy Script]]></title>
    <link href="https://blog.helong.info//blog/2013/11/18/a-http-proxy-script/"/>
    <updated>2013-11-18T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2013/11/18/a-http-proxy-script</id>
    <content type="html"><![CDATA[<pre><code class="python">#!/usr/local/bin/python
# -*- coding: utf-8 -*-

import base64
import select
import socket
import httplib
import os
import sys
#base64.encodestring("das\120xsdada\s")

def usage ():
    print "connect_to_http_proxy %s"
    print "usage: connect_to_http_proxy &amp;lt;desthost&amp;gt; &amp;lt;destport&amp;gt;"

if len(sys.argv) != 3:
    usage()
    print sys.argv
    sys.exit()

proxy_host="web-proxy-domain.com"
proxy_port="8080"
dest_host=""
dest_port=""
dest_host, dest_port=sys.argv[1:]

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((proxy_host,int(proxy_port)))
sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
req="CONNECT "+dest_host+":"+dest_port + " HTTP/1.0\r\n\r\n"
sock.send(req)
resp=sock.recv(100000)
if resp.find("200") &amp;lt; 0:
    print req,resp
    exit(-1)

ep=select.epoll()
ep.register(sock.fileno(),select.EPOLLIN)
ep.register(sys.stdin.fileno(),select.EPOLLIN)
while True:
    events=ep.poll(1,2)
    for fd,event in events:
        if event &amp; select.EPOLLERR:
            sys.exit(0)
        if event &amp; select.EPOLLIN and fd==sock.fileno():
            os.write(sys.stdout.fileno(),sock.recv(1024*100)) 
        if event &amp; select.EPOLLIN and fd==sys.stdin.fileno():
            os.write(sock.fileno(),sys.stdin.read()) 

#conn=httplib.HTTPConnection(proxy_host+":"+proxy_port)
#conn.request("CONNECT",dest_host+":"+dest_port)
#res=conn.getresponse()
#print res.read()
#if res.status != 200:
#    print res.status,res.reason
#    sys.exit()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Libpcap试玩]]></title>
    <link href="https://blog.helong.info//blog/2013/08/04/libpcap%25e8%25af%2595%25e7%258e%25a9/"/>
    <updated>2013-08-04T00:00:00+00:00</updated>
    <id>https://blog.helong.info//blog/2013/08/04/libpcap%e8%af%95%e7%8e%a9</id>
    <content type="html"><![CDATA[<p>libpcap驱动了tcpdump,和wireshark这类抓包工具.提供了高度灵活的包过滤语言. 据wikipedia,高性能的包过滤最早是在bsd上作为一个问题被解决,被称为bpf,在内核实现了一个解释器,进行包匹配,用户态提供一个字符设备, linux作为后来者,支持与bsd基本相同的packet filter,称为lpf,不同的是,linux是通过在一个raw socket来支持包过滤的,通过setsockopt来SO_ATTACH_FILTER,挂载过滤器. strace 可知,libpcap实际上进行了如下syscall:</p>

<pre>socket(PF_PACKET, SOCK_RAW, 768) = 59 
setsockopt(59, SOL_SOCKET, SO_ATTACH_FILTER, "\1\0\0\0\0\0\0\0\250\327Vc\375\177\0\0", 16) = 0</pre>


<p>libpcap的api文档和demo代码可以参见</p>

<ol>
<li><a href="http://www.tcpdump.org/pcap3_man.html" target="_blank"><a href="http://www.tcpdump.org/pcap3_man.html">http://www.tcpdump.org/pcap3_man.html</a></a></li>
<li><a href="http://www.tcpdump.org/sniffex.c" target="_blank"><a href="http://www.tcpdump.org/sniffex.c">http://www.tcpdump.org/sniffex.c</a></a></li>
</ol>


<p>参考文档了demo,我写了一个小的sniffer,</p>

<!--more-->


<p>如下:</p>

<pre><code class="cpp">class Sniffer{
public:
    Sniffer():handle(NULL),cap_exp(""),net_if("any"),exp_compiled(false){}
    ~Sniffer(){
        if(handle){
            pcap_freecode(&amp;filter_code);
        }
        if(exp_compiled){
            pcap_close(handle);
        }
    }
    string help(){
        string h("avaliable net_interface:");
        pcap_if_t* alldev=NULL;
        if(0==pcap_findalldevs(&amp;alldev, errbuf)){
            for(pcap_if_t * dev =alldev;NULL!=dev;dev=dev-&amp;gt;next){
                h+=dev-&amp;gt;name;
                h+=" ";
            }
            pcap_freealldevs(alldev);
        }
        char * default_if=pcap_lookupdev(errbuf);
        if(default_if){
            h+=" default interface:";
            h+=default_if;
        }
        return h;
    }

    string err(){
        return pcap_geterr(handle);
    }

    bool configure(const string &amp; net_interface,const string &amp; exp){
        if(net_interface!="")
            net_if=net_interface;
        cap_exp=exp;

        if(0!=pcap_lookupnet(net_if.data(),&amp;netp,&amp;maskp,errbuf)){
            return false;
        }

        handle=pcap_create(net_if.data(),errbuf);
        if(NULL==handle){
            return false;
        }
        if(0!=pcap_activate(handle)){
            return false;
        }
        //ignore:?
        //pcap_set_snaplen
        //pcap_set_promisc
        //pcap_set_rfmon
        //pcap_set_timeout
        //pcap_set_buffer_size
        //pcap_set_tstamp_type

        //only cap ethernet packet
        if(DLT_EN10MB!=pcap_datalink(handle)){
            return false;
        }

        if (0!=pcap_compile(handle, &amp;filter_code, cap_exp.data(), 0, maskp)) {
            return false;
        }
        exp_compiled=true;

        if (0!=pcap_setfilter(handle, &amp;filter_code)) {
            return false;
        }
    }

    bool loop(int pkg_num=-1){
        typedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h,
                const u_char *bytes);
        pcap_loop(handle,pkg_num,&amp;(Sniffer::pcap_callback),(u_char*)this);
    }

    static void pcap_callback(u_char *user, const struct pcap_pkthdr *h,
        const u_char *bytes){
    Sniffer * p_this=(Sniffer*) user;
    p_this-&amp;gt;dispatch(h,bytes);
    }

private:

    void dispatch(const struct pcap_pkthdr *h, const u_char *bytes){
        got_packet(NULL,h,bytes);
    }

    private:
    pcap_t *handle;             // packet capture handle 
    string net_if; //e.g. "eth0"
    string cap_exp; //e.g "tcp and dst port 80"
    bool exp_compiled;
    struct bpf_program filter_code;         // compiled filter program (expression) 
    bpf_u_int32 netp;
    bpf_u_int32 maskp;
    char errbuf[PCAP_ERRBUF_SIZE];
};
</code></pre>
]]></content>
  </entry>
  
</feed>
