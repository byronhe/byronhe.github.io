<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Crypto | Tech Ideas]]></title>
  <link href="https://blog.helong.info//blog/categories/crypto/atom.xml" rel="self"/>
  <link href="https://blog.helong.info//"/>
  <updated>2019-09-22T18:24:16+08:00</updated>
  <id>https://blog.helong.info//</id>
  <author>
    <name><![CDATA[byronhe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TLS协议分析 与 现代加密通信协议设计]]></title>
    <link href="https://blog.helong.info//blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/"/>
    <updated>2015-09-06T22:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design</id>
    <content type="html"><![CDATA[<!--
---


#  TLS协议分析 与 现代加密通信协议设计

标签（空格分隔）：密码学 tls

作者：byronhe

---


-->


<p>最近发现密码学很有意思，刚好还和工作有点关系，就研究了一下，本文是其中一部分笔记和一些思考。</p>

<p><strong>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</strong></p>

<p><strong>本文禁止转载</strong></p>

<p>本文目标：</p>

<ol>
<li>学习鉴赏TLS协议的设计，透彻理解原理和重点细节</li>
<li>跟进一下密码学应用领域的历史和进展</li>
<li>整理现代加密通信协议设计的一般思路</li>
</ol>


<p>本文有门槛，读者需要对现代密码学有清晰而系统的理解，建议花精力补足背景知识再读。本文最后的参考文献里有一些很不错的学习资料。</p>

<p><strong>目录 :</strong></p>

<pre><code>
TLS协议分析 与 现代加密通信协议设计
一 . TLS协议的设计目标：
1. 密码学的方法论
2. TLS的设计目标
3. TLS的历史
二. TLS协议的原理
1. 自顶向下，分层抽象
3. TLS CipherSuite
4. 协议分层
5. record 协议
1. SecurityParameters
2. record层分段
3. record层的密码学保护
4. record层的密码学保护--MAC
5. record层的密码学保护--stream cipher
6. record层的密码学保护-- CBC block cipher
7. record层的密码学保护-- AEAD cipher
8. record层的密码学保护-- Key扩展
5. handshake 协议
1.handshake的总体流程
3. handshake 协议外层结构
4. handshake -- ClientHello，ServerHello，HelloRequest
4.1 Client Hello
4.2 Server Hello
4.3 Hello Extensions
4.4 Hello Request
5. handshake -- Server Certificate
6. handshake -- Server Key Exchange
7. handshake -- Certificate Request
8. handshake -- Server Hello Done
9. handshake -- Client Certificate
10. handshake -- Client Key Exchange
(1). RSA 加密的 Premaster Secret 消息
(2). 客户端 Diffie-Hellman 公钥
(3). 客户端 EC Diffie-Hellman 公钥
11. handshake -- Cerificate Verify
12. handshake -- Finished
13. handshake -- NewSessionTicket
6. ChangeCipherSpec 协议
7. Alert 协议
8. application data协议
8. TLS协议的安全分析
1. 认证和密钥交换 的安全性
1. 匿名密钥交换
2. RSA 密钥交换和认证
3. Diffie-Hellman 密钥交换和认证
2. 版本回退攻击
3. 针对握手过程的攻击
4. 针对 Resuming Sessions 的攻击
5. 针对应用数据保护的攻击
6. 显式 IV的安全性
7. 加密和MAC组合模式的安全性
8. DOS 攻击下的安全性
9.Session Ticket 的安全分析
1. 无效的Session
2. 窃取 Tickets
3. 伪造 Tickets
4. DoS 攻击
5. 加密 Ticket 的key 的管理
6. Ticket 的有效期
7. 其他的 Ticket 格式和分发方法
8. Identity Privacy, Anonymity, and Unlinkability
9. TLS扩展:
10. TLS的配套：PKI体系
1. X.509 证书
2.现有PKI体系暴露出的问题
1. public key pin
2. HSTS
11. TLS协议历史上出现过的漏洞，密码学常见陷阱
1. TLS的漏洞
2. 密码学常见陷阱
13. 下一代TLS: TLS 1.3
1. record层的密码学保护的改动
2.handshake协议的改动
3.1-RTT 握手
4. 有副作用的 0-RTT握手
5. Resumption 和 PSK
6. Key Schedule 过程的改动
三. TLS协议的代码实现
四. TLS协议的部署与优化
五. 更多的加密通信协议case：QUIC，iMessage，TextSecure, otr, ios HomeKit，libsodium
1. QUIC
2. apple ios iMessage
3. apple ios HomeKit
4. TextSecure
5. otr 协议
6. libsodium/NaCL
7. Tox.im
8. CurveCP
9. tcpcrypt
10.noise
11.tcpcrypt
12. netflix MSL
12.Amazon KMS 密钥管理服务 白皮书
六. TLS协议给我们的启发 -- 现代加密通信协议设计
七. 附录：密码学基础概念
1. 块加密算法 block cipher
2. 流加密算法 stream cipher
3. Hash函数 hash funtion
4. 消息验证码函数 message authentication code
5. 密钥交换 key exchange
6. 公钥加密 public-key encryption
7. 数字签名算法 signature algorithm
8. 密码衍生函数 key derivation function
9. 随机数生成器 random number generators
八. 参考文献：
TLS/SSL 相关RFC及标准
协议分析文章
实际部署调优相关
密码学相关
相关开源项目
</code></pre>

<p>[TOC]
!TOC
{:toc}</p>

<!--more-->


<a name="L......TLS........................"></a>
<h1>一 . TLS协议的设计目标：</h1>

<a name="L1......................."></a>
<h2>1. 密码学的方法论</h2>

<p>密码学和软件开发不同，软件开发是工程，是手艺，造轮子是写代码的一大乐趣。软件开发中常常有各种权衡，一般难有明确的对错，一般还用建筑来比拟软件的结构，设计的优雅被高度重视。</p>

<p>密码学就不一样了。<a href="http://www.daemonology.net/blog/2013-06-17-crypto-science-not-engineering.html">密码学是科学，不是工程</a>，有严格的技术规范，严禁没有经过学术训练者随意创造。要求严谨的理论建模，严密的数学证明。很少有需要权衡的地方，正确就是正确，错误就是错误。又由于密码学过去在军事上的重要价值，各国政府一直投入大量人力物力财力，不断深入强化己方的算法，破解对手的算法，所以密码学就是一种残酷的军备竞赛。</p>

<ul>
<li><p>密码学有很多的陷阱（下文会介绍几个），设计使用密码学的协议或者软件，是极其容易出错，高风险的专业活动，单纯的码农背景是做不了的。本着<strong>不作死就不会死</strong>的伟大理念，首先推荐读者尽可能使用 TLS 这种标准化，开源，广泛使用，久经考验，高性能的协议。本文也只是整理一点粗浅的科普常识，读完这篇文章，并不能使读者具有设计足够安全的密码学协议的能力。</p></li>
<li><p>密码学经过几十年的军备竞赛式发展，已经发展出大量巧妙而狡猾的攻击方法，我们使用的算法，都是在所有已知的攻击方法下都无法攻破的，由于我们大多数码农并没有精力去了解最前沿的攻击方法，所以我们其实并没有能力去评价一个加密算法，更没有能力自己发明算法。所以最好跟着业界的主流技术走，肯定不会有大错。</p></li>
<li><p>现代密码学近20年进展迅猛，现在搞现代密码学研究的主要都是数学家，在这个领域里面以一个码农的知识背景，已经很难理解最前沿的东西，连正确使用加密算法都是要谨慎谨慎再谨慎的。一个码农，能了解密码学基本概念，跟进密码学的最新应用趋势，并正确配置部署TLS这种协议，就很不错了。</p></li>
<li><p>密码学算法很难被正确地使用，各种细节非常容易出错。
例如：</p>

<ul>
<li>1.大多数码农都听说过aes，可是大多数都不了解细节，比如：aes应该用哪种模式？应该用哪种padding？IV/nonce应该取多少bit？IV/nonce应该怎么生成？ key size应该选多大？key应该怎么生成？应不应该加MAC？MAC算法的选择？MAC和加密应该怎么组合？</li>
<li>2.大多数知道RSA的码农分不清 RSASSA-PKCS1-v1_5 ，RSAES-OAEP 和 RSASSA-PSS</li>
<li>3.更多错误参见 <a href="http://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology">这个stackoverflow问答，强烈推荐仔细阅读</a></li>
</ul>
</li>
<li><p>密码学算法很难被正确地实现(代码实现过程中会引入很多漏洞，比如HeartBleed，比如各种随机数生成器的bug，时间侧通道攻击漏洞)</p></li>
<li><p>不能一知半解，绝对不能在一知半解的情况下就动手设计密码学协议。犹如“盲人骑瞎马，夜班临深池”。</p></li>
<li><p>不能闭门造车，密码学相关协议和代码一定要开源，采用大集市式的开发，接受peer review，被越多的人review，出漏洞的可能越小（所以应该尽可能使用开源组件）</p></li>
</ul>


<a name="L2..TLS..............."></a>
<h2>2. TLS的设计目标</h2>

<p>TLS的设计目标是构建一个安全传输层（Transport Layer Security ），在基于连接的传输层（如tcp）之上提供：</p>

<ol>
<li>密码学安全
 (1). 保密， message privacy (保密通过加密encryption实现，所有信息都加密传输，第三方无法窃听 )
 (2). 完整性， message integrity（  通过MAC校验机制，一旦被篡改，通信双方会立刻发现 ）
 (3). 认证， mutual authentication （双方认证,双方都可以配备证书，防止身份被冒充 ）</li>
<li>互操作，通用性 （ 根据公开的rfc，任何符合rfc的软件实现都可以互操作，不受限于任何专利技术）</li>
<li>可扩展性 ( 通过扩展机制 tls_ext可以添加功能，有大量的新功能，都是通过扩展添加的)</li>
<li>高效率 （通过session cache，恰当部署cache之后，tls的效率很高）</li>
</ol>


<p>请认准这几个目标，在后文中，会逐一实现。</p>

<a name="L3..TLS........."></a>
<h2>3. TLS的历史</h2>

<ul>
<li>1995: SSL 2.0, 由Netscape提出，这个版本由于设计缺陷，并不安全，很快被发现有严重漏洞，已经废弃。</li>
<li>1996: SSL 3.0. 写成RFC，开始流行。目前(2015年)已经不安全，必须禁用。</li>
<li>1999: TLS 1.0. 互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版.</li>
<li>2006: TLS 1.1. 作为 RFC 4346 发布。主要fix了CBC模式相关的如BEAST攻击等漏洞</li>
<li>2008: TLS 1.2. 作为RFC 5246 发布 。增进安全性。目前(2015年)应该主要部署的版本，请确保你使用的是这个版本</li>
<li>2015之后: TLS 1.3，还在制订中，支持0-rtt，大幅增进安全性，砍掉了aead之外的加密方式</li>
</ul>


<p>由于SSL的2个版本都已经退出历史舞台了，所以本文后面只用TLS这个名字。
读者应该明白，一般所说的SSL就是TLS。</p>

<a name="L.....TLS..............."></a>
<h1>二. TLS协议的原理</h1>

<a name="L1............................."></a>
<h2>1. 自顶向下，分层抽象</h2>

<p>构建软件的常用方式是分层，把问题域抽象为多层，每一层的概念定义为一组原语，上一层利用下一层的组件构造实现，并被上一层使用，层层叠叠即成软件。
*  例如在编程语言领域中，汇编语言为一层，在汇编上面是C/C++等静态编译语言，C/C++之上是python/php/lua等动态类型脚本语言层，之上常常还会构造领域特定的DSL
*  在网络架构中，以太网是一层，其上是ip协议的网络层，ip之上是tcp等传输层，tcp之上是http等应用层</p>

<p>密码学通信协议也是分层构造得到。大致可以这么分层：</p>

<ol>
<li><p>最底层是基础算法原语的实现，例如: aes ,  rsa， md5, sha256，ecdsa,  ecdh 等（举的例子都是目前的主流选择，下同）</p></li>
<li><p>其上是选定参数后，符合密码学里标准分类的算法，包括块加密算法，签名算法，非对称加密算法，MAC算法等，例如： aes-128-cbc-pkcs7，rsaes-oaep ，rsassa-pkcs1-v1_5, hmac-sha256，ecdsa-p256，curve25519 等</p></li>
<li><p>再其上，是把多种标准算法组合而成的半成品组件，例如：对称传输组件例如 aes-128-cbc + hmac-sha256，aes-128-gcm，认证密钥协商算法: rsassa-OAEP + ecdh-secp256r1，数字信封：rsaes-oaep + aes-cbc-128 + hmac-sha256 ，文件密码加密存储组件：pbkdf2+aes-128-cbc-hmac-sha256，密钥扩展算法 PRF-sha256 等</p></li>
<li><p>再其上，是用各种组件拼装而成的各种成品密码学协议/软件，例如：tls协议，ssh协议，srp协议，gnupg文件格式，iMessage协议，bitcoin协议等等</p></li>
</ol>


<p>第1层，一般程序员都有所了解，例如rsa，简直路人皆知; md5 被广泛使用(当然，也有广泛的误用)
第2层，各种莫名其妙的参数，一般很让程序员摸不着头脑，需要深入学习才能理清。
第3层，很多程序员自己造的轮子，往往说白了就是想重复实现第3层的某个组件而已。
第4层，正确地理解，使用，部署这类成熟的开放协议，并不是那么容易。很多的误用来源于不理解，需要密码学背景知识，才能搞懂是什么，为什么，怎么用。</p>

<p>最难的是<strong>理论联系实际</strong>。面对一个一团乱麻的实际业务问题，最难的是从中抽象分析出其本质密码学问题，然后用密码学概念体系给业务建模。在分析建模过程中，要求必须有严密的，体系化的思考方式。不体系化的思考方式会导致疏漏，或者误用。</p>

<p>第2层中，密码学算法，常见的有下面几类：</p>

<ol>
<li>块加密算法 block cipher: AES, Serpent, 等</li>
<li>流加密算法 stream cipher: RC4，ChaCha20 等</li>
<li>Hash函数 hash funtion:MD5，sha1，sha256，sha512 , ripemd 160，poly1305 等</li>
<li>消息验证码函数 message authentication code: HMAC-sha256，AEAD 等</li>
<li>密钥交换 key exchange: DH，ECDH，RSA，PFS方式的（DHE，ECDHE）等</li>
<li>公钥加密 public-key encryption: RSA，rabin-williams 等</li>
<li>数字签名算法 signature algorithm:RSA，DSA，ECDSA (secp256r1 , ed25519) 等</li>
<li>密码衍生函数 key derivation function: TLS-12-PRF(SHA-256) , bcrypto，scrypto，pbkdf2 等</li>
<li>随机数生成器 random number generators:  /dev/urandom 等</li>
</ol>


<p>每个类别里面的都有几个算法不断竞争，优胜劣汰，近几十年不断有老的算法被攻破被淘汰，新的算法被提出被推广。这一块话题广，水很深，内容多，陷阱也多，后续byron会翻译整理一系列文章，分享一下每一类里面个人收集的资料。
在此推荐一下 <a href="https://www.crypto101.io/"> 开源电子书crypto101</a>，讲的很透彻，而且很易读)</p>

<p><strong>设计一个加密通信协议的过程，就是自顶向下，逐步细化，挑选各类组件，拼装成完整协议的过程</strong></p>

<a name="L3..TLS.CipherSuite"></a>
<h2>3. TLS CipherSuite</h2>

<p>从上述分层的角度看，TLS大致是由3个组件拼成的：
-  <strong>1.对称加密传输组件</strong>，例如aes-128-gcm(这几个例子都是当前2015年最主流的选择);
-  <strong>2.认证密钥协商组件</strong>，例如rsa-ecdhe;
-  <strong>3.密钥扩展组件</strong>，例如TLS-PRF-sha256</p>

<p>这些组件可以再拆分为5类算法，在TLS中，这5类算法组合在一起，称为一个CipherSuite：
authentication (认证算法)
encryption (加密算法 )
message authentication code (消息认证码算法  简称MAC)
key exchange (密钥交换算法)
key derivation function （密钥衍生算法)</p>

<p> TLS协议设计之初就考虑到了这每一类算法的演变，所以没有定死算法，而是设计了一个算法协商过程，来允许加入新的算法( 简直是软件可扩展性设计的典范！)，协商出的一个算法组合即一个CipherSuite
TLS CipherSuite  在 iana 集中注册，每一个CipherSuite分配有 一个2字节的数字用来标识 ，可以在 <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">iana的注册页面</a>  查看</p>

<p>iana注册页面截图：
<img src="/images/blog/tls/CipherSuiteList.png" alt="" /></p>

<p>在浏览器中，就可以查看当前使用了什么 CipherSuite，在地址栏上，点击一个小锁的标志，就可以看到了。
<img src="/images/blog/tls/addrbar_lock.png" alt="" /></p>

<p>服务器端支持的CipherSuite列表，如果是用的openssl，可以用  openssl  ciphers -V  | column -t 命令查看，输出如：
<img src="/images/blog/tls/openssl_ciphers_output.png" alt="" /></p>

<p>例如其中这一行(这个是目前的主流配置):</p>

<pre><code class="c">    0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(128)    Mac=AEAD
</code></pre>

<p>表示：
名字为<code>ECDHE-RSA-AES128-GCM-SHA256</code>  的CipherSuite ，用于 TLSv1.2版本，使用 ECDHE 做密钥交换，使用RSA做认证，使用AES-128-gcm做加密算法，MAC由于gcm作为一种aead模式并不需要，所以显示为aead，使用SHA256做PRF算法。</p>

<p>可以参考 <a href="http://linux.die.net/man/1/ciphers">man 1 ciphers</a></p>

<p>要注意的是，由于历史兼容原因，tls标准，和openssl的tls实现中，有一些极度不安全的CipherSuite，一定要禁用，比如：</p>

<dl>
<dt>EXP , EXPORT</dt>
<dd> 一定要禁用。EXPORT表示上世纪美国出口限制弱化过的算法，早已经被攻破，TLS的FREAK 攻击就是利用了这类坑爹的算法。</dd>
<dt>eNULL, NULL</dt>
<dd> 一定要禁用。NULL表示不加密！默认是禁用的。
aNULL
： 一定要禁用。表示不做认证(authentication) ，也就是说可以随意做中间人攻击。</dd>
<dt>ADH</dt>
<dd> 一定要禁用。表示不做认证的 DH 密钥协商。</dd>
</dl>

<p>上面是举个例子，读者不要自己去研究怎么配置，这太容易搞错。
请按照mozilla官方给出的这个<a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations">权威文档</a>，复制粘贴就好了。</p>

<p>CipherSuite的更多解释，配置方法等，可以参考byron之前写的一篇文章 <a href="https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/">SSL/TLS CipherSuite 介绍</a></p>

<a name="L4.............."></a>
<h2>4. 协议分层</h2>

<p>TLS是用来做加密数据传输的，因此它的主体当然是一个对称加密传输组件。为了给这个组件生成双方共享的密钥，因此就需要先搞一个认证密钥协商组件，故，TLS协议自然分为：</p>

<ol>
<li>做对称加密传输的record协议 ，the record protocol</li>
<li>做认证密钥协商的handshake协议，the handshake protocol</li>
</ol>


<p>还有3个很简单的辅助协议：</p>

<ol>
<li>changecipher spec 协议，the changecipher spec protocol, 用来通知对端从handshake切换到record协议(有点冗余，在TLS1.3里面已经被删掉了)</li>
<li>alert协议，the alert protocol, 用来通知各种返回码，</li>
<li>application data协议， The application data protocol，就是把http，smtp等的数据流传入record层做处理并传输。</li>
</ol>


<p>这种 <strong>认证密钥协商 + 对称加密传输</strong> 的结构，是<strong>绝大多数加密通信协议的通用结构</strong>，在后文的更多协议案例中，我们可以看到该结构一再出现。</p>

<p>这5个协议中：
record协议在tcp流上提供分包，
图片来自网络：
<img src="/images/blog/tls/tls_5_proto.png" alt="" /></p>

<p>其它的: handshake protocol, alert protocol, changeCipherSpec protocol, application data protocol都封装在record protocol的包里，然后在tcp上传输（此处以tcp举例，也有可能是udp，或者随便什么ipc机制等）</p>

<p>下文分别介绍，内容主要是翻译自 RFC5246，RFC5077，RFC4492</p>

<a name="L5..record......."></a>
<h2>5. record 协议</h2>

<p>record协议做应用数据的对称加密传输，占据一个TLS连接的绝大多数流量，因此，先看看record协议
图片来自网络:
<img src="/images/blog/tls/tls_record_layer.png" alt="" /></p>

<p> Record 协议 &ndash; 从应用层接受数据，并且做:</p>

<ol>
<li>分片，逆向是重组</li>
<li>生成序列号，为每个数据块生成唯一编号，防止被重放或被重排序</li>
<li>压缩，可选步骤，使用握手协议协商出的压缩算法做压缩</li>
<li>加密，使用握手协议协商出来的key做加密/解密</li>
<li>算HMAC，对数据计算HMAC，并且验证收到的数据包的HMAC正确性</li>
<li>发给tcp/ip，把数据发送给 TCP/IP 做传输(或其它ipc机制)。</li>
</ol>


<a name="L1..SecurityParameters"></a>
<h3>1. SecurityParameters</h3>

<p>record层的上述处理，完全依据下面这个SecurityParameters里面的参数进行：</p>

<pre><code class="c">      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;
</code></pre>

<p>record 层使用上面的SecurityParameters生成下面的6个参数（不是所有的CipherSuite都需要全部6个，如果不需要，那就是空）:</p>

<pre><code class="c">      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV
</code></pre>

<p>当handshake完成，上述6个参数生成完成之后，就可以建立连接状态，连接状态除了上面的SecurityParameters，还有下面几个参数，并且随着数据的发送/接收，更新下面的参数：</p>

<dl>
<dt>*   compression state</dt>
<dd><pre><code> 当前压缩算法的状态。
</code></pre></dd>
<dt>*   cipher state</dt>
<dd><pre><code>加密算法的当前状态，对块加密算法比如aes，包含密码预处理生成的轮密钥(感谢温博士指出) "round key"，还有IV等；对于流加密，包含能让流加密持续进行加解密的状态信息
</code></pre></dd>
<dt>*  sequence number</dt>
<dd>   每个连接状态都包含一个sequence number，并且读和写状态有不同的sequence number。当连接开始传输数据时，sequence number必须置为0.  sequence number 是uint64类型的，并且不得超过 $ 2^{64}-1$ 。s.  Sequence number不得回绕。如果一个TLS实现无法避开回绕一个sequence number，必须进行重协商。sequence number在每个record被发送时都增加1。并且传输的第1个Record必须使用0作为sequence number。</dd>
</dl>

<p>此处有几个问题值得思考：</p>

<p>(1).  为什么MAC key , encryption key, IV 要分别不同？</p>

<p>在密码学中，对称加密算法一般需要encryption key，IV两个参数，MAC算法需要MAC key参数，因此这3个key用于不同的用途。
当然，不是所有的算法都一定会用到这3个参数，例如新的aead型算法，就不需要MAC key。</p>

<p>(2). 为什么client和server要使用不同的key
如果TLS的双方使用相同的key，那么当使用stream cipher加密应用数据的时候，stream cipher的字节流在两个方向是一样的，如果攻击者知道TLS数据流一个方向的部分明文（比如协议里面的固定值），那么对2个方向的密文做一下xor，就能得到另一个方向对应部分的明文了。</p>

<p>还有，当使用 aead 比如 aes-gcm 做加密的时候，aead标准严格要求，<strong>绝对不能用相同的 key+nonce 加密不同的明文</strong>，故如果TLS双方使用相同的key，又从相同的数字开始给nonce递增，那就不符合规定，会直接导致 aes-gcm 被攻破。</p>

<p>参考:
<a href="http://crypto.stackexchange.com/questions/2878/separate-read-and-write-keys-in-tls-key-material">http://crypto.stackexchange.com/questions/2878/separate-read-and-write-keys-in-tls-key-material</a></p>

<a name="L2..record........."></a>
<h3>2. record层分段</h3>

<p>如上图所示，对要发送的数据流，首先分段，分段成如下格式：</p>

<pre><code class="c">      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
</code></pre>

<dl>
<dt>*  version字段</dt>
<dd> ，定义当前协商出来的TLS协议版本，例如 TLS  1.2   version 是 { 3, 3 }</dd>
<dt>*  length字段</dt>
<dd> 即长度，tls协议规定length必须小于 $2^{14}$，一般我们不希望length过长，因为解密方需要收完整个record，才能解密，length过长会导致解密方需要等待更多的rtt，增大latency，破坏用户体验，参考 <a href="http://book.douban.com/subject/25856314/">Web性能权威指南</a> TLS那一章。</dd>
<dt>*  type字段</dt>
<dd><p> ，用来标识当前record是4种协议中的哪一种，</p>

<p>record压缩</p></dd>
<dd> TLS协议定义了可选的压缩，但是，由于压缩导致了 2012 年被爆出<a href="https://en.wikipedia.org/wiki/CRIME">CRIME攻击，BREACH攻击</a>，所以在实际部署中，<strong>一定要禁用压缩</strong>。
<a href="http://www.unclekevin.org/?p=640">http://www.unclekevin.org/?p=640</a>
<a href="http://www.freebuf.com/articles/web/5636.html">http://www.freebuf.com/articles/web/5636.html</a></dd>
</dl>

<a name="L3..record....................."></a>
<h3>3. record层的密码学保护</h3>

<p>record层的密码学保护:</p>

<p>经过处理后的包格式定义如下：</p>

<pre><code class="c">      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;
</code></pre>

<p>TLS协议设计目标中的 1.保密(encryption) 2.完整性(authentication) ，和防重放就在这里实现。
实现方式有3类：</p>

<ol>
<li>Block Cipher (CBC mode of operation) + HMAC：例如 aes-128-cbc+hmac-sha256</li>
<li>Stream Cipher (RC4) + HMAC</li>
<li>Authenticated-Encryption using block cipher (GCM/CCM 模式)：例如 aes-128-gcm</li>
</ol>


<p>1.Block Cipher+HMAC 和 2.Stream Cipher + HMAC 的各类算法目前（2015年）都已经爆出各种漏洞(后文解释)，目前最可靠的是 3.Authenticated-Encryption 类的算法，主要就是aes-gcm，下一代的TLS v1.3干脆只保留了3.Authenticated-Encryption，把1和2直接禁止了(所以。。。你真的还要继续用aes-cbc吗？)。</p>

<p>GCM模式是AEAD的，所以不需要MAC算法。
GCM模式是AEAD的一种，AEAD 的 作用类似于  Encrypt-then-HMAC ，例如 Sha256 + Salt + AES + IV</p>

<p>此处需要介绍一个<strong>陷阱</strong>。
在密码学历史上，出现过3种加密和认证的组合方式：</p>

<ol>
<li>Encrypt-and-MAC</li>
<li>MAC-then-Encrypt</li>
<li>Encrypt-then-MAC</li>
</ol>


<p>在TLS协议初定的那个年代，人们还没意识到这3种组合方式的安全性有什么差别，所以TLS协议规定使用 2.MAC-then-Encrypt，即先计算MAC，然后把 &ldquo;明文+MAC&rdquo; 再加密(块加密或者流加密)的方式，做流加密+MAC，和块加密+MAC。
但是，悲剧的是，近些年，人们发现 MAC-then-Encrypt 这种结构导致了 很容易构造padding oracle 相关的攻击，例如这在TLS中，间接形成被攻击者利用，这间接导致了 BEAST 攻击 , Lucky 13攻击 (CVE-2013-0169), 和 POODLE 攻击 (CVE-2014-3566).</p>

<p>目前因此，学术界已经一致同意： <strong>Encrypt-then-MAC 才是最安全的!</strong>
tls使用的是 MAC-then-Encrypt 的模式，导致了一些问题。
具体比较，参见：
<a href="http://cseweb.ucsd.edu/~mihir/papers/oem.pdf">http://cseweb.ucsd.edu/~mihir/papers/oem.pdf</a>
<a href="https://www.iacr.org/archive/crypto2001/21390309.pdf">https://www.iacr.org/archive/crypto2001/21390309.pdf</a>
<a href="http://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac">http://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac</a>
<a href="https://news.ycombinator.com/item?id=4779015">https://news.ycombinator.com/item?id=4779015</a>
<a href="http://tozny.com/blog/encrypting-strings-in-android-lets-make-better-mistakes/">http://tozny.com/blog/encrypting-strings-in-android-lets-make-better-mistakes/</a></p>

<p>鉴于这个陷阱如此险恶，学术界有人就提出了，干脆把Encrypt和MAC直接集成为一个算法，在算法内部解决好安全问题，不再让码农选择，避免众码农再被这个陷阱坑害，这就是AEAD（Authenticated-Encryption With Additional data）类的算法，GCM模式就是AEAD最重要的一种。</p>

<a name="L4..record.....................--MAC"></a>
<h3>4. record层的密码学保护&ndash;MAC</h3>

<p>TLS record 层 MAC的计算方法：
<code>c
      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);
</code></p>

<p>其中的seq_num是当前record的 sequence number，每条record都会++，
可以看到把 seq_num，以及record header里面的几个字段也算进来了，这样<strong>解决了防重放问题</strong>，并且保证record的任何字段都不能被篡改。</p>

<p>算完MAC，格式如下：
<code>c
      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;
</code></p>

<p>然后根据SecurityParameters.cipher_type，选择对应的对称加密算法进行加密，分类解说如下：</p>

<a name="L5..record.....................--stream.cipher"></a>
<h3>5. record层的密码学保护&ndash;stream cipher</h3>

<p>stream cipher:
算stream cipher，stream cipher的状态在连续的record之间会复用。
stream cipher的主力是RC4，但是目前RC4已经爆出多个漏洞，所以实际中基本不使用流加密没法，详情请见：</p>

<p><a href="https://tools.ietf.org/html/rfc7457#section-2.5">https://tools.ietf.org/html/rfc7457#section-2.5</a></p>

<p><a href="http://www.freebuf.com/news/72622.html">[FreeBuf] RC4加密已不再安全，破解效率极高</a></p>

<p><a href="http://www.imperva.com/docs/HII_Attacking_SSL_when_using_RC4.pdf">http://www.imperva.com/docs/HII_Attacking_SSL_when_using_RC4.pdf</a></p>

<a name="L6..record.....................--.CBC.block.cipher"></a>
<h3>6. record层的密码学保护&ndash; CBC block cipher</h3>

<p>CBC模式块加密
TLS目前靠得住的的块加密cipher也不多，基本就是AES（最靠谱，最主流），Camellia，SEED，（3DES，IDEA之类已经显得老旧，DES请禁用），加密完的格式如下：</p>

<pre><code class="c">      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;
</code></pre>

<p>这个值得说道说道，因为我们码农平常在业界还能看到很多用AES-CBC的地方，其中的几个参数：</p>

<dl>
<dt>   IV </dt>
<dd><p>： 要求<strong>必须用密码学安全的伪随机数生成器(CSPRNG)</strong>生成，并且必须是不可预测的，在Linux下，就是用用/dev/urandom，或者用 openssl 库的 RAND_bytes()。</p>

<p> 注意：TLS 在 1.1版本之前，没有这个IV字段，前一个record的最后一个block被当成下一个record的IV来用，然后粗大事了，这导致了 <a href="http://www.openssl.org/~bodo/tls-cbc.txt">BEAST攻击</a>。
 所以，TLS1.2改成了这样。
 (<strong>还在使用CBC的各位，建议关注一下自己的IV字段是怎么生成出来的。如果要用，做好和TLS1.2的做法保持一致</strong>)。</p>

<p> 其中  SecurityParameters.record_iv_length 一定等于    SecurityParameters.block_size.
 例如 AES-256-CBC的 IV 一定是16字节长的，因为AES 128/192/256 的block size都是16字节。</p>

<p> padding</p></dd>
<dd><p>  使用CBC常用的PKCS 7 padding（在block size=16字节这种情况下，和pkcs 5的算法是一回事，java代码里面就可以这么用这个case里，和pkcs 5的结果是一样的）</p>

<p> padding_length</p></dd>
<dd>  就是PKCS 7 padding的最后一个字节</dd>
</dl>

<p> 注意2个险恶的陷阱：
 1. 实现的代码必须在收到全部明文之后才能传输密文，否则可能会有BEAST攻击
 2. 实现上，根据MAC计算的时间，可能进行时间侧通道攻击，因此必须确保&ndash;<strong>运行时间和padding是否正确无关</strong>。</p>

<a name="L7..record.....................--.AEAD.cipher"></a>
<h3>7. record层的密码学保护&ndash; AEAD cipher</h3>

<p>AEAD
到了我们重点关注的AEAD，AEAD是新兴的主流加密模式，是目前最重要的模式，其中主流的AEAD模式是 aes-gcm-128/aes-gcm-256/chacha20-poly1305</p>

<p>AEAD加密完的格式是：</p>

<pre><code class="c">      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;
</code></pre>

<p>   AEAD ciphers的输入是: key，nonce, 明文,和 &ldquo;additional data&rdquo;.
   key是   client_write_key 或者 the server_write_key.  不需要使用 MAC key.</p>

<p>   每一个AEAD算法都要指定不同的nonce构造算法，并指定 GenericAEADCipher.nonce_explicit 的长度.
   在TLS 1.2中，规定很多情况下，可以按照rfc5116 section 3.2.1的技术来做。其中record_iv_length是nonce的显式部分的长度，nonce的隐式部分从key_block作为  client_write_iv和 and server_write_iv得出，并且把显式部分放在 GenericAEAEDCipher.nonce_explicit 里.</p>

<p>在TLS 1.3 draft中，做了更改:</p>

<ol>
<li>规定 AEAD算法的 nonce的长度规定为 max(8 bytes, N_MIN)，即如果N_MIN比8大，就用N_MIN; 如果比8小，就用8。</li>
<li>并且规定 N_MAX小于8字节的AEAD不得用于TLS。</li>
<li><p>规定TLS AEAD中每条record的nonce通过下面的方法构造出来：
64bit的sequence number的右侧填充0，直到长度达到iv_length。然后把填充过的sequence number和静态的 client_write_iv或 server_write_iv （根据发送端选择）做异或(XOR)。异或完成后，得到的 iv_length 的nonce就可以做每条record的nonce用了。</p>

<p> AEAD输入的明文就是  TLSCompressed.fragment (记得上面的介绍吗？AEAD是MAC和encrypt的集成，所以输入数据不需要在算MAC了).</p>

<p> AEAD输入的additional_data 是:</p></li>
</ol>


<pre><code class="c">      additional_data = seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;
</code></pre>

<p>&ldquo;+&rdquo; 表示字符串拼接。
    可以看到，此处类似上面的MAC计算，算入了seq_num来防重放，type,version,length等字段防止这些元数据被篡改。</p>

<pre><code class="c">      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,
                                   additional_data)
</code></pre>

<p>  解密+验证完整性：</p>

<pre><code class="c">    TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,
                                            AEADEncrypted,
                                            additional_data)
</code></pre>

<p>   如果解密/验证完整性失败,就回复一条 fatal bad_record_mac alert 消息.</p>

<p>aes-gcm的iv长度，nonce长度，nonce构成等，后续再深入探讨。</p>

<a name="L8..record.....................--.Key......"></a>
<h3>8. record层的密码学保护&ndash; Key扩展</h3>

<p>Key 扩展</p>

<p>TLS握手生成的master_secret只有48字节，2组encryption key, MAC key, IV加起来，长度一般都超过48，(例如 AES_256_CBC_SHA256 需要 128字节),所以，TLS里面用1个函数，来把48字节延长到需要的长度，称为PRF：</p>

<pre><code class="c">      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);
</code></pre>

<p>然后，key_block像下面这样被分割：</p>

<pre><code class="c">      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]
</code></pre>

<p>  TLS使用HMAC结构，和在CipherSuite中指定的hash函数（安全等级起码是SHA256的水平）
  来构造PRF，</p>

<p>首先定义P_hash，把(secret,seed)扩展成无限长的字节流：</p>

<pre><code class="c">      P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                             HMAC_hash(secret, A(2) + seed) +
                             HMAC_hash(secret, A(3) + seed) + ...
</code></pre>

<p>其中"+&ldquo;表示字符串拼接。
  A() 定义为:</p>

<pre><code class="c">      A(0) = seed
      A(i) = HMAC_hash(secret, A(i-1))
</code></pre>

<p>   TLS的 PRF 就是把 P_hash 应用在secret上:</p>

<pre><code class="c">      PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)
</code></pre>

<p>   其中 label 是一个协议规定的，固定的 ASCII string.</p>

<p>要注意的是，TLS 1.3里面已经废弃了这种方式，改为使用<strong>更靠谱的 HKDF</strong>，HKDF 也是 html5的WebCryptoAPI的标准算法之一。</p>

<a name="L5..handshake......."></a>
<h2>5. handshake 协议</h2>

<p>handshake protocol重要而繁琐。</p>

<p>TLS 1.3对握手做了大修改，下面先讲TLS 1.2，讲完再介绍一下分析TLS 1.3.</p>

<a name="L1.handshake..............."></a>
<h3>1.handshake的总体流程</h3>

<p>handshake protocol用于产生给record protocol使用的SecurityParameters。
在handshake中:</p>

<ul>
<li>客户端和服务器端协商TLS协议版本号和一个CipherSuite，</li>
<li>认证对端的身份（可选，一般如https是客户端认证服务器端的身份），</li>
<li>并且使用密钥协商算法生成共享的master secret。</li>
</ul>


<p>步骤如下：</p>

<ul>
<li><p>  交换Hello消息，协商出算法，交换random值，检查session resumption.</p></li>
<li><p>  交换必要的密码学参数，来允许client和server协商出premaster secret。</p></li>
<li><p>  交换证书和密码学参数，让client和server做认证，证明自己的身份。</p></li>
<li><p>  从premaster secret和交换的random值 ，生成出master secret。</p></li>
<li><p>  把SecerityParameters提供被record层。</p></li>
<li><p>  允许client和server确认对端得出了相同的SecurityParameters，并且握手过程的数据没有被攻击者篡改。</p></li>
</ul>


<p>Handshake的结果是在双方建立相同的Session，Session 包含下列字段：</p>

<ol>
<li>session identifier
 session id，用来唯一标识一个session，在session 恢复的时候，也要用到</li>
<li>peer certificate
 对端的 X509v3 格式证书. 如果不需要认证对端的身份，就为空。</li>
<li>compression method
 压缩算法，一般被禁用</li>
<li>cipher spec
 CipherSuite，如上文介绍，包含： 用于生成key的pseudorandom function (PRF) , 块加密算法例如AES, MAC算法 (例如 HMAC-SHA256). 还包括一个 mac_length字段，在后文的we握手协议介绍</li>
<li>master secret
 48字节的，client和server共享密钥。</li>
<li>is resumable
 一个标志位，用来标识当前session是否能被恢复。</li>
</ol>


<p>以上字段，随后被用于生成 record层的SecurityParameters，多个连接可以通过握手协议的session恢复功能来复用同一个session。</p>

<p>握手协议使用 非对称加密/密钥协商/数字签名  3类算法，
因此要求读者对这3类算法概念清晰，能准确区分。
在此澄清一下,：
非对称的算法分为3类:
，
*  非对称加密，有：RSAES-PKCS1-v1_5，RSAES-OAEP ,Rabin-Williams-OAEP, Rabin-Williams-PKCS1-v1_5等
*  非对称密钥协商，有：DH，DHE，ECDH，ECDHE 等
*  非对称数字签名：RSASSA-PKCS1-v1_5，RSASSA-PSS，ECDSA，DSA，ED25519 等</p>

<p>另外，<strong>非对称加密算法，可以当作密钥协商算法来用，所以 RSAES-PKCS1-v1_5，RSAES-OAEP 也可以当作密钥协商算法来用</strong>。</p>

<hr />

<p>插播一段 RSA：</p>

<p>RSA的实际工程应用，要遵循PKCS#1 标准，见 <a href="https://www.ietf.org/rfc/rfc3447">https://www.ietf.org/rfc/rfc3447</a></p>

<p>其中的 RSAES-PKCS1-v1_5 和 RSASSA-PKCS1-v1_5 是使用RSA算法的两种不同scheme（体制）。
RSAES表示 RSA Encryption schemes，即非对称加密，
RSAES有：RSAES-OAEP，RSAES-PKCS1-v1_5两种，其中RSAES-OAEP更新更安全</p>

<p>RSASSA表示 Signature schemes with appendix，即appendix模式(appendix和recovery的区别请参看密码学教材)的非对称数字签名算法。
RSASSA有： RSASSA-PSS, RSASSA-PKCS1-v1_5 两种， 其中RSASSA-PSS更新更安全</p>

<p>RSA还有一个缺陷，就是很容易被时间侧通道攻击，所以现在的RSA实现都要加 blinding ，后文有介绍。</p>

<p>可以看到，RSA是一种很特殊的算法，既可以当非对称加密算法使用，又可以当非对称数字签名使用。这一点很有迷惑性，其实很多用RSA的人都分不清自己用的是RSA的哪种模式。</p>

<p>相比之下，ECC(椭圆曲线)这一块的算法就很清晰，ECDSA只能用作数字签名，ECDH只能用作密钥交换。</p>

<p>分清楚 RSAES-PKCS1-v1_5 和 RSASSA-PKCS1-v1_5 有什么用涅？</p>

<p>PKCS#1规范解释：</p>

<blockquote><p>   A generally good cryptographic practice is to employ a given RSA
key    pair in only one scheme.  This avoids the risk that
vulnerability in    one scheme may compromise the security of the
other, and may be    essential to maintain provable security.</p></blockquote>

<p>FIPS PUB 186-3  美国标准规定：</p>

<blockquote><p>An RSA key pair used for digital signatures shall only be used for one
digital signature scheme (e.g., ANS X9.31, RSASSA-PKCS1 v1.5 or
RSASSA-PSS; see Sections 5.4 and 5.5). In addition, an RSA digital
signature key pair shall not be used for other purposes (e.g., key
establishment).</p></blockquote>

<p><strong>一对密钥只做一个用途，要么用作非对称加解密，要么用作签名验证，别混着用！</strong>
<strong>一对密钥只做一个用途，要么用作非对称加解密，要么用作签名验证，别混着用！</strong>
<strong>一对密钥只做一个用途，要么用作非对称加解密，要么用作签名验证，别混着用！</strong></p>

<p>这个要求，决定了一个协议的 PFS（前向安全性），在斯诺登曝光NSA的“今日捕获，明日破解”政策后，<strong>越发重要</strong>。</p>

<p><a href="https://news.ycombinator.com/item?id=5942534">https://news.ycombinator.com/item?id=5942534</a></p>

<p><a href="http://news.netcraft.com/archives/2013/06/25/ssl-intercepted-today-decrypted-tomorrow.html">http://news.netcraft.com/archives/2013/06/25/ssl-intercepted-today-decrypted-tomorrow.html</a></p>

<p><a href="https://lwn.net/Articles/572926/">https://lwn.net/Articles/572926/</a></p>

<p><a href="https://www.eff.org/deeplinks/2014/04/why-web-needs-perfect-forward-secrecy">https://www.eff.org/deeplinks/2014/04/why-web-needs-perfect-forward-secrecy</a></p>

<p><a href="http://www.wired.com/2013/10/lavabit_unsealed">http://www.wired.com/2013/10/lavabit_unsealed</a></p>

<p>PFS反映到密钥协商过程中，就是：</p>

<ul>
<li> <strong>不要使用RSA做密钥协商，一定只用RSA做数字签名</strong>。</li>
<li> <strong>不要把ECDH的公钥固定内置在客户端做密钥协商</strong></li>
</ul>


<p>后文可以看到这一原则在 TLS 1.3,  QUIC，Apple的iMessage等协议中一再贯彻。</p>

<p>非对称RSA/ECC这个话题比较大了，后面有空再写文章吧，读者可以先看一下参考资料，里面有清晰的介绍。</p>

<p>插播结束，继续TLS。</p>

<hr />

<p>由于设计的时候，就要考虑兼容性，而且实际历史悠久，所以TLS协议90年代曾经使用的一些算法，现在已经被破解了，例如有的被发现漏洞(rc4)，有的密钥长度过短(例如曾经美帝有出口限制，限制RSA 在512比特以下，对称加密密钥限制40比特以下，后来2005年限制被取消)，但是考虑到兼容，现在的TLS实现中，还是包含了这种已经被破解的老算法的代码。这样，如果攻击者可以干扰握手过程，诱使client和server使用这种已经被破解的算法，就会威胁TLS协议的安全，这被称为“降级攻击”。</p>

<p>为了在握手协议解决降级攻击的问题，TLS协议规定：client发送ClientHello消息，server必须回复ServerHello消息，否则就是fatal error，当成连接失败处理。ClientHello和ServerHello消息用于建立client和server之间的安全增强能力，ClientHello和ServerHello消息建立如下属性：</p>

<ul>
<li>Protocol Version</li>
<li>Session ID</li>
<li>Cipher Suite</li>
<li>Compression Method.</li>
</ul>


<p>另外，产生并交换两个random值 ClientHello.random 和 ServerHello.random</p>

<p>密钥协商使用四条： server的Certificate，ServerKeyExchange，client的Certificate，ClientKeyExchange 。TLS规定以后如果要新增密钥协商方法，可以订制这4条消息的数据格式，并且指定这4条消息的使用方法。密钥协商得出的共享密钥<strong>必须足够长</strong>，<strong>当前定义的密钥协商算法生成的密钥长度必须大于46字节</strong>。</p>

<p>在hello消息之后，server会把自己的证书在一条Certificate消息里面发给客户端(如果需要做服务器端认证的话，例如https)。 并且，如果需要的话，server会发送一条ServerKeyExchange消息，（例如如果服务器的证书只用做签名，不用做密钥交换，或者服务器没有证书）。client对server的认证完成后，server可以要求client发送client的证书，如果这是协商出来的CipherSuite允许的。下一步，server会发送ServerHelloDone消息，表示握手的hello消息部分已经结束。然后server会等待一个client的响应。如果server已经发过了CertificateRequest消息，client必须发送Certificate消息。然后发送ClientKeyExchange消息，并且这条消息的内容取决于ClientHello和ServerHello消息协商的算法。如果client发送了有签名能力的证书，就显式发送一个经过数字签名的CertificateVerify消息，来证明自己拥有证书私钥。</p>

<p>然后，client发送一个ChangeCipherSpec消息，并且client拷贝待定的Cipher  Spec到当前的Cipher Spec。然后client立即用新算法+新key+新密钥 发送Finished消息。收到后，server发送自己的ChangeCipherSpec消息，作为响应，并且拷贝待定的Cipher Spec到当前的Cipher Spec。此时，握手就完成了，client和server可以开始交换应用层数据（如下图所示）。应用层数据不得在握手完成前发送。</p>

<p>引用一个来自网络的图片：
<img src="/images/blog/tls/tls_handshake.png" alt="" /></p>

<pre><code class="c">
      Client                                               Server

      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data

             Figure 1.  Message flow for a full handshake

   * 表示可选的消息，或者根据上下文在某些情况下会发送的消息。Indicates optional or situation-dependent messages that are not
   always sent.
</code></pre>

<p>注：为了帮助解决管道阻塞的问题，ChangeCipherSpec是一个独立的TLS protocol content type，并不是一个握手消息。</p>

<p>TLS的完整握手过程，要进行RSA/ECDH/ECDSA等非对称计算，非对称计算是很慢的。关于非对称的性能：
例如在2015年的服务器cpu：  Intel&reg; Xeon&reg; CPU E3-1230 V2 @ 3.30GHz 上，
使用如下命令测试：</p>

<pre><code class="sh">    openssl speed rsa2048
    openssl speed ecdsap256
    openssl speed ecdhp256
    openssl speed aes-128-cbc
    openssl speed -evp aes-128-cbc
</code></pre>

<p>结果如下表：</p>

<table>
<thead>
<tr>
<th> 算法   </th>
<th> 性能 </th>
<th> 性能  </th>
</tr>
</thead>
<tbody>
<tr>
<td>RSA-2048 </td>
<td> 私钥运算 723.7 次/秒   </td>
<td> 公钥运算 23505.8 次/秒 </td>
</tr>
<tr>
<td> 256 bit ecdsa (nistp256)  </td>
<td> 签名   8628.4 次/秒    </td>
<td> 验证  2217.0 次/秒 </td>
</tr>
<tr>
<td> 256 bit ecdh (nistp256) </td>
<td>  ECDH协商 2807.8 次/秒</td>
<td></td>
</tr>
<tr>
<td> aes-128-cbc </td>
<td> 加密 121531.39 K/秒</td>
<td></td>
</tr>
<tr>
<td> aes-128-cbc 使用aesni硬件加速</td>
<td>  加密 683682.13 K/秒 </td>
<td></td>
</tr>
</tbody>
</table>


<p>注：非对称的单位是 次/秒，这是由于非对称一般只用于处理一个block，
对称的单位是 K/秒，因为对称一般用于处理大量数据流，所以单位和流量一样。
可以给非对称的 次/秒 乘以 block  size ，就可以和对称做比较了。例如rsa-2048，723.7*2048/8/1024=185.2672 K/秒 ，
故 <strong>RSA-2048 私钥运算性能 是aes-128-cbc 的 $1.5/1000$。是aesni的 $2.6/10000$</strong>。</p>

<p>如上，性能数据惨不忍睹， <strong>简直不能忍！！！</strong></p>

<p>有鉴于此，TLS从设计之初，就采用了万能手段&ndash;<strong>加cache</strong>，有2种cache手段：session id，和session ticket。把握手的结果直接cache起来，绕过握手运算。</p>

<p>当client和server决定恢复一个之前的session，或复用一个已有的session时(可以不用协商一个新的SecurityParameters)，消息流程如下：</p>

<p>   客户端使用要被恢复的session，发送一个ClientHello，把Session ID包含在其中。server在自己的session cache中，查找客户端发来的Session ID，如果找到，sever把找到的session 状态恢复到当前连接，然后发送一个ServerHello，在ServerHello中把Session ID带回去。然后，client和server都必须ChangeCipherSpec消息，并紧跟着发送Finished消息。这几步完成后，client和server 开始交换应用层数据（如下图所示）。如果server在session cache中没有找到Session ID，那server就生成一个新的session ID在ServerHello里给客户端，并且client和server进行完整的握手。</p>

<p>   流程图如下：</p>

<pre><code class="c">      Client                                                Server

      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data

          Figure 2.  Message flow for an abbreviated handshake
</code></pre>

<a name="L3..handshake..................."></a>
<h3>3. handshake 协议外层结构</h3>

<p>   从消息格式来看，TLS Handshake Protocol 在 TLS Record Protocol 的上层. 这个协议用于协商一个session的安全参数。 Handshake 消息（例如ClientHello，ServerHello等） 被包装进 TLSPlaintext结构里面，传入TLS record层，根据当前session 状态做处理，然后传输。</p>

<p>如下：</p>

<pre><code class="c">      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
              case session_ticket:      NewSessionTicket; /* NEW */
          } body;
      } Handshake;
</code></pre>

<p>TLS协议规定，handshake 协议的消息必须按照规定的顺序发，收到不按顺序来的消息，当成fatal error处理。也就是说，TLS协议可以当成状态机来建模编码。</p>

<p>下面按照消息发送必须遵循的顺序，逐个解释每一条握手消息。</p>

<p>handshake协议的外层字段，见这个抓包：</p>

<p>  <img src="/images/blog/tls/handshake_protocol.png" alt="" /></p>

<a name="L4..handshake..--.ClientHello...ServerHello...HelloRequest"></a>
<h3>4. handshake  &ndash; ClientHello，ServerHello，HelloRequest</h3>

<p>Hello消息有3个：ClientHello, ServerHello，HellloRequest
逐个说明：</p>

<a name="L4.1.Client.Hello"></a>
<h4>4.1 Client Hello</h4>

<p>当客户端第一次连接到服务器时，第一条message必须发送ClientHello。
另外，rfc里规定，如果客户端和服务器支持重协商，在客户端收到服务器发来的HelloRequest后，也可以回一条ClientHello，在一条已经建立的连接上开始重协商。(重协商是个很少用到的特性。)</p>

<p>消息结构：</p>

<pre><code class="c">
   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;

   opaque SessionID&lt;0..32&gt;;

   uint8 CipherSuite[2];

   enum { null(0), (255) } CompressionMethod;

   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ClientHello;
</code></pre>

<p>Random 其中：
      gmt_unix_time 是 unix epoch时间戳。
      random_bytes 是 28字节的，用密码学安全随机数生成器 生成出来的随机数。</p>

<hr />

<p>密码学安全的随机数生成，这是个很大的话题，也是一个大陷阱，目前最好的做法就是用 /dev/urandom，或者openssl库的 RAND_bytes()</p>

<p>历史上，恰好就在SSL的random_bytes这个字段，NetScape浏览器早期版本被爆出过随机数生成器漏洞。
被爆菊的随机数生成器使用 pid + 时间戳 来初始化一个seed，并用MD5(seed)得出结果。
见 <a href="http://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html">http://www.cs.berkeley.edu/~daw/papers/ddj-netscape.html</a>，
建议读者检查一下自己的随机数生成器。</p>

<hr />

<dl>
<dt>client_version</dt>
<dd><pre><code> 客户端支持的最高版本号。
</code></pre></dd>
<dt>random</dt>
<dd><pre><code>客户端生成的random。
</code></pre></dd>
</dl>

<p>ClientHello.session_id 唯一标识一个session，用来做session cache。如果为空，表示不做复用，要求服务器生成新的session。
session_id的来源有：</p>

<ol>
<li>之前的协商好的连接的session_id</li>
<li>当前连接的session_id</li>
<li>当前也在使用中的另一条连接的session_id</li>
</ol>


<p>其中第三种允许不做重新握手，就同时建立多条独立的安全连接。这些独立的连接可能顺序创建，也可以同时创建。一个SessionID当握手协商的Finished消息完成后，就合法可用了。存活直到太旧被移除，或者session 关联的某个连接发生fatal error。SessionID的内容由服务器端生成。</p>

<p>注：由于SessionID的传输是不加密，不做MAC保护的，服务器不允许把私密信息发在里面，不能允许伪造的SessionID在服务器造成安全问题。（握手过程中的数据，整体是受Finished消息的保护的）</p>

<p>ClientHello.cipher_suites字段，包含了客户端支持的CipherSuite的列表，按照客户端希望的优先级排序，每个CipherSuite有2个字节，每个CipherSuite由：一个密钥交换算法，一个大量数据加密算法(需要制定key length参数)，一个MAC算法，一个PRF 构成。服务器会从客户端发过来的列表中选择一个；如果没有可以接受的选择，就返回一个 handshake failure 的 alert，并关闭连接。如果列表包含服务器不认识，不支持，或者禁用的CipherSuite，服务器必须忽略。
如果SessionID不为空，则cipher_suites里面起码要包含客户端cache的session里面的那个CipherSuite</p>

<p>compression_methods，类似地，ClientHello里面包含压缩算法的列表，按照客户端优先级排序。当然，如前介绍，服务器一般禁用TLS的压缩。</p>

<p>compression_methods 后面可以跟一组扩展(extensions)， extensions都是可选的，比较有用的扩展如： SNI, session ticket，ALPN，OCSP 等，后文介绍。</p>

<p>客户端发送了ClientHello后，服务器端必须回复ServerHello消息，回复其他消息都会导致 fatal error 关闭连接。</p>

<a name="L4.2..Server.Hello"></a>
<h4>4.2  Server Hello</h4>

<p>当收到客户端发来的ClientHello后，正常处理完后，服务器必须回复ServerHello。</p>

<p>消息结构：</p>

<pre><code class="c">      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions&lt;0..2^16-1&gt;;
          };
      } ServerHello;
</code></pre>

<dl>
<dt>server_version</dt>
<dd>  服务器选择 ClientHello.client_version 和 服务器支持的版本号 中的最小的。</dd>
<dt> random</dt>
<dd><pre><code> 服务器生成的random，必须确保和客户端生成的random没有关联。
</code></pre></dd>
<dt> session_id</dt>
<dd><pre><code> 服务器为本连接分配的SessionID。如果ClientHello.session_id不为空，服务器会在自己的本地做查找。
</code></pre></dd>
</dl>

<ul>
<li>如果找到了匹配，并且服务器决定复用找到的session建立连接，服务器应该把ClientHello.session_id同样的 session id填入ServerHello.session_id，这表示恢复了一个session，并且双方会立即发送Finished消息。</li>
<li>否则，回复一个和ClientHello.session_id不同的Serverhello.session_id，来标识新session。服务器可以回复一个空的session_id，来告诉客户端这个session不要cache，不能恢复。
如果一个session 被恢复了，那必须恢复成之前协商的session里面的 CipherSuite。要注意的是，并不要求服务器一定要恢复session，   服务器可以不做恢复。</li>
</ul>


<p>在实践中，session cache在服务器端要求key-value形式的存储，如果tls服务器不止一台的话，就有一个存储怎么共享的问题，要么存储同步到所有TLS服务器的内存里，要么专门搞服务来支持存储，并使用rpc访问，
无论如何，都是很麻烦的事情，相比之下，后文要介绍的session ticket就简单多了，所以一般优先使用session ticket。</p>

<dl>
<dt>   cipher_suite</dt>
<dd><pre><code> 服务器选定的一个CipherSuite。如果是恢复的session，那就是session里的CipherSuite。
</code></pre>

<p> compression_method</p></dd>
<dd><pre><code> 跟上面类似。
</code></pre>

<p>extensions</p></dd>
<dd>  扩展列表。要注意的是，ServerHello.extensions 必须是 ClientHello.extensions的子集。</dd>
</dl>

<a name="L4.3..Hello.Extensions"></a>
<h4>4.3  Hello Extensions</h4>

<p>   The extension 的格式是:</p>

<pre><code class="c">
      struct {
          ExtensionType extension_type;
          opaque extension_data&lt;0..2^16-1&gt;;
      } Extension;

      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;
</code></pre>

<p> 其中:</p>

<ul>
<li><p>  &ldquo;extension_type&rdquo; 标识是哪一个扩展类型。</p></li>
<li><p>  &ldquo;extension_data&rdquo; 一坨二进制的buffer，扩展的数据体，各个扩展自己做解析。</p></li>
</ul>


<p>extension_type 只能出现一次，ExtensionType之间不指定顺序。</p>

<p>extensions 可能在新连接创建时被发送，也可能在要求session恢复的时候被发送。所以各个extension都需要规定自己再完整握手和session恢复情况下的行为。
这些情况比较琐碎而微妙，具体案例要具体分析。</p>

<a name="L4.4..Hello.Request"></a>
<h4>4.4  Hello Request</h4>

<p>服务器任何时候都可以发送 HelloRequest 消息。</p>

<p>HelloRequest的意思是，客户端应该开始协商过程。客户端应该在方便的时候发送ClientHello。服务器不应该在客户端刚创建好连接后，就发送HelloRequest，此时应该让客户端发送ClientHello。</p>

<p>客户端收到这个消息后，可以直接忽略这条消息。
服务器发现客户端没有响应HelloRequest后，可以发送fatal error alert。</p>

<p>消息结构：
<code>c
      struct { } HelloRequest;
</code>
   HelloRequest不包含在握手消息的hash计算范围内。</p>

<a name="L5..handshake.--.Server.Certificate"></a>
<h3>5. handshake &ndash; Server Certificate</h3>

<p>当服务器确定了CipherSuite后，根据CipherSuite里面的认证算法，如果需要发送证书给客户端，那么就发送 Server Certificate消息给客户端。Server Certificate总是在ServerHello之后立即发送，所以在同一个RTT里。</p>

<p>Server Certificate里面包含了服务器的证书链。</p>

<p>消息结构：</p>

<pre><code class="c">      opaque ASN.1Cert&lt;1..2^24-1&gt;;

      struct {
          ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
</code></pre>

<dl>
<dt>   certificate_list</dt>
<dd><pre><code> 证书列表，**发送者的证书必须是第一个，后续的每一个证书都必须是前一个的签署证书。根证书可以省略**
</code></pre></dd>
</dl>

<p>证书申请的时候，一般会收到好几个证书，有的需要自己按照这个格式来拼接成证书链。</p>

<p> 如果服务器要认证客户端的身份，那么服务器会发送Certificate Request消息，客户端应该也以 这条Server Certificate消息的格式回复。</p>

<p>服务器发送的证书必须：</p>

<ul>
<li><p>  证书类型必须是 X.509v3。除非明确地协商成别的了(比较少见，rfc里提到了例如 <a href="https://tools.ietf.org/html/rfc5081">OpenPGP格式</a>)。</p></li>
<li><p>  服务器证书的公钥，必须和选择的密钥交换算法配套。</p></li>
</ul>


<table>
<thead>
<tr>
<th>     密钥交换+认证算法 </th>
<th> 配套的证书中公钥类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>     RSA  /  RSA_PSK           </td>
<td> RSA 公钥；证书中必须允许私钥用于加密 （即如果使用了X509V3规定的key usage扩展， keyEncipherment比特位必须置位） <strong>这种用法没有前向安全性，因此在 TLS 1.3中被废弃了</strong> </td>
</tr>
<tr>
<td>                </td>
<td></td>
</tr>
<tr>
<td>     DHE_RSA /  ECDHE_RSA        </td>
<td> RSA 公钥；证书中必须允许私钥用于签名(即如果使用了X509V3规定的key usage扩展， digitalSignature比特位必须置位)，并且允许server key exchange消息将要使用的签名模式(例如 PKCS1_V1.5 ，OAEP等)和hash算法(例如sha1, sha256等) </td>
</tr>
<tr>
<td>              </td>
<td></td>
</tr>
<tr>
<td>      DHE_DSS           </td>
<td> DSA 公钥; 历史遗留产物，从来没有被大规模用过，安全性差，废弃状态。证书必须允许私钥用于签名，必须允许server key exchange消息中使用的hash算法。</td>
</tr>
<tr>
<td>        DH_DSS   / DH_RSA  </td>
<td> Diffie-Hellman 公钥; 要求key usage里面的keyAgreement比特位必须置位。 <strong>这种用法没有前向安全性，因此在 TLS 1.3中被废弃了</strong> </td>
</tr>
<tr>
<td>               </td>
<td></td>
</tr>
<tr>
<td>  ECDH_ECDSA   / ECDH_RSA      </td>
<td> 能做 ECDH 用途的公钥；公钥必须使用 客户端支持的ec曲线和点格式。<strong>这种用法没有前向安全性，因此在 TLS 1.3中被废弃了</strong></td>
</tr>
<tr>
<td>            </td>
<td></td>
</tr>
<tr>
<td>  ECDHE_ECDSA        </td>
<td> ECDSA用途的公钥；证书必须运输私钥用作签名，必须允许server key exchange消息里面要用到的hash算法。公钥必须使用客户端支持的ec曲线和点格式。</td>
</tr>
</tbody>
</table>


<ul>
<li>  &ldquo;server_name&rdquo; 和 &ldquo;trusted_ca_keys&rdquo; 扩展用于引导证书选择。</li>
</ul>


<p>其中有5种是ECC密钥交换算法：ECDH_ECDSA, ECDHE_ECDSA, ECDH_RSA, ECDHE_RSA, ECDH_anon。
ECC（椭圆曲线）体制相比RSA，由于公钥更小，性能更高，所以在移动互联网环境下越发重要。
以上ECC的5种算法都用ECDH来计算premaster  secret， 仅仅是ECDH密钥的生命周期和认证算法不同。
其中只有 ECDHE_ECDSA 和 ECDHE_RSA 是前向安全的。</p>

<p>如果客户端在ClientHello里提供了 &ldquo;signature_algorithms&rdquo; 扩展，那么服务器提供的所有证书必须用 &ldquo;signature_algoritms"中提供的 hash/signature算法对 之一签署。要注意的是，这意味着，一个包含某种签名算法密钥的证书，可能被另一种签名算法签署（例如，一个RSA公钥可能被一个ECDSA公钥签署）。(这在TLS1.2和TLS1.1中是不一样的，TLS1.1要求所有的算法都相同。)注意这也意味着DH_DSS,DH_RSA,ECDH_ECDSA,和ECDH_RSA 密钥交换不限制签署证书的算法。固定DH证书可能使用"signature_algorithms"扩展列表中的 hash/签名算法对 中的某一个签署。名字 DH_DSS, DH_RSA, ECDH_ECDSA, 和 ECDH_RSA 只是历史原因，这几个名字的后半部分中指定的算法，并不会被使用，即DH_DSS中的DSS并不会被使用，DH_RSA中并不会使用RSA做签名，ECDH_ECDSA并不会使用ECDSA算法。。。
如果服务器有多个证书，就必须从中选择一个，一般根据服务器的外网ip地址，SNI中指定的hostname，服务器配置来做选择。如果服务器只有一个证书，那么要确保这一个证书符合这些条件。
要注意的是，存在一些证书使用了TLS目前不支持的 算法组合。例如，使用 RSASSA-PSS签名公钥的证书（即证书的SubjectPublicKeyInfo字段是id-RSASSA-PSS）。由于TLS没有给这些算法定义对应的签名算法，这些证书不能在TLS中使用。
如果一个CipherSuite指定了新的TLS密钥交换算法，也会指定证书格式和要求的密钥编码方法。</p>

<a name="L6..handshake..--.Server.Key.Exchange"></a>
<h3>6. handshake  &ndash; Server Key Exchange</h3>

<p>服务器会在 server Certificate 消息之后，立即发送 Server Key Exchange消息。
（如果协商出的CipherSuite不需要做认证，即anonymous negotiation，会在ServerHello之后立即发送Server Key Exchange消息）</p>

<p>只有在server Certificate 消息没有足够的信息，不能让客户端完成premaster的密钥交换时，服务器才发送 server Key Exchange， 主要是对前向安全的几种密钥协商算法，列表如下：</p>

<ol>
<li>DHE_DSS</li>
<li>DHE_RSA</li>
<li>DH_anon</li>
<li>ECDHE_ECDSA</li>
<li>ECDHE_RSA</li>
<li>ECDH_anon</li>
</ol>


<p>对下面几种密钥交换方法，发送ServerKeyExchange消息是非法的：</p>

<ol>
<li>RSA</li>
<li>DH_DSS</li>
<li>DH_RSA</li>
<li>ECDH_ECDSA</li>
<li>ECDH_RSA</li>
</ol>


<p>需要注意的是，ECDH和ECDSA公钥的数据结构是一样的。所以，CA在签署一个证书的时候，可能要使用 X.509 v3 的 keyUsage 和 extendedKeyUsage 扩展来限定ECC公钥的使用方式。</p>

<p>ServerKeyExchange传递足够的信息给客户端，来让客户端交换premaster secret。一般要传递的是：一个 Diffie-Hellman 公钥，或者一个其他算法(例如RSA)的公钥。</p>

<p>在TLS实际部署中，我们一般只使用这4种：ECDHE_RSA, DHE_RSA,  ECDHE_ECDSA，RSA</p>

<p>其中RSA密钥协商（也可以叫密钥传输）算法，由于没有前向安全性，在TLS 1.3里面已经被废除了。参见： <a href="http://www.ietf.org/mail-archive/web/tls/current/msg12266.html">Confirming Consensus on removing RSA key Transport from TLS   1.3 </a></p>

<p>消息格式：</p>

<pre><code class="c">      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa,    ec_diffie_hellman
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p&lt;1..2^16-1&gt;;
          opaque dh_g&lt;1..2^16-1&gt;;
          opaque dh_Ys&lt;1..2^16-1&gt;;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         Diffie-Hellman密钥协商计算的大质数模数。

      dh_g
         Diffie-Hellman 的生成元，

      dh_Ys
         服务器的Diffie-Hellman公钥 (g^X mod p).

        struct {
            opaque point &lt;1..2^8-1&gt;;
        } ECPoint;


        enum { explicit_prime (1), explicit_char2 (2),
               named_curve (3), reserved(248..255) } ECCurveType;

        struct {
            ECCurveType    curve_type;
            select (curve_type) {
                case named_curve:
                    NamedCurve namedcurve;
            };
        } ECParameters;


        struct {
            ECParameters    curve_params;
            ECPoint         public; //ECDH的公钥
        } ServerECDHParams;


      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case ec_diffie_hellman:
                  ServerECDHParams    params;
                  Signature           signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [TLSECC] */
          };
      } ServerKeyExchange;

      params
         服务器的密钥交换参数。

      signed_params
         对需要认证的（即非anonymous的）密钥交换，对服务器的密钥交换参数的数字签名。
</code></pre>

<p>ECParameters 结构比较麻烦，其中ECCurveType是支持3种曲线类型的，可以自行指定椭圆曲线的多项式系数，基点等参数。但是，我们基本不会用到这种功能，因为一般部署都是使用 NamedCurve，即参数已经预先选定，各种密码学库普遍都支持的一组曲线，其中目前用的最广的是 secp256r1 （还被称为 P256，或 prime256v1）</p>

<p>NamedCurve 列表中比较重要的曲线(在TLS1.3中，只保留了这几条曲线。)，定义如下：</p>

<pre><code class="c">        enum {
            ...
            secp256r1 (23), secp384r1 (24), secp521r1 (25),
            reserved (0xFE00..0xFEFF),
            (0xFFFF)
        } NamedCurve;
</code></pre>

<p>ECDHE_RSA 密钥交换算法的 SignatureAlgorithm 是 rsa 。
ECDHE_RSA 密钥交换算法的 SignatureAlgorithm 是 ecdsa。</p>

<p>如果客户端提供了 &ldquo;signature_algorithms&rdquo; 扩展， 则签名算法和hash算法必须是列在扩展中的算法。
要注意的是，这个地方可能有不一致，例如客户端可能提供了 DHE_DSS 密钥交换，但是 &ldquo;signature_algorithms"扩展中没有DSA算法，在这类情况下，为了正确地协商，服务器必须确保满足自己选择的CipherSuite满足 "signature_algorithms&rdquo; 的限制。这不优雅，但是是为了把对原来的CipherSuite协商的设计的改动减到最小，而做的妥协。</p>

<p>并且，hash和签名算法，必须和服务器的证书里面的公钥兼容。</p>

<a name="L7..handshake..--.Certificate.Request"></a>
<h3>7. handshake  &ndash; Certificate Request</h3>

<p>TLS规定了一个可选功能：服务器可以认证客户端的身份，这通过服务器要求客户端发送一个证书实现，服务器应该在ServerKeyExchange之后立即发送CertificateRequest消息。</p>

<p>消息结构：</p>

<pre><code class="c">      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3),dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5),dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20),
          ecdsa_sign(64), rsa_fixed_ecdh(65),
          ecdsa_fixed_ecdh(66), 
          (255)
      } ClientCertificateType;

      opaque DistinguishedName&lt;1..2^16-1&gt;;

      struct {
          ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
          SignatureAndHashAlgorithm
            supported_signature_algorithms&lt;2^16-1&gt;;
          DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
      } CertificateRequest;
</code></pre>

<dl>
<dt>certificate_types</dt>
<dd>   客户端可以提供的证书类型。</dd>
</dl>

<ul>
<li>rsa_sign        包含RSA公钥的证书。</li>
<li>dss_sign        包含DSA公钥的证书。</li>
<li>rsa_fixed_dh    包含静态DH公钥的证书。</li>
<li><p>dss_fixed_dh    包含静态DH公钥的证书。</p>

<dl>
<dt>supported_signature_algorithms</dt>
<dd><pre><code> 服务器支持的  hash/signature 算法的列表。
</code></pre></dd>
<dt> certificate_authorities</dt>
<dd><pre><code> 服务器可以接受的CA(certificate_authorities)的 distinguished names 的列表 DER编码格式.
</code></pre></dd>
</dl></li>
</ul>


<p>这些 distinguished names 可能为root CA或者次级CA指定了想要的 distinguished name ，因此，这个消息可以用来描述已知的root，或者希望的授权空间。
如果 certificate_authorities 列表是空的，那么客户端可以发送任何适当的 ClientCertificateType 类型的证书，如果没有别的限制的话。</p>

<p>   certificate_types 和 supported_signature_algorithms 字段的交叉选择很复杂。 certificate_types 这个字段从SSLv3时代就定义了，但是一直都没有详细定义，其大多数功能都被 supported_signature_algorithms 代替了。
   有如下规则：</p>

<ul>
<li><p>  客户端提供的任何证书，必须用一个supported_signature_algorithms 中出现过的  hash/signature 算法对 签名.</p></li>
<li><p>  客户端提供的末端证书必须提供一个和 certificate_types 兼容的key。 如果这个key是一个签名key，那必须能和 supported_signature_algorithms 中提供的某个 hash/signature 算法对配合使用。</p></li>
<li><p>  由于历史原因，某些客户端证书类型的名字，包含了证书的签名算法，例如，早期版本的TLS中， rsa_fixed_dh 意思是一个被RSA算法签署，并且包含一个固定DH密钥的证书。在TLS1.2中，这个功能被 supported_signature_algorithms 淘汰，并且证书类型不再限制用来签署证书的算法。例如，如果服务器发送了 dss_fixed_dh 证书类型，和 { {sha1, dsa}, {sha1,rsa} } 签名类型，客户端可以回复一个 包含静态DH密钥，用RSA-sha1签署的证书。</p></li>
<li><p> 如果协商出来的是匿名CipherSuite，服务器不能要求客户端认证。</p></li>
</ul>


<a name="L8..handshake..--.Server.Hello.Done"></a>
<h3>8. handshake  &ndash; Server Hello Done</h3>

<p>在 ServerHello和相关消息已经处理结束后，服务器发送ServerHelloDone。在发送ServerHelloDone后，服务器开始等待客户端的响应。</p>

<p>ServerHelloDone消息表示，服务器已经发送完了密钥协商需要的消息，并且客户端可以开始客户端的密钥协商处理了。</p>

<p>收到ServerHelloDone后，客户端应该确认服务器提供了合法的证书，并且确认服务器的ServerHello消息里面的参数是可以接受的。</p>

<p>消息格式：</p>

<pre><code class="c">      struct { } ServerHelloDone;
</code></pre>

<a name="L9..handshake..--.Client.Certificate"></a>
<h3>9. handshake  &ndash; Client Certificate</h3>

<p>ClientCertificate消息是客户端收到ServerHelloDone后，可以发送的第一条消息。仅当服务器要求了一个证书的情况下，客户端才发送ClientCertificate消息，如果没有可用的合适证书，客户端必须发送一条不包含任何证书的ClientCertificate消息（即 certificate_list 结构长度为0）。</p>

<p>如果客户端没有发送任何证书，服务器自行决定，可以放弃要求客户端认证，继续握手；或者发送一条 fatal handshake_failure的alert消息，断开连接。并且，如果证书链的某些方面是不能接受的（比如证书没有被可信任的CA签署），服务器可以自行决定，是继续握手（放弃要求客户端认证），或者发送一条fatal的alert。</p>

<p>客户端证书使用和ServerCertificate相同的结构发送。</p>

<p>ClientCertificate把客户端的证书链发送给服务器。服务器会使用证书链来验证CertificateVerify 消息（如果使用基于签名的客户端认证），或者来计算premaster secret（对于非短暂的 DH）。证书必须和协商出来的CipherSuite的密钥交换算法配套，并和任何协商的扩展配套。</p>

<p>尤其是：</p>

<ul>
<li> 证书必须是X.509v3 类型的。</li>
<li> 客户端的末级证书的公钥必须和CertificateRequest里列出的证书类型兼容。</li>
</ul>


<table>
<thead>
<tr>
<th>      客户端证书类型  </th>
<th>  证书公钥类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  rsa_sign </td>
<td> RSA公钥；证书必须允许公钥用于certificateVerify消息中的数字签名和hash算法 </td>
</tr>
<tr>
<td>  dss_sign </td>
<td> DSA 公钥；证书必须允许密钥使用CertificateVerify中的hahs函数做签名；</td>
</tr>
<tr>
<td>      ecdsa_sign         </td>
<td> 可以用作 ECDSA 的公钥；证书必须允许 公钥用 CertificateVerify中的hash函数做签名；公钥必须使用服务器支持的曲线，和点格式；</td>
</tr>
<tr>
<td>      rsa_fixed_dh / dss_fixed_dh   </td>
<td>   Diffie-Hellman 公钥; 必须使用和服务器key相同的参数。</td>
</tr>
<tr>
<td>      rsa_fixed_ecdh   /  ecdsa_fixed_ecdh </td>
<td>   可以用作 ECDH 的公钥。必须和服务器的公钥使用同样的曲线，同样的点格式</td>
</tr>
</tbody>
</table>


<ul>
<li>  如果 certificate_authorities 列表不是空的，客户端证书链中的某一个证书必须是CA中的某一个签署的。</li>
<li>  证书必须使用 服务器可以接受的 hash/signature 算法对。</li>
</ul>


<p>类似于Server Certificate，有一些证书目前无法在TLS中使用。</p>

<a name="L10..handshake.--.Client.Key.Exchange"></a>
<h3>10. handshake &ndash; Client Key Exchange</h3>

<p>客户端必须在客户端的Certificate消息之后，立即发送ClientKeyExchange消息。
或者必须在ServerHelloDone后立即发送ClientKeyExchange消息。</p>

<p>ClientKeyExchange消息中，会设置premaster secret，通过发送 RSA公钥加密premaster secret的密文，或者发送允许双方得出相同的premaster secret的Diffie-Hellman参数。</p>

<p>当客户端使用短暂的 Diffie-Hellman 密钥对时，ClientKeyExchange包含客户端的 Diffie-Hellman 公钥。如果客户端发送一个包含静态 Diffie-Hellman 指数的证书（比如，在使用固定DH的客户端认证），那么这条消息必须被发送，并且必须为空。</p>

<p>消息结构：
消息的选择取决于选择的密钥交换算法。</p>

<pre><code class="c">      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
              case ec_diffie_hellman: 
                  ClientECDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;
</code></pre>

<a name="L.1....RSA...........Premaster.Secret......."></a>
<h4>(1).  RSA 加密的 Premaster Secret 消息</h4>

<p>如果用RSA做密钥协商和认证，客户端生成 48字节的 premaster secret，使用服务器证书里面的公钥加密，然后把密文EncryptedPreMasterSecret发送给服务器，结构定义如下：</p>

<pre><code class="c">      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;

      client_version
         客户端支持的最新协议版本号，这个字段用来检测中间人版本回退攻击。T
      random
         46 字节的，安全生成的随机值。

      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;

      pre_master_secret
         这个随机值由客户端生成，用于生成master secret。
</code></pre>

<p>注：PreMasterSecret里面的 client_version 是 ClientHello.client_version，而不是协商的到的版本号，这个特性用来阻止版本回退攻击。不幸的是，有些不正确的老的代码使用了协商得到的版本号，导致检查client_version字段的时候，和正确的实现无法互通。</p>

<p>客户端实现必须在PreMasterSecret中发送正确的版本号。如果 ClientHello.client_version 的版本号是 TLS 1.1 或者更高，服务器实现必须如下检查版本号。如果版本号是 TLS 1.0 或者更早，服务器必须检查版本号，但是可以通过配置项关闭检查。</p>

<p>要注意的是，如果版本号检查失败了，PreMasterSecret 应该像下面描述的那样填充成随机数。</p>

<p>TLS中的RSA使用的是 PKCS1-V1.5 填充( PKCS1-V1.5也是openssl库RSA的默认填充方式)。Bleichenbacher 在1998年发表了一种针对 PKCS1-V1.5 的选择密文攻击， Klima在2003年发现  PKCS1-V1.5 中 PreMasterSecret 版本号检查的一个侧通道攻击。只要TLS 服务器暴露一条特定的消息是否符合PKCS1-V1.5格式，或暴露PreMasterSecret解密后结构是否合法，或版本号是否合法，就可以用上面2种方法攻击。</p>

<p>Klima 还提出了完全避免这类攻击的方法：对格式不正确的消息，版本号不符的情况，要做出和完全正确的RSA块一样的响应，要让客户端区分不出这3种情况。
具体地说，要如下：</p>

<ol>
<li>生成 46 字节的密码学安全随机值 R</li>
<li>解密消息，获得明文 M</li>
<li>如果 PKCS#1 填充不正确，或者 PreMasterSecret 消息的长度不是48字节，则
pre_master_secret = ClientHello.client_version || R
或者如果 ClientHello.client_version &lt;= TLS 1.0，并且明确禁止了版本号检查，则
pre_master_secret = ClientHello.client_version || M[2..47]</li>
</ol>


<p>注意：明确地用 ClientHello.client_version 构造 pre_master_secret 时，当客户端在原来的 pre_master_secret 中发送了错误的 客户端版本值时，会产生一个不合法的 master_secret 。</p>

<p> 另一种解决问题的方法是，把版本号不符，当成 PKCS-1 格式错误来对待，并且完全随机填充 premaster secret。</p>

<ol>
<li>生成 48 字节的密码学安全随机值 R</li>
<li>解密 PreMasterSecret 恢复出明文 M</li>
<li>如果 PKCS#1 填充不正确，或者消息的长度不是48字节，则
  pre_master_secret = R
或者如果 ClientHello.client_version &lt;= TLS 1.0，并且 明确禁止了版本号检查，则
  pre_master_secret = M
或者如果 M[0..1] != CleintHello.client_version
  pre_master_secret = R
或者
  pre_master_secret = M</li>
</ol>


<p>尽管实践中，还没有发现针对这种结构的攻击，Klima 在论文中描述了几种理论上的攻击方式，因此推荐上述的第一种结构。</p>

<p>在任何情况下，一个 TLS 服务器绝对不能在:1. 处理 RSA 加密的 premaster 消息失败, 2.或者版本号检查失败 时产生alert消息。当遇到这两种情况时，服务器必须用随机生成的 premaster 值继续握手。服务器可以把造成失败的真实原因log下来，用于调查问题，但是必须小心确保不能把这种信息泄漏给攻击者（比如通过时间侧通道，log文件，或者其它通道等泄漏）。</p>

<p>RSAES-OAEP 加密体制，更能抵抗 Bleichenbacher 发表的攻击，然而，为了和早期的TLS版本最大程度保持兼容，TLS 仍然规定使用  RSAES-PKCS1-v1_5 体制。只要遵守了上面列出的建议，目前还没有 Bleichenbacher 的变化形式能攻破 TLS 。</p>

<p>实现的时候要注意：公钥加密的数据用 字节数组 &lt;0..2<sup>16</sup>-1> 的形式表示。因此，ClientKeyExchange中的 RSA加密的PreMasterSecret 前面有2个字节用来表示长度。这2个字节在使用RSA做密钥协商时，是冗余的，因为此时 EncryptedPreMasterSecret 是 ClientKeyExchange 中的唯一字段，因此可以无歧义地得出 EncryptedPreMasterSecret 的长度。因此更早的 SSLv3 规范没有明确规定 public-key-encrypted 数据的编码格式，因此有一些SSLv3的实现没有包含 长度字段，这些实现直接把 RSA 加密的数据放入了 ClientKeyExchange消息里面。
TLS规范要求 EncryptedPreMasterSecret 字段包含长度字段。因此得出的结果会和一些 SSLv3 的实现不兼容。实现者从 SSLv3 升级到 TLS 时，必须修改自己的实现，以接受并且生成带长度的格式。如果一个实现要同时兼容 SSLv3 和 TLS，那就应该根据协议版本确定自己的行为。</p>

<p>注意：根据 Boneh 等在2003年USENIX Security Symposium上发表的论文 &ldquo;Remote timing attacks are practical"，针对 TLS RSA密钥交换的远程时间侧通道攻击，是<strong>实际可行的</strong>，起码当客户端和服务器在同一个LAN里时是可行的。因此，使用静态 RSA 密钥的实现，必须使用 RSA blinding，或者Boneh论文中提到的，其他抵抗时间侧通道攻击的技术。</p>

<p>openssl中的RSA blinding，参见：<a href="http://linux.die.net/man/3/rsa_blinding_on">http://linux.die.net/man/3/rsa_blinding_on</a></p>

<a name="L.2..............Diffie-Hellman......."></a>
<h4>(2).  客户端 Diffie-Hellman 公钥</h4>

<p>这条消息把客户端的 Diffie-Hellman 公钥 ( Yc ) 发送给服务器。</p>

<p>Yc的编码方式由 PublicValueEncoding 决定。</p>

<p>消息的结构：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
<span class='line-number'>244</span>
<span class='line-number'>245</span>
<span class='line-number'>246</span>
<span class='line-number'>247</span>
<span class='line-number'>248</span>
<span class='line-number'>249</span>
<span class='line-number'>250</span>
<span class='line-number'>251</span>
<span class='line-number'>252</span>
<span class='line-number'>253</span>
<span class='line-number'>254</span>
<span class='line-number'>255</span>
<span class='line-number'>256</span>
<span class='line-number'>257</span>
<span class='line-number'>258</span>
<span class='line-number'>259</span>
<span class='line-number'>260</span>
<span class='line-number'>261</span>
<span class='line-number'>262</span>
<span class='line-number'>263</span>
<span class='line-number'>264</span>
<span class='line-number'>265</span>
<span class='line-number'>266</span>
<span class='line-number'>267</span>
<span class='line-number'>268</span>
<span class='line-number'>269</span>
<span class='line-number'>270</span>
<span class='line-number'>271</span>
<span class='line-number'>272</span>
<span class='line-number'>273</span>
<span class='line-number'>274</span>
<span class='line-number'>275</span>
<span class='line-number'>276</span>
<span class='line-number'>277</span>
<span class='line-number'>278</span>
<span class='line-number'>279</span>
<span class='line-number'>280</span>
<span class='line-number'>281</span>
<span class='line-number'>282</span>
<span class='line-number'>283</span>
<span class='line-number'>284</span>
<span class='line-number'>285</span>
<span class='line-number'>286</span>
<span class='line-number'>287</span>
<span class='line-number'>288</span>
<span class='line-number'>289</span>
<span class='line-number'>290</span>
<span class='line-number'>291</span>
<span class='line-number'>292</span>
<span class='line-number'>293</span>
<span class='line-number'>294</span>
<span class='line-number'>295</span>
<span class='line-number'>296</span>
<span class='line-number'>297</span>
<span class='line-number'>298</span>
<span class='line-number'>299</span>
<span class='line-number'>300</span>
<span class='line-number'>301</span>
<span class='line-number'>302</span>
<span class='line-number'>303</span>
<span class='line-number'>304</span>
<span class='line-number'>305</span>
<span class='line-number'>306</span>
<span class='line-number'>307</span>
<span class='line-number'>308</span>
<span class='line-number'>309</span>
<span class='line-number'>310</span>
<span class='line-number'>311</span>
<span class='line-number'>312</span>
<span class='line-number'>313</span>
<span class='line-number'>314</span>
<span class='line-number'>315</span>
<span class='line-number'>316</span>
<span class='line-number'>317</span>
<span class='line-number'>318</span>
<span class='line-number'>319</span>
<span class='line-number'>320</span>
<span class='line-number'>321</span>
<span class='line-number'>322</span>
<span class='line-number'>323</span>
<span class='line-number'>324</span>
<span class='line-number'>325</span>
<span class='line-number'>326</span>
<span class='line-number'>327</span>
<span class='line-number'>328</span>
<span class='line-number'>329</span>
<span class='line-number'>330</span>
<span class='line-number'>331</span>
<span class='line-number'>332</span>
<span class='line-number'>333</span>
<span class='line-number'>334</span>
<span class='line-number'>335</span>
<span class='line-number'>336</span>
<span class='line-number'>337</span>
<span class='line-number'>338</span>
<span class='line-number'>339</span>
<span class='line-number'>340</span>
<span class='line-number'>341</span>
<span class='line-number'>342</span>
<span class='line-number'>343</span>
<span class='line-number'>344</span>
<span class='line-number'>345</span>
<span class='line-number'>346</span>
<span class='line-number'>347</span>
<span class='line-number'>348</span>
<span class='line-number'>349</span>
<span class='line-number'>350</span>
<span class='line-number'>351</span>
<span class='line-number'>352</span>
<span class='line-number'>353</span>
<span class='line-number'>354</span>
<span class='line-number'>355</span>
<span class='line-number'>356</span>
<span class='line-number'>357</span>
<span class='line-number'>358</span>
<span class='line-number'>359</span>
<span class='line-number'>360</span>
<span class='line-number'>361</span>
<span class='line-number'>362</span>
<span class='line-number'>363</span>
<span class='line-number'>364</span>
<span class='line-number'>365</span>
<span class='line-number'>366</span>
<span class='line-number'>367</span>
<span class='line-number'>368</span>
<span class='line-number'>369</span>
<span class='line-number'>370</span>
<span class='line-number'>371</span>
<span class='line-number'>372</span>
<span class='line-number'>373</span>
<span class='line-number'>374</span>
<span class='line-number'>375</span>
<span class='line-number'>376</span>
<span class='line-number'>377</span>
<span class='line-number'>378</span>
<span class='line-number'>379</span>
<span class='line-number'>380</span>
<span class='line-number'>381</span>
<span class='line-number'>382</span>
<span class='line-number'>383</span>
<span class='line-number'>384</span>
<span class='line-number'>385</span>
<span class='line-number'>386</span>
<span class='line-number'>387</span>
<span class='line-number'>388</span>
<span class='line-number'>389</span>
<span class='line-number'>390</span>
<span class='line-number'>391</span>
<span class='line-number'>392</span>
<span class='line-number'>393</span>
<span class='line-number'>394</span>
<span class='line-number'>395</span>
<span class='line-number'>396</span>
<span class='line-number'>397</span>
<span class='line-number'>398</span>
<span class='line-number'>399</span>
<span class='line-number'>400</span>
<span class='line-number'>401</span>
<span class='line-number'>402</span>
<span class='line-number'>403</span>
<span class='line-number'>404</span>
<span class='line-number'>405</span>
<span class='line-number'>406</span>
<span class='line-number'>407</span>
<span class='line-number'>408</span>
<span class='line-number'>409</span>
<span class='line-number'>410</span>
<span class='line-number'>411</span>
<span class='line-number'>412</span>
<span class='line-number'>413</span>
<span class='line-number'>414</span>
<span class='line-number'>415</span>
<span class='line-number'>416</span>
<span class='line-number'>417</span>
<span class='line-number'>418</span>
<span class='line-number'>419</span>
<span class='line-number'>420</span>
<span class='line-number'>421</span>
<span class='line-number'>422</span>
<span class='line-number'>423</span>
<span class='line-number'>424</span>
<span class='line-number'>425</span>
<span class='line-number'>426</span>
<span class='line-number'>427</span>
<span class='line-number'>428</span>
<span class='line-number'>429</span>
<span class='line-number'>430</span>
<span class='line-number'>431</span>
<span class='line-number'>432</span>
<span class='line-number'>433</span>
<span class='line-number'>434</span>
<span class='line-number'>435</span>
<span class='line-number'>436</span>
<span class='line-number'>437</span>
<span class='line-number'>438</span>
<span class='line-number'>439</span>
<span class='line-number'>440</span>
<span class='line-number'>441</span>
<span class='line-number'>442</span>
<span class='line-number'>443</span>
<span class='line-number'>444</span>
<span class='line-number'>445</span>
<span class='line-number'>446</span>
<span class='line-number'>447</span>
<span class='line-number'>448</span>
<span class='line-number'>449</span>
<span class='line-number'>450</span>
<span class='line-number'>451</span>
<span class='line-number'>452</span>
<span class='line-number'>453</span>
<span class='line-number'>454</span>
<span class='line-number'>455</span>
<span class='line-number'>456</span>
<span class='line-number'>457</span>
<span class='line-number'>458</span>
<span class='line-number'>459</span>
<span class='line-number'>460</span>
<span class='line-number'>461</span>
<span class='line-number'>462</span>
<span class='line-number'>463</span>
<span class='line-number'>464</span>
<span class='line-number'>465</span>
<span class='line-number'>466</span>
<span class='line-number'>467</span>
<span class='line-number'>468</span>
<span class='line-number'>469</span>
<span class='line-number'>470</span>
<span class='line-number'>471</span>
<span class='line-number'>472</span>
<span class='line-number'>473</span>
<span class='line-number'>474</span>
<span class='line-number'>475</span>
<span class='line-number'>476</span>
<span class='line-number'>477</span>
<span class='line-number'>478</span>
<span class='line-number'>479</span>
<span class='line-number'>480</span>
<span class='line-number'>481</span>
<span class='line-number'>482</span>
<span class='line-number'>483</span>
<span class='line-number'>484</span>
<span class='line-number'>485</span>
<span class='line-number'>486</span>
<span class='line-number'>487</span>
<span class='line-number'>488</span>
<span class='line-number'>489</span>
<span class='line-number'>490</span>
<span class='line-number'>491</span>
<span class='line-number'>492</span>
<span class='line-number'>493</span>
<span class='line-number'>494</span>
<span class='line-number'>495</span>
<span class='line-number'>496</span>
<span class='line-number'>497</span>
<span class='line-number'>498</span>
<span class='line-number'>499</span>
<span class='line-number'>500</span>
<span class='line-number'>501</span>
<span class='line-number'>502</span>
<span class='line-number'>503</span>
<span class='line-number'>504</span>
<span class='line-number'>505</span>
<span class='line-number'>506</span>
<span class='line-number'>507</span>
<span class='line-number'>508</span>
<span class='line-number'>509</span>
<span class='line-number'>510</span>
<span class='line-number'>511</span>
<span class='line-number'>512</span>
<span class='line-number'>513</span>
<span class='line-number'>514</span>
<span class='line-number'>515</span>
<span class='line-number'>516</span>
<span class='line-number'>517</span>
<span class='line-number'>518</span>
<span class='line-number'>519</span>
<span class='line-number'>520</span>
<span class='line-number'>521</span>
<span class='line-number'>522</span>
<span class='line-number'>523</span>
<span class='line-number'>524</span>
<span class='line-number'>525</span>
<span class='line-number'>526</span>
<span class='line-number'>527</span>
<span class='line-number'>528</span>
<span class='line-number'>529</span>
<span class='line-number'>530</span>
<span class='line-number'>531</span>
<span class='line-number'>532</span>
<span class='line-number'>533</span>
<span class='line-number'>534</span>
<span class='line-number'>535</span>
<span class='line-number'>536</span>
<span class='line-number'>537</span>
<span class='line-number'>538</span>
<span class='line-number'>539</span>
<span class='line-number'>540</span>
<span class='line-number'>541</span>
<span class='line-number'>542</span>
<span class='line-number'>543</span>
<span class='line-number'>544</span>
<span class='line-number'>545</span>
<span class='line-number'>546</span>
<span class='line-number'>547</span>
<span class='line-number'>548</span>
<span class='line-number'>549</span>
<span class='line-number'>550</span>
<span class='line-number'>551</span>
<span class='line-number'>552</span>
<span class='line-number'>553</span>
<span class='line-number'>554</span>
<span class='line-number'>555</span>
<span class='line-number'>556</span>
<span class='line-number'>557</span>
<span class='line-number'>558</span>
<span class='line-number'>559</span>
<span class='line-number'>560</span>
<span class='line-number'>561</span>
<span class='line-number'>562</span>
<span class='line-number'>563</span>
<span class='line-number'>564</span>
<span class='line-number'>565</span>
<span class='line-number'>566</span>
<span class='line-number'>567</span>
<span class='line-number'>568</span>
<span class='line-number'>569</span>
<span class='line-number'>570</span>
<span class='line-number'>571</span>
<span class='line-number'>572</span>
<span class='line-number'>573</span>
<span class='line-number'>574</span>
<span class='line-number'>575</span>
<span class='line-number'>576</span>
<span class='line-number'>577</span>
<span class='line-number'>578</span>
<span class='line-number'>579</span>
<span class='line-number'>580</span>
<span class='line-number'>581</span>
<span class='line-number'>582</span>
<span class='line-number'>583</span>
<span class='line-number'>584</span>
<span class='line-number'>585</span>
<span class='line-number'>586</span>
<span class='line-number'>587</span>
<span class='line-number'>588</span>
<span class='line-number'>589</span>
<span class='line-number'>590</span>
<span class='line-number'>591</span>
<span class='line-number'>592</span>
<span class='line-number'>593</span>
<span class='line-number'>594</span>
<span class='line-number'>595</span>
<span class='line-number'>596</span>
<span class='line-number'>597</span>
<span class='line-number'>598</span>
<span class='line-number'>599</span>
<span class='line-number'>600</span>
<span class='line-number'>601</span>
<span class='line-number'>602</span>
<span class='line-number'>603</span>
<span class='line-number'>604</span>
<span class='line-number'>605</span>
<span class='line-number'>606</span>
<span class='line-number'>607</span>
<span class='line-number'>608</span>
<span class='line-number'>609</span>
<span class='line-number'>610</span>
<span class='line-number'>611</span>
<span class='line-number'>612</span>
<span class='line-number'>613</span>
<span class='line-number'>614</span>
<span class='line-number'>615</span>
<span class='line-number'>616</span>
<span class='line-number'>617</span>
<span class='line-number'>618</span>
<span class='line-number'>619</span>
<span class='line-number'>620</span>
<span class='line-number'>621</span>
<span class='line-number'>622</span>
<span class='line-number'>623</span>
<span class='line-number'>624</span>
<span class='line-number'>625</span>
<span class='line-number'>626</span>
<span class='line-number'>627</span>
<span class='line-number'>628</span>
<span class='line-number'>629</span>
<span class='line-number'>630</span>
<span class='line-number'>631</span>
<span class='line-number'>632</span>
<span class='line-number'>633</span>
<span class='line-number'>634</span>
<span class='line-number'>635</span>
<span class='line-number'>636</span>
<span class='line-number'>637</span>
<span class='line-number'>638</span>
<span class='line-number'>639</span>
<span class='line-number'>640</span>
<span class='line-number'>641</span>
<span class='line-number'>642</span>
<span class='line-number'>643</span>
<span class='line-number'>644</span>
<span class='line-number'>645</span>
<span class='line-number'>646</span>
<span class='line-number'>647</span>
<span class='line-number'>648</span>
<span class='line-number'>649</span>
<span class='line-number'>650</span>
<span class='line-number'>651</span>
<span class='line-number'>652</span>
<span class='line-number'>653</span>
<span class='line-number'>654</span>
<span class='line-number'>655</span>
<span class='line-number'>656</span>
<span class='line-number'>657</span>
<span class='line-number'>658</span>
<span class='line-number'>659</span>
<span class='line-number'>660</span>
<span class='line-number'>661</span>
<span class='line-number'>662</span>
<span class='line-number'>663</span>
<span class='line-number'>664</span>
<span class='line-number'>665</span>
<span class='line-number'>666</span>
<span class='line-number'>667</span>
<span class='line-number'>668</span>
<span class='line-number'>669</span>
<span class='line-number'>670</span>
<span class='line-number'>671</span>
<span class='line-number'>672</span>
<span class='line-number'>673</span>
<span class='line-number'>674</span>
<span class='line-number'>675</span>
<span class='line-number'>676</span>
<span class='line-number'>677</span>
<span class='line-number'>678</span>
<span class='line-number'>679</span>
<span class='line-number'>680</span>
<span class='line-number'>681</span>
<span class='line-number'>682</span>
<span class='line-number'>683</span>
<span class='line-number'>684</span>
<span class='line-number'>685</span>
<span class='line-number'>686</span>
<span class='line-number'>687</span>
<span class='line-number'>688</span>
<span class='line-number'>689</span>
<span class='line-number'>690</span>
<span class='line-number'>691</span>
<span class='line-number'>692</span>
<span class='line-number'>693</span>
<span class='line-number'>694</span>
<span class='line-number'>695</span>
<span class='line-number'>696</span>
<span class='line-number'>697</span>
<span class='line-number'>698</span>
<span class='line-number'>699</span>
<span class='line-number'>700</span>
<span class='line-number'>701</span>
<span class='line-number'>702</span>
<span class='line-number'>703</span>
<span class='line-number'>704</span>
<span class='line-number'>705</span>
<span class='line-number'>706</span>
<span class='line-number'>707</span>
<span class='line-number'>708</span>
<span class='line-number'>709</span>
<span class='line-number'>710</span>
<span class='line-number'>711</span>
<span class='line-number'>712</span>
<span class='line-number'>713</span>
<span class='line-number'>714</span>
<span class='line-number'>715</span>
<span class='line-number'>716</span>
<span class='line-number'>717</span>
<span class='line-number'>718</span>
<span class='line-number'>719</span>
<span class='line-number'>720</span>
<span class='line-number'>721</span>
<span class='line-number'>722</span>
<span class='line-number'>723</span>
<span class='line-number'>724</span>
<span class='line-number'>725</span>
<span class='line-number'>726</span>
<span class='line-number'>727</span>
<span class='line-number'>728</span>
<span class='line-number'>729</span>
<span class='line-number'>730</span>
<span class='line-number'>731</span>
<span class='line-number'>732</span>
<span class='line-number'>733</span>
<span class='line-number'>734</span>
<span class='line-number'>735</span>
<span class='line-number'>736</span>
<span class='line-number'>737</span>
<span class='line-number'>738</span>
<span class='line-number'>739</span>
<span class='line-number'>740</span>
<span class='line-number'>741</span>
<span class='line-number'>742</span>
<span class='line-number'>743</span>
<span class='line-number'>744</span>
<span class='line-number'>745</span>
<span class='line-number'>746</span>
<span class='line-number'>747</span>
<span class='line-number'>748</span>
<span class='line-number'>749</span>
<span class='line-number'>750</span>
<span class='line-number'>751</span>
<span class='line-number'>752</span>
<span class='line-number'>753</span>
<span class='line-number'>754</span>
<span class='line-number'>755</span>
<span class='line-number'>756</span>
<span class='line-number'>757</span>
<span class='line-number'>758</span>
<span class='line-number'>759</span>
<span class='line-number'>760</span>
<span class='line-number'>761</span>
<span class='line-number'>762</span>
<span class='line-number'>763</span>
<span class='line-number'>764</span>
<span class='line-number'>765</span>
<span class='line-number'>766</span>
<span class='line-number'>767</span>
<span class='line-number'>768</span>
<span class='line-number'>769</span>
<span class='line-number'>770</span>
<span class='line-number'>771</span>
<span class='line-number'>772</span>
<span class='line-number'>773</span>
<span class='line-number'>774</span>
<span class='line-number'>775</span>
<span class='line-number'>776</span>
<span class='line-number'>777</span>
<span class='line-number'>778</span>
<span class='line-number'>779</span>
<span class='line-number'>780</span>
<span class='line-number'>781</span>
<span class='line-number'>782</span>
<span class='line-number'>783</span>
<span class='line-number'>784</span>
<span class='line-number'>785</span>
<span class='line-number'>786</span>
<span class='line-number'>787</span>
<span class='line-number'>788</span>
<span class='line-number'>789</span>
<span class='line-number'>790</span>
<span class='line-number'>791</span>
<span class='line-number'>792</span>
<span class='line-number'>793</span>
<span class='line-number'>794</span>
<span class='line-number'>795</span>
<span class='line-number'>796</span>
<span class='line-number'>797</span>
<span class='line-number'>798</span>
<span class='line-number'>799</span>
<span class='line-number'>800</span>
<span class='line-number'>801</span>
<span class='line-number'>802</span>
<span class='line-number'>803</span>
<span class='line-number'>804</span>
<span class='line-number'>805</span>
<span class='line-number'>806</span>
<span class='line-number'>807</span>
<span class='line-number'>808</span>
<span class='line-number'>809</span>
<span class='line-number'>810</span>
<span class='line-number'>811</span>
<span class='line-number'>812</span>
<span class='line-number'>813</span>
<span class='line-number'>814</span>
<span class='line-number'>815</span>
<span class='line-number'>816</span>
<span class='line-number'>817</span>
<span class='line-number'>818</span>
<span class='line-number'>819</span>
<span class='line-number'>820</span>
<span class='line-number'>821</span>
<span class='line-number'>822</span>
<span class='line-number'>823</span>
<span class='line-number'>824</span>
<span class='line-number'>825</span>
<span class='line-number'>826</span>
<span class='line-number'>827</span>
<span class='line-number'>828</span>
<span class='line-number'>829</span>
<span class='line-number'>830</span>
<span class='line-number'>831</span>
<span class='line-number'>832</span>
<span class='line-number'>833</span>
<span class='line-number'>834</span>
<span class='line-number'>835</span>
<span class='line-number'>836</span>
<span class='line-number'>837</span>
<span class='line-number'>838</span>
<span class='line-number'>839</span>
<span class='line-number'>840</span>
<span class='line-number'>841</span>
<span class='line-number'>842</span>
<span class='line-number'>843</span>
<span class='line-number'>844</span>
<span class='line-number'>845</span>
<span class='line-number'>846</span>
<span class='line-number'>847</span>
<span class='line-number'>848</span>
<span class='line-number'>849</span>
<span class='line-number'>850</span>
<span class='line-number'>851</span>
<span class='line-number'>852</span>
<span class='line-number'>853</span>
<span class='line-number'>854</span>
<span class='line-number'>855</span>
<span class='line-number'>856</span>
<span class='line-number'>857</span>
<span class='line-number'>858</span>
<span class='line-number'>859</span>
<span class='line-number'>860</span>
<span class='line-number'>861</span>
<span class='line-number'>862</span>
<span class='line-number'>863</span>
<span class='line-number'>864</span>
<span class='line-number'>865</span>
<span class='line-number'>866</span>
<span class='line-number'>867</span>
<span class='line-number'>868</span>
<span class='line-number'>869</span>
<span class='line-number'>870</span>
<span class='line-number'>871</span>
<span class='line-number'>872</span>
<span class='line-number'>873</span>
<span class='line-number'>874</span>
<span class='line-number'>875</span>
<span class='line-number'>876</span>
<span class='line-number'>877</span>
<span class='line-number'>878</span>
<span class='line-number'>879</span>
<span class='line-number'>880</span>
<span class='line-number'>881</span>
<span class='line-number'>882</span>
<span class='line-number'>883</span>
<span class='line-number'>884</span>
<span class='line-number'>885</span>
<span class='line-number'>886</span>
<span class='line-number'>887</span>
<span class='line-number'>888</span>
<span class='line-number'>889</span>
<span class='line-number'>890</span>
<span class='line-number'>891</span>
<span class='line-number'>892</span>
<span class='line-number'>893</span>
<span class='line-number'>894</span>
<span class='line-number'>895</span>
<span class='line-number'>896</span>
<span class='line-number'>897</span>
<span class='line-number'>898</span>
<span class='line-number'>899</span>
<span class='line-number'>900</span>
<span class='line-number'>901</span>
<span class='line-number'>902</span>
<span class='line-number'>903</span>
<span class='line-number'>904</span>
<span class='line-number'>905</span>
<span class='line-number'>906</span>
<span class='line-number'>907</span>
<span class='line-number'>908</span>
<span class='line-number'>909</span>
<span class='line-number'>910</span>
<span class='line-number'>911</span>
<span class='line-number'>912</span>
<span class='line-number'>913</span>
<span class='line-number'>914</span>
<span class='line-number'>915</span>
<span class='line-number'>916</span>
<span class='line-number'>917</span>
<span class='line-number'>918</span>
<span class='line-number'>919</span>
<span class='line-number'>920</span>
<span class='line-number'>921</span>
<span class='line-number'>922</span>
<span class='line-number'>923</span>
<span class='line-number'>924</span>
<span class='line-number'>925</span>
<span class='line-number'>926</span>
<span class='line-number'>927</span>
<span class='line-number'>928</span>
<span class='line-number'>929</span>
<span class='line-number'>930</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="k">enum</span> <span class="p">{</span> <span class="n">implicit</span><span class="p">,</span> <span class="n">explicit</span> <span class="p">}</span> <span class="n">PublicValueEncoding</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">implicit</span>
</span><span class='line'> <span class="err">如果客户端已经发送了一个包含合适的</span> <span class="n">DH</span> <span class="err">公钥的证书（即</span> <span class="n">fixed_dh</span> <span class="err">客户端认证方式），那么</span><span class="n">Yc</span><span class="err">已经隐式包含了，不需要再发送。这种情况下，</span><span class="n">ClientKeyExchange</span><span class="err">消息必须发送，并且必须是空的。</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">explicit</span>
</span><span class='line'> <span class="err">表示</span><span class="n">Yc</span><span class="err">需要发送。</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">select</span> <span class="p">(</span><span class="n">PublicValueEncoding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nl">implicit</span><span class="p">:</span> <span class="k">struct</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'>      <span class="k">case</span> <span class="nl">explicit</span><span class="p">:</span> <span class="n">opaque</span> <span class="n">dh_Yc</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">dh_public</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">ClientDiffieHellmanPublic</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">dh_Yc</span>
</span><span class='line'> <span class="err">客户端的</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">公钥</span> <span class="n">Yc</span><span class="p">.</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="cp">#### (3).  客户端 EC Diffie-Hellman 公钥</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">select</span> <span class="p">(</span><span class="n">PublicValueEncoding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">implicit</span><span class="p">:</span> <span class="k">struct</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'>        <span class="k">case</span> <span class="nl">explicit</span><span class="p">:</span> <span class="n">ECPoint</span> <span class="n">ecdh_Yc</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="n">ecdh_public</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">ClientECDiffieHellmanPublic</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">推广到椭圆曲线群上，就是</span> <span class="n">EC</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">，简称</span> <span class="n">ECDH</span><span class="err">，其它的计算，和一般的</span> <span class="n">DH</span> <span class="err">计算类似。</span>
</span><span class='line'>
</span><span class='line'><span class="o">**</span><span class="n">ECDH</span> <span class="err">是目前最重要的密钥协商算法</span><span class="o">**</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">### 11. handshake  -- Cerificate Verify</span>
</span><span class='line'>
</span><span class='line'><span class="err">当需要做客户端认证时，客户端发送</span><span class="n">CertificateVerify</span><span class="err">消息，来证明自己确实拥有客户端证书的私钥。这条消息仅仅在客户端证书有签名能力的情况下发送（就是说，除了含有固定</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">参数的证书以外的证书）。</span><span class="n">CertificateVerify</span><span class="err">必须紧跟在</span><span class="n">ClientKeyExchange</span><span class="err">之后发送。</span>
</span><span class='line'>
</span><span class='line'><span class="err">消息结构：</span>
</span><span class='line'>   <span class="n">Structure</span> <span class="n">of</span> <span class="n">this</span> <span class="nl">message</span><span class="p">:</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">digitally</span><span class="o">-</span><span class="kt">signed</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">opaque</span> <span class="n">handshake_messages</span><span class="p">[</span><span class="n">handshake_messages_length</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">CertificateVerify</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">此处，</span> <span class="n">handshake_messages</span> <span class="err">表示所有发送或者接收的握手消息，从</span><span class="n">client</span> <span class="n">hello</span><span class="err">开始，一直到</span><span class="n">CertificateVerify</span><span class="err">之前的所有消息，包括</span><span class="n">handshake</span><span class="err">消息的</span><span class="n">type</span><span class="err">和</span><span class="n">length</span><span class="err">字段，这是之前所有握手结构体的拼接。要注意，这要求双方在握手过程中，都得缓存所有消息，或者在握手过程中，用每一种可能的</span><span class="n">hash</span><span class="err">算法计算到</span><span class="n">CeritificateVerify</span><span class="err">为止的</span><span class="n">hash</span><span class="err">值。</span>
</span><span class='line'>
</span><span class='line'><span class="n">signature</span><span class="err">中用的</span><span class="n">hash</span><span class="err">和签名算法必须是</span> <span class="n">CertificateRequest</span> <span class="err">的</span> <span class="n">supported_signature_algorithms</span> <span class="err">中的某一种。另外，</span><span class="n">hash</span><span class="err">和签名算法必须和客户端的证书的算法兼容。</span>
</span><span class='line'><span class="n">RSA</span><span class="err">公钥可能被用于任何允许的</span><span class="n">hash</span><span class="err">函数，只要遵循证书中的限制。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">### 12. handshake  -- Finished</span>
</span><span class='line'>
</span><span class='line'><span class="err">在</span> <span class="n">ChangeCipherSpec</span> <span class="err">消息之后，应该立即发送</span> <span class="n">Finished</span> <span class="err">消息，来确认密钥交换和认证过程已经成功了。</span><span class="n">ChangeCipherSpec</span> <span class="err">必须在其它握手消息和</span> <span class="n">Finished</span> <span class="err">消息之间。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Finished</span> <span class="err">消息是第一条用刚刚协商出来的参数保护的消息。接收方必须确认</span><span class="n">Finished</span><span class="err">消息的内容是正确的。一旦某一方发送了，并且确认了对端发来的</span><span class="n">Finished</span><span class="err">消息，就可以开始在连接上发送和接收应用数据了。</span>
</span><span class='line'>
</span><span class='line'><span class="err">消息结构：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">verify_data</span><span class="p">[</span><span class="n">verify_data_length</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">Finished</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">verify_data</span>
</span><span class='line'> <span class="n">PRF</span><span class="p">(</span><span class="n">master_secret</span><span class="p">,</span> <span class="n">finished_label</span><span class="p">,</span><span class="n">Hash</span><span class="p">(</span><span class="n">handshake_messages</span><span class="p">))</span>
</span><span class='line'>    <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">verify_data_length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">finished_label</span>
</span><span class='line'> <span class="err">对客户端发的</span><span class="n">Finished</span><span class="err">消息来说，固定是字符串</span> <span class="s">&quot;client finished&quot;</span><span class="p">.</span>
</span><span class='line'> <span class="err">对服务器发的</span><span class="n">Finished</span><span class="err">消息来说，固定是字符串</span> <span class="s">&quot;server finished&quot;</span><span class="p">.</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">Hash</span><span class="err">表示握手消息的</span><span class="n">hash</span><span class="err">。</span><span class="n">hash</span><span class="err">函数是前文</span> <span class="n">PRF</span> <span class="err">的</span><span class="n">hash</span> <span class="err">函数。或者</span> <span class="n">CipherSuite</span> <span class="err">规定的用于</span> <span class="n">Finished</span> <span class="err">计算的</span><span class="n">hash</span><span class="err">函数。</span>
</span><span class='line'>
</span><span class='line'><span class="err">在</span><span class="n">TLS</span><span class="err">的之前版本中，</span><span class="n">verify_data</span> <span class="err">总是</span> <span class="mi">12</span> <span class="err">字节。在</span><span class="n">TLS</span> <span class="mf">1.2</span><span class="err">中，这取决于</span><span class="n">CipherSuite</span><span class="err">。如果</span><span class="n">CipherSuite</span><span class="err">没有显式规定</span> <span class="n">verify_data_length</span> <span class="err">，就当成</span><span class="mi">12</span><span class="err">字节处理。将来的</span><span class="n">CipherSuite</span><span class="err">可能会规定别的长度，但是不能小于</span><span class="mi">12</span><span class="err">字节。</span>
</span><span class='line'>
</span><span class='line'> <span class="n">Finished</span> <span class="err">消息必须跟在</span> <span class="n">ChangeCipherSpec</span> <span class="err">消息之后，如果顺序错乱，就是</span> <span class="n">fatal</span> <span class="n">error</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="n">handshake_message</span> <span class="err">的内容包含从</span> <span class="n">ClientHello</span><span class="err">开始，直到</span> <span class="err">本条</span><span class="n">Finished</span><span class="err">之前的所有消息，只包含</span><span class="n">handshake</span><span class="err">层的消息体，不包含</span><span class="n">record</span><span class="err">层的几个消息头字段。包括</span><span class="n">CertificateVerify</span> <span class="err">消息。同时，对客户端和服务器来说，</span><span class="n">handshake_message</span> <span class="err">的内容不同，</span> <span class="err">后发送者必须包含前发送者的</span> <span class="n">Finished</span> <span class="err">消息。</span>
</span><span class='line'>
</span><span class='line'> <span class="err">注意：</span><span class="n">ChangeCipherSpec</span> <span class="err">消息，</span><span class="n">alert</span><span class="err">，和其它的</span><span class="n">record</span> <span class="err">类型不是握手消息，不包含在</span> <span class="n">hash</span><span class="err">计算中。同时，</span><span class="n">HelloRequest</span> <span class="err">消息也不算在内。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###13. handshake -- NewSessionTicket</span>
</span><span class='line'><span class="n">SessionTicket</span> <span class="err">定义在</span> <span class="n">RFC5077</span> <span class="err">标准里面，</span><span class="mi">2008</span><span class="err">年发布。</span>
</span><span class='line'>
</span><span class='line'><span class="n">SessionTicket</span><span class="err">是一种不需要服务器端状态的，恢复</span><span class="n">TLS</span> <span class="n">session</span><span class="err">的方式。</span>
</span><span class='line'><span class="n">SessionTicket</span><span class="err">可以用于任何</span><span class="n">CipherSuite</span><span class="err">。</span> <span class="n">TLS</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">TLS</span> <span class="mf">1.1</span><span class="p">,</span> <span class="n">TLS</span> <span class="mf">1.2</span> <span class="err">都适用。</span>
</span><span class='line'>
</span><span class='line'><span class="err">在下面这些场景下，尤其有用：</span>
</span><span class='line'>
</span><span class='line'><span class="err">用户量巨大，</span><span class="n">session</span> <span class="n">id</span><span class="err">的方式耗费服务器内存过多</span>
</span><span class='line'><span class="err">服务器希望长时间缓存</span><span class="n">session</span>
</span><span class='line'><span class="err">服务器有多台，不希望服务器间有共享状态</span>
</span><span class='line'><span class="err">服务器内存不足</span>
</span><span class='line'><span class="err">客户端在</span> <span class="n">ClientHello</span><span class="err">中设置一个</span> <span class="n">SessionTicket</span> <span class="err">扩展来标识自己支持</span> <span class="n">SessionTicket</span><span class="err">。如果客户端本地没有存之前收到的</span><span class="n">ticket</span><span class="err">，就把这个扩展设为空。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果服务器希望使用</span> <span class="n">SessionTicket</span> <span class="err">机制，服务器把本地的</span> <span class="n">session</span> <span class="err">状态存入一个</span><span class="n">ticket</span><span class="err">中，</span><span class="n">ticket</span><span class="err">会被加密，并被</span><span class="n">MAC</span><span class="err">保护，无法篡改，加密和算</span><span class="n">MAC</span><span class="err">用的</span><span class="n">key</span><span class="err">只有服务器知道。</span>
</span><span class='line'><span class="err">加密并</span><span class="n">MAC</span><span class="err">过的</span><span class="n">ticket</span><span class="err">用</span> <span class="n">NewSessionTicket</span> <span class="err">消息分发给客户端，</span><span class="n">NewSessionTicket</span> <span class="err">消息应该在</span> <span class="n">ChangeCipherSpec</span> <span class="err">消息之前，在服务器验证通过客户端的</span><span class="n">Finished</span><span class="err">消息之后发送。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">Client</span>                                               <span class="n">Server</span>
</span><span class='line'>  <span class="n">ClientHello</span>
</span><span class='line'>  <span class="p">(</span><span class="n">empty</span> <span class="n">SessionTicket</span> <span class="n">extension</span><span class="p">)</span><span class="o">-------&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>                                              <span class="n">ServerHello</span>
</span><span class='line'>                          <span class="p">(</span><span class="n">empty</span> <span class="n">SessionTicket</span> <span class="n">extension</span><span class="p">)</span>
</span><span class='line'>                                             <span class="n">Certificate</span><span class="o">*</span>
</span><span class='line'>                                       <span class="n">ServerKeyExchange</span><span class="o">*</span>
</span><span class='line'>                                      <span class="n">CertificateRequest</span><span class="o">*</span>
</span><span class='line'>                           <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">--------</span>      <span class="n">ServerHelloDone</span>
</span><span class='line'>  <span class="n">Certificate</span><span class="o">*</span>
</span><span class='line'>  <span class="n">ClientKeyExchange</span>
</span><span class='line'>  <span class="n">CertificateVerify</span><span class="o">*</span>
</span><span class='line'>  <span class="p">[</span><span class="n">ChangeCipherSpec</span><span class="p">]</span>
</span><span class='line'>  <span class="n">Finished</span>                     <span class="o">--------&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>                                         <span class="n">NewSessionTicket</span>
</span><span class='line'>                                       <span class="p">[</span><span class="n">ChangeCipherSpec</span><span class="p">]</span>
</span><span class='line'>                           <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">--------</span>             <span class="n">Finished</span>
</span><span class='line'>  <span class="n">Application</span> <span class="n">Data</span>             <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-------&amp;</span><span class="n">gt</span><span class="p">;</span>     <span class="n">Application</span> <span class="n">Data</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>   <span class="n">Figure</span> <span class="mi">1</span><span class="o">:</span> <span class="n">Message</span> <span class="n">flow</span> <span class="k">for</span> <span class="n">full</span> <span class="n">handshake</span> <span class="n">issuing</span> <span class="n">new</span> <span class="n">session</span> <span class="n">ticket</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">客户端把收到的</span><span class="n">ticket</span><span class="err">和</span><span class="n">master</span> <span class="n">secret</span><span class="err">等其它与当前</span><span class="n">session</span><span class="err">有关的参数一起，缓存起来。</span>
</span><span class='line'><span class="err">单客户端希望恢复会话时，就把</span><span class="n">ticket</span><span class="err">包含在</span> <span class="n">ClientHello</span> <span class="err">的</span> <span class="n">SessionTicket</span> <span class="err">扩展中发给服务器。</span>
</span><span class='line'><span class="err">服务器收到后，解密</span><span class="n">ticket</span><span class="err">，算</span><span class="n">MAC</span><span class="err">确认</span><span class="n">ticket</span><span class="err">没有被篡改过，然后从解密的内容里面，获取</span><span class="n">session</span> <span class="err">状态，用来恢复会话。如果服务器成功地验证了</span><span class="n">ticket</span><span class="err">，可以在</span> <span class="n">ServerHello</span> <span class="err">之后返回一个</span> <span class="n">NewSessionTicket</span> <span class="err">消息来更新</span><span class="n">ticket</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">显然，这种情况下，相比完整握手，可以省掉</span><span class="mi">1</span><span class="err">个</span><span class="n">RTT</span><span class="err">。如下图：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="n">Client</span>                                                <span class="n">Server</span>
</span><span class='line'>  <span class="n">ClientHello</span>
</span><span class='line'>  <span class="p">(</span><span class="n">SessionTicket</span> <span class="n">extension</span><span class="p">)</span>      <span class="o">--------&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>                                               <span class="n">ServerHello</span>
</span><span class='line'>                           <span class="p">(</span><span class="n">empty</span> <span class="n">SessionTicket</span> <span class="n">extension</span><span class="p">)</span>
</span><span class='line'>                                          <span class="n">NewSessionTicket</span>
</span><span class='line'>                                        <span class="p">[</span><span class="n">ChangeCipherSpec</span><span class="p">]</span>
</span><span class='line'>                            <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">--------</span>             <span class="n">Finished</span>
</span><span class='line'>  <span class="p">[</span><span class="n">ChangeCipherSpec</span><span class="p">]</span>
</span><span class='line'>  <span class="n">Finished</span>                      <span class="o">--------&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Application</span> <span class="n">Data</span>              <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">-------&amp;</span><span class="n">gt</span><span class="p">;</span>     <span class="n">Application</span> <span class="n">Data</span>
</span><span class='line'><span class="n">Figure</span> <span class="mi">2</span><span class="o">:</span> <span class="n">Message</span> <span class="n">flow</span> <span class="k">for</span> <span class="n">abbreviated</span> <span class="n">handshake</span> <span class="n">using</span> <span class="n">new</span>
</span><span class='line'>                      <span class="n">session</span> <span class="n">ticket</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">如果服务器不能，或者不想使用客户端发来的</span><span class="n">ticket</span><span class="err">，那服务器可以忽略</span><span class="n">ticket</span><span class="err">，启动一个完整的握手流程。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果服务器此时不希望下发新的</span><span class="n">ticket</span><span class="err">，那就可以不回复</span> <span class="n">SessionTicket</span> <span class="err">扩展，或者不回复</span> <span class="n">NewSessionTicket</span> <span class="err">消息。</span>
</span><span class='line'><span class="err">此时除了</span> <span class="n">ClientHello</span><span class="err">里面的</span> <span class="n">SessionTicket</span><span class="err">扩展，就和一般的</span><span class="n">TLS</span><span class="err">流程一样了。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果服务器拒绝收到的</span><span class="n">ticket</span><span class="err">，服务器可能仍然希望在完整的握手之后，下发新的</span><span class="n">ticket</span><span class="err">。</span>
</span><span class='line'><span class="err">此时流程和全新</span> <span class="n">ticket</span> <span class="err">生成下发的区别，就是</span><span class="n">ClientHello</span><span class="err">的</span><span class="n">SessionTicket</span><span class="err">不是空的。</span>
</span><span class='line'>
</span><span class='line'><span class="n">NewSessionTicket</span> <span class="err">消息</span>
</span><span class='line'><span class="err">服务器在握手过程中，发</span><span class="n">ChangeCipherSpec</span><span class="err">之前发送</span><span class="n">NewSessionTicket</span><span class="err">消息。</span>
</span><span class='line'><span class="err">如果服务器在</span><span class="n">ServerHello</span><span class="err">中包含了一个</span><span class="n">SessionTicket</span><span class="err">扩展，那就必须发送</span><span class="n">NewSessionTicket</span><span class="err">消息。</span>
</span><span class='line'><span class="err">如果服务器没有包含</span><span class="n">SessionTicket</span><span class="err">扩展，那绝对不能发送</span><span class="n">NewSessionTicket</span><span class="err">消息。</span>
</span><span class='line'><span class="err">如果服务器在包含了</span><span class="n">SessionTicket</span><span class="err">扩展之后，不想发送</span><span class="n">ticket</span><span class="err">，那可以发送一个长度为</span><span class="mi">0</span><span class="err">的</span><span class="n">NewSessionTicket</span><span class="err">消息。</span>
</span><span class='line'>
</span><span class='line'><span class="err">在完整握手的情况下，客户端必须在确认服务器的</span><span class="n">Finished</span><span class="err">消息正确之后，才能认为</span><span class="n">NewSessionTicket</span> <span class="err">里面的</span><span class="n">ticket</span><span class="err">合法。</span>
</span><span class='line'>
</span><span class='line'><span class="err">服务器可以</span><span class="n">NewSessionTicket</span><span class="err">消息中更新</span> <span class="n">ticket</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="n">ticket_lifetime_hint</span> <span class="err">字段包含一个服务器的提示，提示客户端本</span><span class="n">ticket</span><span class="err">应该存多长时间就失效。单位是秒，网络字节序。当时间到期时，客户端应该删掉</span><span class="n">ticket</span><span class="err">和关联的状态。客户端也可以提前删除。服务器端也可以提前认为</span><span class="n">ticket</span><span class="err">失效。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint32</span> <span class="n">ticket_lifetime_hint</span><span class="p">;</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">ticket</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">0..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">NewSessionTicket</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">SessionTicket</span> <span class="err">和</span> <span class="n">Session</span> <span class="n">ID</span> <span class="err">之间的关系比较繁琐。感兴趣的自行去看</span><span class="n">RFC</span><span class="err">吧。</span>
</span><span class='line'>
</span><span class='line'><span class="err">对于客户端来说，</span><span class="n">ticket</span><span class="err">就是一块二进制</span><span class="n">buffer</span><span class="err">，客户端并不管里面的内容。所以</span><span class="n">ticket</span><span class="err">具体怎么加密加</span><span class="n">MAC</span><span class="err">服务器可以为所欲为，无需顾及客户端的感受。</span>
</span><span class='line'>
</span><span class='line'><span class="n">RFC5077</span><span class="err">中推荐了一种</span><span class="n">ticket</span><span class="err">的加密保护方法：</span>
</span><span class='line'><span class="err">服务器使用</span><span class="mi">2</span><span class="err">个</span><span class="n">key</span><span class="err">，一个</span> <span class="n">aes</span><span class="o">-</span><span class="mi">128</span><span class="o">-</span><span class="n">cbc</span><span class="err">的</span><span class="n">key</span><span class="err">，一个</span> <span class="n">HMAC</span><span class="o">-</span><span class="n">SHA</span><span class="o">-</span><span class="mi">256</span> <span class="err">的</span><span class="n">key</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="n">ticket</span><span class="err">的格式像这样：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">key_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">iv</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">encrypted_state</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">0..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">mac</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">ticket</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">其中，</span><span class="n">key_name</span> <span class="err">用来标识一组</span><span class="n">key</span><span class="err">，这样服务器端就可以使用多组</span><span class="n">key</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">加密过程，首先随机生成</span><span class="n">IV</span><span class="err">，然后用</span> <span class="n">aes</span><span class="o">-</span><span class="mi">128</span><span class="o">-</span><span class="n">cbc</span> <span class="err">加密</span> <span class="n">session</span> <span class="err">的序列化结果，</span>
</span><span class='line'><span class="err">然后用</span> <span class="n">HMAC</span><span class="o">-</span><span class="n">SHA</span><span class="o">-</span><span class="mi">256</span> <span class="err">对</span> <span class="n">key_name</span><span class="p">,</span><span class="n">IV</span><span class="p">,</span><span class="n">encrypted_data</span> <span class="err">的长度（</span><span class="mi">2</span><span class="err">字节），</span><span class="n">encrypted_data</span> <span class="err">计算</span><span class="n">MAC</span><span class="err">。</span>
</span><span class='line'><span class="err">最好把各个字段填入上面</span><span class="n">ticket</span><span class="err">结构体。</span>
</span><span class='line'><span class="err">显然，此处是</span> <span class="n">Encrypt</span><span class="o">-</span><span class="n">then</span><span class="o">-</span><span class="n">MAC</span><span class="err">的方式，是最安全的。</span>
</span><span class='line'>
</span><span class='line'><span class="err">实际在</span><span class="n">openssl</span> <span class="err">中的</span><span class="n">session</span><span class="err">，用</span><span class="n">asn1</span><span class="err">格式序列化保存了下面这些字段：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span> <span class="k">typedef</span> <span class="k">struct</span> <span class="n">ssl_session_asn1_st</span> <span class="p">{</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">ssl_version</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">cipher</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">master_key</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">session_id</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">session_id_context</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">time</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">timeout</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">verify_result</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">tlsext_hostname</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_INTEGER</span> <span class="n">tlsext_tick_lifetime</span><span class="p">;</span>
</span><span class='line'> <span class="n">ASN1_OCTET_STRING</span> <span class="n">tlsext_tick</span><span class="p">;</span>
</span><span class='line'> <span class="p">}</span> <span class="n">SSL_SESSION_ASN1</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##6. ChangeCipherSpec 协议</span>
</span><span class='line'><span class="n">ChangeCipherSpec</span><span class="err">用来通知对端，开始启用协商好的</span><span class="n">Connection</span> <span class="n">State</span><span class="err">做对称加密，内容只有</span><span class="mi">1</span><span class="err">个字节。</span>
</span><span class='line'><span class="err">这个协议是冗余的，在</span><span class="n">TLS</span> <span class="mf">1.3</span><span class="err">里面直接被删除了。</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">changeCipherSpec</span><span class="err">协议抓包：</span>
</span><span class='line'>  <span class="o">!</span><span class="p">[][</span><span class="n">changeCipherSpec</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="cp">##7. Alert 协议</span>
</span><span class='line'><span class="err">一种返回码机制，简单</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">enum</span> <span class="p">{</span> <span class="n">warning</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">fatal</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="p">}</span> <span class="n">AlertLevel</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">AlertLevel</span> <span class="n">level</span><span class="p">;</span>
</span><span class='line'>      <span class="n">AlertDescription</span> <span class="n">description</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">Alert</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="err">其中</span><span class="n">level</span><span class="err">是等级，不同等级要求不同的处理。</span>
</span><span class='line'>
</span><span class='line'><span class="err">其中有一种：</span><span class="n">close_notify</span><span class="err">，用来通知对端，我不会再发送更多数据了。这个可以让对端主动</span><span class="n">close</span> <span class="n">fd</span><span class="err">，这样可以减少我方</span><span class="n">tcp</span> <span class="n">timewait</span><span class="err">状态的</span><span class="n">socket</span> <span class="err">量。</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">alert</span><span class="err">协议：</span>
</span><span class='line'>  <span class="o">!</span><span class="p">[][</span><span class="n">alert</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="cp">##8. application data协议</span>
</span><span class='line'>
</span><span class='line'><span class="n">application</span> <span class="n">data</span><span class="err">协议，就是把应用数据直接输入</span><span class="n">record</span><span class="err">层，做分段，算</span><span class="n">MAC</span><span class="err">，加密，传输。</span>
</span><span class='line'>   <span class="err">抓包举例如下：</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">!</span><span class="p">[][</span><span class="n">appProto</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##8. TLS协议的安全分析  </span>
</span><span class='line'><span class="err">安全分析，重中之重，也是大家最关心的。</span>
</span><span class='line'>
</span><span class='line'><span class="err">安全分析的第一步是建立攻击模型，</span><span class="n">TLS</span><span class="err">的攻击模式是：</span>
</span><span class='line'><span class="o">*</span>  <span class="err">攻击者有充足的计算资源</span>
</span><span class='line'><span class="o">*</span>  <span class="err">攻击者无法得到私钥，无法得到客户端和服务器内存里面的密钥等保密信息</span>
</span><span class='line'><span class="o">*</span>  <span class="err">攻击者可以抓包，修改包，删除包，重放包，篡改包。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这个模型其实就是密码学里面一般假定的攻击模型。</span>
</span><span class='line'>
</span><span class='line'><span class="err">好了，在这个模型下，</span><span class="n">TLS</span><span class="err">的安全性分析如下：</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###1. 认证和密钥交换 的安全性</span>
</span><span class='line'><span class="n">TLS</span><span class="err">有三种认证模式：双方认证，服务器认证，无认证。</span>
</span><span class='line'><span class="err">只要包含了有服务器端认证，就可以免疫</span> <span class="n">man</span><span class="o">-</span><span class="n">in</span><span class="o">-</span><span class="n">the</span><span class="o">-</span><span class="n">middle</span> <span class="err">攻击。但是完全匿名的会话是可以被</span> <span class="n">MITM</span> <span class="err">攻击的。匿名的服务器不能认证客户端。</span>
</span><span class='line'>
</span><span class='line'><span class="err">密钥交换的目的，是产生一个只有通信双方知道的共享密钥</span> <span class="n">pre_master_secret</span> <span class="err">。</span><span class="n">pre_master_secret</span> <span class="err">用来生成</span> <span class="n">master_secret</span> <span class="err">。</span> <span class="n">master_secret</span> <span class="err">用来生成</span> <span class="n">Finished</span> <span class="err">消息，加密</span><span class="n">key</span><span class="err">，和</span><span class="n">MAC</span> <span class="n">key</span><span class="err">。通过发送正确的</span><span class="n">Finished</span><span class="err">消息，双方可以证明自己知道正确的</span> <span class="n">pre_master_key</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####1. 匿名密钥交换</span>
</span><span class='line'>
</span><span class='line'><span class="err">匿名密钥交换是一种历史遗留的不安全方式。</span> <span class="err">匿名密钥交换缺失认证</span><span class="p">(</span><span class="n">Authentication</span><span class="p">)</span><span class="err">，所以绝大多数场景下，我们应该禁用这种方式。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####2. RSA 密钥交换和认证</span>
</span><span class='line'>
</span><span class='line'><span class="err">当使用</span><span class="n">RSA</span><span class="err">的时候，合并了密钥交换</span> <span class="err">和</span> <span class="err">服务器端认证。</span>
</span><span class='line'><span class="n">RSA</span><span class="err">公钥包含在服务器证书中。要注意的是，一旦服务器证书的</span><span class="n">RSA</span><span class="err">私钥泄露，之前用该证书保护的所有流量都会变成可以破解的，即没有前向安全性</span><span class="p">(</span><span class="n">Perfect</span> <span class="n">Forward</span> <span class="n">Secrecy</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'><span class="err">需要前向安全性的</span><span class="n">TLS</span><span class="err">用户，应该使用</span> <span class="n">DHE</span> <span class="err">或者</span> <span class="n">EC</span>
</span><span class='line'>   <span class="n">TLS</span> <span class="n">users</span> <span class="n">desiring</span> <span class="n">Perfect</span> <span class="n">Forward</span> <span class="n">Secrecy</span> <span class="n">should</span> <span class="n">use</span> <span class="n">DHE</span> <span class="err">类的</span><span class="n">CcipherSuite</span><span class="err">。这样，如果私钥泄露，只需要更换私钥和证书就行，不会有更大的损失。</span>
</span><span class='line'>
</span><span class='line'><span class="n">RSA</span><span class="err">密钥交换和认证的安全性基于，在验证了服务器的证书之后，客户端用服务器的公钥加密一个</span> <span class="n">pre_master_secret</span> <span class="err">。成功地解密</span> <span class="n">pre_master_secret</span> <span class="err">并产生正确地</span> <span class="n">Finished</span> <span class="err">消息之后，就可以确信服务器拥有证书对应的私钥。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果使用了客户端认证，通过</span> <span class="n">CertificateVerify</span> <span class="err">消息来认证客户端。客户端会签署一个之前所有握手消息的</span><span class="n">hash</span><span class="err">值，这些握手消息包括</span> <span class="err">服务器的证书，</span><span class="n">ServerHello</span><span class="p">.</span><span class="n">random</span> <span class="err">。其中服务器证书确保客户端签署了和本服务器有关的绑定</span><span class="p">(</span><span class="err">即不能重放和别的服务器的握手</span><span class="p">)</span><span class="err">，</span><span class="n">ServerHello</span><span class="p">.</span><span class="n">random</span> <span class="err">确保签名和当前握手流程绑定</span><span class="p">(</span><span class="err">即不能重放</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####3. Diffie-Hellman 密钥交换和认证</span>
</span><span class='line'>
</span><span class='line'><span class="err">当使用</span> <span class="n">DH</span> <span class="err">密钥交换的时候，服务器</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="err">或者发送包含固定</span> <span class="n">DH</span><span class="err">参数的证书</span>
</span><span class='line'><span class="mf">1.</span>  <span class="err">或者发送一组临时</span><span class="n">DH</span><span class="err">参数，并用</span> <span class="n">ECDSA</span><span class="o">/</span><span class="n">RSA</span><span class="o">/</span><span class="n">DSA</span> <span class="err">证书的私钥签署。而且在签署之前，临时</span><span class="n">DH</span><span class="err">参数和</span> <span class="n">hello</span><span class="p">.</span><span class="n">random</span> <span class="err">都参与</span><span class="n">hash</span><span class="err">计算，来确保攻击者不能重放老的签名值。</span>
</span><span class='line'>
</span><span class='line'><span class="err">无论如何，客户端都可以通过验证证书，或者验证签名，来确保收到的</span><span class="n">DH</span><span class="err">参数确实来自真正的服务器。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果客户端有一个包含固定</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">参数的证书，则证书包含完成密钥交换所需的参数。要注意的是，这种情况下，客户端和服务器每次都会协商出相同的</span> <span class="n">DH</span> <span class="err">结果</span><span class="p">(</span><span class="err">就是</span> <span class="n">pre_master_secret</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'><span class="err">为了尽可能减少</span> <span class="n">pre_master_secret</span> <span class="err">存在在内存里面的时间，当不再需要的时候，尽快将其清除，</span><span class="n">pre_master_secret</span> <span class="err">应该尽早转换成</span> <span class="n">master_secret</span> <span class="err">的形式。</span>
</span><span class='line'><span class="err">为了进行密钥交换，客户端发送的</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">参数必须和服务器发送的兼容。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果客户端有一个标准的</span> <span class="n">DSA</span> <span class="err">或者</span> <span class="n">RSA</span> <span class="err">证书，或者</span> <span class="err">客户端没有被认证，那么客户端在</span><span class="n">ClientKeyExchange</span><span class="err">中发送一组临时参数，或者可选地发送一个</span><span class="n">CertificateVerify</span><span class="err">消息来证明自己的身份。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果相同的</span> <span class="n">DH</span> <span class="err">密钥对，被多次用于握手协商，不管是由于客户端或服务器使用了固定</span><span class="n">DH</span><span class="err">密钥的证书，还是服务器在重用</span> <span class="n">DH</span> <span class="err">密钥，都必须小心避免</span> <span class="n">small</span> <span class="n">subgroup</span> <span class="err">攻击。实现都必须遵循</span> <span class="n">rfc2785</span> <span class="err">中的标准。</span>
</span><span class='line'>
</span><span class='line'><span class="err">最简单避免</span> <span class="n">small</span> <span class="n">subgroup</span> <span class="err">攻击的方法是使用一种</span> <span class="n">DHE</span> <span class="n">CipherSuite</span><span class="err">，并且每次都握手都生成一个新的</span> <span class="n">DH</span> <span class="err">私钥</span> <span class="n">X</span><span class="err">。如果选择了一个合适的</span><span class="n">base</span><span class="err">（例如</span><span class="mi">2</span><span class="err">），</span><span class="n">g</span><span class="o">^</span><span class="n">X</span> <span class="n">mod</span> <span class="n">p</span> <span class="err">的计算可以非常快，因而性能开销会最小化。并且每次都使用一个新的</span><span class="n">DH</span><span class="err">密钥，可以提供前向安全性。当使用</span>  <span class="n">DHE</span> <span class="err">类的</span><span class="n">CipherSuite</span><span class="err">时，实现必须每次握手都生成一个全新的</span><span class="n">DH</span><span class="err">私钥（即</span> <span class="n">X</span> <span class="err">）。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">由于</span><span class="n">TLS</span><span class="err">允许服务器提供任意的</span> <span class="n">DH</span> <span class="err">群，客户端必须确认服务器提供的</span><span class="n">DH</span> <span class="err">群的大小适合本地策略。</span>
</span><span class='line'><span class="err">客户端必须确认</span> <span class="n">DH</span> <span class="err">公共指数有足够的大小。</span>
</span><span class='line'><span class="err">如果</span><span class="n">DH</span><span class="err">群已知的话，客户端做简单比对就行了，因此服务器可以使用一个已知的群，来方便客户端的检查。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###2. 版本回退攻击</span>
</span><span class='line'>
</span><span class='line'><span class="err">由于</span> <span class="n">TLS</span> <span class="err">历史上出现过多个版本，服务器端实现可能会兼容多个版本的协议，而像</span> <span class="n">SSL</span> <span class="mf">2.0</span> <span class="err">这样的版本是有严重安全问题的，因此攻击者可能会尝试诱骗客户端和服务器，来使</span><span class="n">TLS</span><span class="err">连接回退到</span> <span class="n">SSL</span> <span class="mf">2.0</span><span class="err">这种老版本。</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="err">对此的解决办法，就是</span><span class="n">PreMasterSecret</span><span class="err">里面包含版本号。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###3. 针对握手过程的攻击</span>
</span><span class='line'><span class="err">攻击者可能会尝试影响握手过程，来使双方选择不安全的加密算法。</span>
</span><span class='line'>
</span><span class='line'><span class="err">对这种攻击的解决办法是，如果握手消息被篡改了，那么在</span><span class="n">Finished</span><span class="err">消息里，客户端和服务器都会计算</span> <span class="err">握手消息的</span><span class="n">hash</span><span class="err">，如果攻击者篡改了握手消息，那么双方得出的</span><span class="n">hash</span><span class="err">就不一样，这样</span><span class="n">Finished</span><span class="err">消息就会验证不过。就会发现攻击。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###4. 针对 Resuming Sessions 的攻击</span>
</span><span class='line'>
</span><span class='line'><span class="err">当使用</span> <span class="n">session</span> <span class="n">resuming</span><span class="err">的时候，会产生新的</span> <span class="n">ClientHello</span><span class="p">.</span><span class="n">random</span> <span class="err">和</span> <span class="n">ServerHello</span><span class="p">.</span><span class="n">random</span> <span class="err">，并和</span><span class="n">session</span><span class="err">的</span> <span class="n">master_secret</span> <span class="err">一同被</span><span class="n">hash</span><span class="err">。只要</span><span class="n">master_secret</span><span class="err">没有泄漏，并且</span><span class="n">PRF</span><span class="err">中用来生成加密</span><span class="n">key</span><span class="err">和</span><span class="n">MAC</span> <span class="n">key</span><span class="err">的</span><span class="n">hash</span><span class="err">算法是安全的，连接就是安全的，并且独立于前一个连接</span><span class="p">(</span><span class="err">被恢复的前一个连接</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">只有在客户端和服务器都同意的情况下，才会做</span><span class="n">session</span> <span class="n">resuming</span><span class="err">。只要有任意一方怀疑</span> <span class="n">session</span> <span class="err">泄漏，或者证书过期</span><span class="o">/</span><span class="err">被吊销，就可以要求对端做完整的握手。</span>
</span><span class='line'><span class="err">一个</span><span class="n">session</span><span class="err">的生命周期建议定位</span><span class="mi">24</span><span class="err">小时。由于如果攻击者获得了</span> <span class="n">master_secret</span> <span class="err">就可以在</span><span class="n">session</span> <span class="n">ID</span><span class="err">过期之前伪装成被泄漏者，所以要加一个生命期限制。</span>
</span><span class='line'><span class="err">运行在不安全环境的应用程序，不应该把</span><span class="n">session</span> <span class="n">ID</span><span class="err">写入持久存储。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###5. 针对应用数据保护的攻击</span>
</span><span class='line'>
</span><span class='line'><span class="n">master_secret</span> <span class="err">和</span> <span class="n">ClientHello</span><span class="p">.</span><span class="n">random</span> <span class="err">及</span>   <span class="n">ServerHello</span><span class="p">.</span><span class="n">random</span> <span class="err">一起做</span> <span class="n">hash</span><span class="err">，来生成每个连接唯一的加密</span><span class="n">key</span><span class="err">和</span><span class="n">MAC</span> <span class="n">key</span><span class="err">（就算是</span><span class="n">session</span> <span class="n">resuming</span><span class="err">得到的连接，也是不同的）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">在</span><span class="n">CBC</span><span class="err">和</span><span class="n">stream</span> <span class="n">cipher</span><span class="err">的情况下，</span>
</span><span class='line'><span class="err">发送出去的数据，在发送前用</span><span class="n">MAC</span><span class="err">保护，来避免消息重放，避免篡改。</span>
</span><span class='line'><span class="n">MAC</span><span class="err">根据</span> <span class="n">MAC</span> <span class="n">key</span><span class="err">，序列号，消息长度，消息内容，固定字符串算出。</span>
</span><span class='line'><span class="err">消息类型字段（</span><span class="n">content</span> <span class="n">type</span><span class="err">）是必须的，来确保握手消息，</span><span class="n">ChangeCipherSpec</span><span class="err">消息，应用数据消息不会被混淆。</span>
</span><span class='line'><span class="err">序列号用来确保删除包或者打乱包顺序的攻击无法得逞。</span>
</span><span class='line'><span class="err">由于序列号是</span><span class="mi">64</span><span class="err">位的，可以认为不会回绕。</span>
</span><span class='line'><span class="err">从一方发给对端的消息，不能被插入对端发来的字节流中，这是用于两端使用不同的</span> <span class="n">MAC</span> <span class="n">key</span><span class="err">。</span>
</span><span class='line'><span class="err">类似地，</span><span class="n">server</span> <span class="n">write</span> <span class="n">key</span> <span class="err">和</span> <span class="n">client</span> <span class="n">write</span> <span class="n">key</span><span class="err">相互独立。因此</span><span class="n">stream</span> <span class="n">cipher</span><span class="err">的</span><span class="n">key</span><span class="err">只使用了一次，避免了类似问题。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果攻击者获取了加密</span><span class="n">key</span><span class="err">，那么就可以解密所有的消息。</span>
</span><span class='line'><span class="err">类似地，泄漏</span><span class="n">MAC</span> <span class="n">key</span><span class="err">，会使攻击者可以篡改消息。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">AEAD</span><span class="err">就简单了。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###6. 显式 IV的安全性</span>
</span><span class='line'>
</span><span class='line'><span class="err">如前文所述，</span><span class="n">TLS</span> <span class="mf">1.0</span><span class="err">是把前一条消息的最后一个</span><span class="n">block</span><span class="err">，当作下一条消息的第一个</span><span class="n">IV</span><span class="err">的，这促成了</span><span class="mi">2004</span><span class="err">年公开的</span> <span class="n">BEAST</span> <span class="err">攻击，后来就改成这种显式</span><span class="n">IV</span><span class="err">的更安全的方式了。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###7. 加密和MAC组合模式的安全性 </span>
</span><span class='line'>
</span><span class='line'><span class="err">前文介绍</span><span class="n">CBC</span><span class="err">和</span><span class="n">AEAD</span><span class="err">时已有分析，此处略过。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###8. DOS 攻击下的安全性</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span><span class="err">容易遭受某些</span> <span class="n">DoS</span> <span class="err">攻击。例如，攻击者创建很多</span><span class="n">TCP</span><span class="err">连接，就可以让服务器忙于做</span> <span class="n">RSA</span> <span class="err">解密计算。然而，由于</span><span class="n">TLS</span><span class="err">运行在</span><span class="n">TCP</span><span class="err">之上，只要操作系统</span><span class="n">TCP</span><span class="err">栈的</span> <span class="n">SYN</span><span class="o">-</span><span class="n">ACK</span><span class="err">里</span><span class="n">seqnum</span><span class="err">是随机的，攻击者就无法隐藏自己的</span><span class="n">ip</span><span class="err">，这样就可以和一般的</span><span class="n">TCP</span><span class="err">连接一样做</span><span class="n">DOS</span><span class="err">防御。</span>
</span><span class='line'>
</span><span class='line'><span class="err">由于</span><span class="n">TLS</span><span class="err">运行在</span><span class="n">TCP</span><span class="err">上，每个独立的连接都可能遭受一系列</span><span class="n">DOS</span><span class="err">攻击。尤其是，攻击者可以伪造</span><span class="n">RST</span><span class="err">包，来中断一条</span><span class="n">TCP</span><span class="o">+</span><span class="n">TLS</span><span class="err">连接。或者伪造部分</span><span class="n">TLS</span><span class="err">记录，导致连接阻塞挂起。不过这些攻击都是任何</span><span class="n">TCP</span><span class="err">协议都有问题，不是</span><span class="n">TLS</span><span class="err">特有的。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###9.Session Ticket 的安全分析</span>
</span><span class='line'>
</span><span class='line'><span class="n">Ticket</span><span class="err">必须</span><span class="o">:</span> <span class="mf">1.</span><span class="err">有</span><span class="n">MAC</span> <span class="err">（即</span> <span class="n">authenticated</span><span class="err">，不可篡改），</span><span class="mf">2.</span><span class="err">加密（即保密）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">下面分析在各种攻击方法下的安全性。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####1. 无效的Session </span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span><span class="err">协议要求当发现错误的时候，把</span><span class="n">TLS</span> <span class="n">session</span><span class="err">变为无效。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这不会影响到</span><span class="n">ticket</span><span class="err">的安全性。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####2. 窃取 Tickets</span>
</span><span class='line'>
</span><span class='line'><span class="err">攻击者或者中间人，可能会窃取到</span><span class="n">ticket</span><span class="err">，并且尝试用来和</span><span class="n">server</span><span class="err">建立会话。</span>
</span><span class='line'><span class="err">然而，由于</span><span class="n">ticket</span><span class="err">是加密过的，并且攻击者不知道密钥，窃取到的</span><span class="n">ticket</span><span class="err">无法使攻击者恢复会话。</span>
</span><span class='line'><span class="n">TLS</span><span class="err">服务器必须使用强加密和</span><span class="n">MAC</span><span class="err">算法，来保护</span><span class="n">ticket</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####3. 伪造 Tickets</span>
</span><span class='line'>
</span><span class='line'><span class="err">一个恶意用户可能会伪造，或者篡改一个</span><span class="n">ticket</span><span class="err">，来恢复一个会话，来延长</span><span class="n">ticket</span><span class="err">的生命周期，或者假装成另一个用户。</span>
</span><span class='line'>
</span><span class='line'><span class="err">然而，由于服务器使用了强的校验保护算法，比如带密码的</span> <span class="n">HMAC</span><span class="o">-</span><span class="n">SHA1</span> <span class="err">，因此无法得逞。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####4. DoS 攻击 </span>
</span><span class='line'>
</span><span class='line'><span class="err">推荐</span><span class="n">ticket</span> <span class="err">格式中的</span> <span class="n">key_name</span> <span class="err">字段帮助服务器有效地拒绝不是自己签发的票据。</span>
</span><span class='line'><span class="err">因此，一个攻击者可能发送大量的</span><span class="n">ticket</span><span class="err">，让服务器忙于验证</span><span class="n">ticket</span><span class="err">。</span>
</span><span class='line'><span class="err">然而，只要服务器使用了高效的加密和</span><span class="n">MAC</span><span class="err">算法，就不会有问题。（现实中，加密和</span><span class="n">MAC</span><span class="err">算法效率都极高，这根本不是问题）</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####5. 加密 Ticket 的key 的管理</span>
</span><span class='line'>
</span><span class='line'><span class="err">加密</span><span class="n">ticket</span><span class="err">的</span><span class="n">key</span><span class="err">的管理，推荐的做法：</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="n">key</span> <span class="err">应该用密码学安全的随机数生成器生成，按照</span><span class="n">RFC4086</span><span class="err">。</span>
</span><span class='line'><span class="o">*</span>  <span class="n">key</span> <span class="err">和加密算法最少应该是</span> <span class="mi">128</span> <span class="err">比特安全程度的。</span>
</span><span class='line'><span class="o">*</span>  <span class="n">key</span> <span class="err">除了加密和解密</span><span class="n">ticket</span><span class="err">以外，不应该有其他用途。</span>
</span><span class='line'><span class="o">*</span>  <span class="n">key</span> <span class="err">应该定期更换</span>
</span><span class='line'><span class="o">*</span>  <span class="err">当</span><span class="n">ticket</span><span class="err">格式更换，或者算法更换时，应该更换</span><span class="n">key</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">####6. Ticket 的有效期</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span><span class="err">服务器控制</span><span class="n">ticket</span><span class="err">的生命周期。服务器根据配置来决定可以接受的</span><span class="n">ticket</span><span class="err">生命周期。</span>
</span><span class='line'><span class="n">ticket</span><span class="err">的生命周期可能会长于</span><span class="mi">24</span><span class="err">小时。</span><span class="n">TLS</span><span class="err">客户端可能会接受到一个</span><span class="n">ticket</span><span class="err">生命周期的提示，当然，客户端本地的策略最终决定</span><span class="n">ticket</span><span class="err">保存多久。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####7. 其他的 Ticket 格式和分发方法</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果没使用推荐的</span><span class="n">ticket</span><span class="err">格式，那必须小心地分析方案的安全性。尤其是，如果保密数据比如保密密钥传输给了客户端，那必须用加密方式传输，来防止泄露或篡改。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####8. Identity Privacy, Anonymity, and Unlinkability</span>
</span><span class='line'>
</span><span class='line'><span class="n">ticket</span><span class="err">的加密和加</span><span class="n">MAC</span><span class="err">，就保证了敏感信息不会泄露。</span>
</span><span class='line'>
</span><span class='line'><span class="err">由于在</span><span class="n">ticket</span><span class="err">解密之前的</span><span class="n">TLS</span><span class="err">握手，无法隐藏客户端的特征，因此中间人可能根据相同的</span><span class="n">ticket</span><span class="err">被复用，发现相同的</span><span class="n">ticket</span><span class="err">属于相同的用户。</span><span class="n">TLS</span><span class="err">对这种情况不提供保证。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##9. TLS扩展:</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//tools.ietf.org/html/rfc6066&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">几个比较重要的</span><span class="n">TLS</span><span class="err">扩展：</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">Server</span> <span class="n">Name</span> <span class="n">Indication</span> <span class="p">(</span><span class="n">SNI</span><span class="p">)</span>
</span><span class='line'><span class="err">由于在</span><span class="n">SNI</span><span class="err">提出之前，</span><span class="n">tls</span><span class="err">握手过程中没有字段标明客户端希望连接服务器端的哪个域名，这样如果一个服务器端口上有多个域名，服务器就无法给出正确的证书。随着</span><span class="n">ipv4</span><span class="err">地址空间紧张，这个问题越发突出。因此提出了</span><span class="n">SNI</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">TLSEXT_ALPN</span>
</span><span class='line'><span class="err">上层协议协商，就是在握手过程中，标明</span><span class="n">TLS</span><span class="err">里面是什么协议，例如</span> <span class="n">http2</span><span class="err">就是</span> <span class="n">h2</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">Maximum</span> <span class="n">Fragment</span> <span class="n">Length</span> <span class="n">Negotiation</span>
</span><span class='line'><span class="err">主要用于嵌入式环境，需要客户端发送。</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">Session</span> <span class="n">Ticket</span>
</span><span class='line'><span class="n">Session</span> <span class="n">Ticket</span><span class="err">，就是把</span><span class="n">session</span> <span class="n">cache</span><span class="err">加密后存入客户端，这样服务器端就不需要任何存储了。</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">TLSEXT_SAFE_RENEGOTIATION</span>
</span><span class='line'><span class="err">重协商</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">Certificate</span> <span class="n">Status</span> <span class="nl">Request</span><span class="p">:</span>
</span><span class='line'><span class="n">OCSP</span> <span class="err">，</span><span class="n">OCSP</span> <span class="err">主要是为了减少客户端查询</span> <span class="err">证书撤销列表（</span><span class="n">Ceritificate</span> <span class="n">Revoke</span> <span class="n">List</span><span class="p">)</span><span class="err">的网络调用，而提出的。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##10. TLS的配套：PKI体系</span>
</span><span class='line'>
</span><span class='line'><span class="cp">### 1. X.509  证书</span>
</span><span class='line'>
</span><span class='line'><span class="n">X</span><span class="mf">.509</span><span class="err">是</span><span class="n">PKI</span><span class="err">的一个标准，其中内容包括：</span>
</span><span class='line'>
</span><span class='line'>   <span class="o">-</span> <span class="err">公钥证书</span>
</span><span class='line'>   <span class="o">-</span> <span class="err">证书撤销列表，</span><span class="n">CRL</span>
</span><span class='line'>   <span class="o">-</span> <span class="err">证书路径验证算法（</span><span class="n">CA</span><span class="o">/</span><span class="err">证书</span> <span class="err">链的格式）</span>
</span><span class='line'>
</span><span class='line'><span class="n">X</span><span class="mf">.509</span><span class="err">使用</span><span class="n">ASN</span><span class="mf">.1</span><span class="err">语法做序列化</span><span class="o">/</span><span class="err">反序列化</span>
</span><span class='line'>
</span><span class='line'><span class="n">ASN1</span> <span class="err">就是一个数据序列化</span><span class="o">/</span><span class="err">反序列化格式，跟</span> <span class="n">protobuf</span> <span class="err">差不多，可以算作竞争对手。</span>
</span><span class='line'>
</span><span class='line'><span class="n">DER</span> <span class="err">就是用</span> <span class="n">ASN1</span> <span class="err">序列化某些数据结构的格式。</span>
</span><span class='line'>
</span><span class='line'><span class="n">PEM</span> <span class="err">就是</span> <span class="n">DER</span><span class="err">做</span><span class="n">base64</span><span class="err">，加上一些其他字段。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">证书链，以一个或多个</span><span class="n">CA</span><span class="err">证书开头的证书的列表，其中</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="err">每一个证书的</span> <span class="n">Issuer</span> <span class="err">和下一个证书的</span> <span class="n">Subject</span> <span class="err">相同</span>
</span><span class='line'><span class="o">*</span>  <span class="err">每一个证书都被下一个证书的私钥签署</span>
</span><span class='line'><span class="o">*</span>  <span class="err">最后一个证书是</span> <span class="err">根证书</span><span class="p">(</span><span class="s">&quot;root CA&quot;</span><span class="p">)</span><span class="err">，在</span><span class="n">TLS</span><span class="err">握手中不会被发送</span>
</span><span class='line'>
</span><span class='line'><span class="o">!</span><span class="p">[][</span><span class="n">handshake_certificate_chain</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">证书里面包含公钥，和其它一些字段（比如证书用途，有效期，签发者等等）</span>
</span><span class='line'><span class="n">x509</span><span class="p">.</span><span class="n">v3</span><span class="err">证书的字段：</span>
</span><span class='line'><span class="o">!</span><span class="p">[][</span><span class="n">tls_certificate_x509_example</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">mozilla</span><span class="err">的</span><span class="n">ca</span><span class="err">证书列表</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//www.mozilla.org/en-US/about/governance/policies/security-group/certs/</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//www.apple.com/certificateauthority/ca_program.html</span>
</span><span class='line'><span class="err">苹果对</span><span class="n">CA</span><span class="err">提的要求：</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span><span class="n">CA</span><span class="err">必须取得完整的</span> <span class="n">WebTrust</span> <span class="k">for</span> <span class="n">Certification</span> <span class="n">Authorities</span> <span class="n">audit</span> <span class="err">（</span><span class="n">WebTrust</span> <span class="n">CA</span><span class="err">审计：</span><span class="nl">http</span><span class="p">:</span><span class="c1">//www.webtrust.org/）</span>
</span><span class='line'><span class="mf">2.</span><span class="err">你的</span><span class="n">root</span> <span class="n">CA</span><span class="err">证书必须为</span><span class="n">apple</span><span class="err">平台的用户提供广泛的商业价值。例如，一个组织内内部使用的证书不能被接受为</span><span class="n">root</span><span class="err">证书。</span>
</span><span class='line'><span class="mf">3.</span><span class="err">你签的证书必须含有可以公开访问的</span><span class="n">CRL</span><span class="err">地址。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Webtrust</span><span class="err">审计介绍：</span>
</span><span class='line'><span class="n">Webtrust</span><span class="err">是由世界两大著名注册会计师协会（美国注册会计师协会，</span><span class="n">AICPA</span><span class="err">和加拿大注册会计师协会，</span><span class="n">CICA</span><span class="err">）制定的安全审计标准，主要对申请对象的系统及业务运作逻辑安全性、保密性等共计七项内容进行近乎严苛的审查和鉴证。只有通过</span><span class="n">Webtrust</span><span class="err">国际安全审计认证，才有可能成为全球主流浏览器根信任的证书签发机构。</span>
</span><span class='line'>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//www.geotrust.com/</span>
</span><span class='line'><span class="err">的网站上右下角，有个图标</span><span class="o">:</span> <span class="o">!</span><span class="p">[][</span><span class="n">webtrust_logo</span><span class="p">]</span>
</span><span class='line'><span class="err">点开就可以看到</span> <span class="n">KPMG</span> <span class="err">对</span> <span class="n">geotrust</span> <span class="err">公司的</span> <span class="n">webtrust</span> <span class="err">审计报告</span><span class="o">:</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//cert.webtrust.org/SealFile?seal=1567&amp;amp;file=pdf</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'> <span class="mi">2011</span><span class="err">年</span> <span class="err">荷兰</span><span class="n">CA</span><span class="err">公司</span><span class="n">DigiNotar</span><span class="err">颁发假</span><span class="n">google</span><span class="err">，</span><span class="n">Facebook</span><span class="err">，微软证书被发现，后发现被入侵，导致该公司破产。</span>
</span><span class='line'><span class="nl">http</span><span class="p">:</span><span class="c1">//www.cnbeta.com/articles/154375.htm</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//news.ycombinator.com/item?id=530600&amp;gt;</span>
</span><span class='line'><span class="n">CA</span><span class="err">公司签署一个证书的成本是</span><span class="mi">0</span> <span class="err">。</span>
</span><span class='line'><span class="n">CA</span><span class="err">公司的主要成本构成：审核</span> <span class="err">，验证</span><span class="n">CSR</span><span class="err">成本，支持成本，法律成本</span><span class="p">(</span><span class="err">保险费用，担保费用</span><span class="p">)</span><span class="err">。</span>
</span><span class='line'><span class="err">要进入各个浏览器的根证书列表，</span><span class="n">CA</span><span class="err">公司每年必须过</span> <span class="n">WebTrust</span> <span class="err">年度审计，是很大的开销。</span>
</span><span class='line'><span class="err">一些浏览器厂商还会对植入根证书列表的</span><span class="n">CA</span><span class="err">收费。</span>
</span><span class='line'><span class="err">基础设施开销，</span><span class="n">CRL</span> <span class="err">和</span> <span class="n">OCSP</span> <span class="err">服务器成本。</span>
</span><span class='line'><span class="err">验证</span><span class="n">CSR</span><span class="err">：就是提交证书申请后，</span><span class="n">CA</span><span class="err">要做多项验证，越是高级的证书（比如</span><span class="n">EV</span><span class="err">）验证越麻烦。不固定开销，有些要花费很多人力和时间来完成。</span>
</span><span class='line'><span class="err">法律开销：</span><span class="n">CA</span><span class="err">公司得买保险，保险费跑不了。</span>
</span><span class='line'><span class="n">CA</span><span class="err">链费用：新开的</span><span class="n">CA</span><span class="err">公司要等</span><span class="mi">5</span><span class="o">-</span><span class="mi">10</span><span class="err">年，才会被普遍信任，才能广泛进入根证书链。要想加快点，就得给别的大牌</span><span class="n">CA</span><span class="err">公司掏钱，买次级证书。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">### 2.现有PKI体系暴露出的问题</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//googleonlinesecurity.blogspot.com/2015/03/maintaining-digital-certificate-security.html&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//blog.mozilla.org/security/2015/04/02/distrusting-new-cnnic-certificates/&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.dfn-cert.de/dokumente/workshop/2013/FolienSmith.pdf&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.cs.utexas.edu/~shmat/shmat_ccs12.pdf&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">解决方案：</span>
</span><span class='line'><span class="cp">### 1. public key pin</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">### 2. HSTS</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//www.chromium.org/hsts&amp;gt;</span>
</span><span class='line'><span class="err">收录进</span><span class="n">chrome</span><span class="err">的默认</span><span class="n">HSTS</span><span class="err">列表：</span>   <span class="nl">https</span><span class="p">:</span><span class="c1">//hstspreload.appspot.com/</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##11. TLS协议历史上出现过的漏洞，密码学常见陷阱</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###1. TLS的漏洞</span>
</span><span class='line'>
</span><span class='line'><span class="err">漏洞分析很耗时间，这里总结一些资料，有兴趣的自己看吧。</span>
</span><span class='line'>
</span><span class='line'><span class="err">虽然</span><span class="n">TLS</span><span class="err">的设计已经尽可能的严密，但是随着技术进步的滚滚车轮，历史上还是出现过很多漏洞，</span>
</span><span class='line'><span class="err">可以参看这个</span><span class="n">rfc</span><span class="err">，做了总结：</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">Summarizing</span> <span class="n">Known</span> <span class="n">Attacks</span> <span class="n">on</span> <span class="n">Transport</span> <span class="n">Layer</span> <span class="n">Security</span> <span class="p">(</span><span class="n">TLS</span><span class="p">)</span> <span class="n">and</span> <span class="n">Datagram</span> <span class="n">TLS</span> <span class="p">(</span><span class="n">DTLS</span><span class="p">)](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//tools.ietf.org/html/rfc7457)</span>
</span><span class='line'>
</span><span class='line'><span class="err">还有这个文档：</span>
</span><span class='line'><span class="p">[</span><span class="n">The</span> <span class="n">Sorry</span> <span class="n">State</span> <span class="n">Of</span> <span class="n">SSL</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//hynek.me/talks/tls/)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//hyperelliptic.org/internetcrypto/OpenSSLPresentation.pdf&amp;gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="err">协议最近一些年被爆出过的设计缺陷，尤其是在用的最多的</span> <span class="n">AES</span><span class="o">-</span><span class="n">CBC</span> <span class="err">和</span> <span class="n">RC4</span> <span class="err">上。</span>
</span><span class='line'>
</span><span class='line'><span class="n">AES</span><span class="o">-</span><span class="n">CBC</span> <span class="err">发现了</span><span class="o">:</span>
</span><span class='line'><span class="mf">1.</span>  <span class="n">padding</span> <span class="n">oracle</span> <span class="err">攻击</span>
</span><span class='line'><span class="mf">2.</span>  <span class="n">BEAST</span> <span class="err">攻击</span>
</span><span class='line'><span class="mf">3.</span>  <span class="n">Lucky</span> <span class="mi">13</span> <span class="err">攻击</span>
</span><span class='line'><span class="mf">4.</span>  <span class="n">TIME</span> <span class="err">攻击</span>
</span><span class='line'><span class="mf">5.</span>  <span class="n">POODLE</span><span class="err">攻击</span>
</span><span class='line'>
</span><span class='line'><span class="mi">2013</span> <span class="err">年</span><span class="p">,</span> <span class="n">AlFardan</span><span class="err">发表了对</span> <span class="n">RC4</span> <span class="err">的一个攻击分析，展示如何恢复</span> <span class="n">RC4</span> <span class="err">传输的连接上的数据。这种恢复攻击利用了</span><span class="n">RC4</span><span class="err">的一些已知弱点，例如</span><span class="n">RC4</span><span class="err">最初的一些字节的显著统计特征。</span>
</span><span class='line'>
</span><span class='line'><span class="err">最近几年，</span><span class="n">TLS</span><span class="err">的代码实现引起了安全研究者的关注，这导致了新漏洞不断发现。</span>
</span><span class='line'><span class="mi">2014</span><span class="err">年，</span><span class="n">OpenSSL</span><span class="err">库爆出了好几个漏洞，例如</span> <span class="n">HeartBleed</span><span class="err">，还有</span> <span class="n">CVE</span><span class="o">-</span><span class="mi">2014</span><span class="o">-</span><span class="mi">6321</span> <span class="p">(</span> <span class="n">Microsoft</span> <span class="n">SChannel</span> <span class="err">的实现漏洞</span><span class="p">)</span><span class="err">等</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span><span class="err">的问题</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="err">•</span> <span class="err">很多问题是由于</span><span class="n">TLS</span><span class="err">使用了一些“史前时代”的密码学算法</span><span class="p">(</span><span class="o">-</span> <span class="n">Eric</span> <span class="n">Rescorla</span><span class="p">)</span>
</span><span class='line'><span class="err">•</span> <span class="n">CBC</span> <span class="err">和</span> <span class="n">Mac</span><span class="o">-</span><span class="n">Pad</span><span class="o">-</span><span class="n">then</span><span class="o">-</span><span class="n">Encrypt</span>
</span><span class='line'><span class="err">•</span> <span class="n">RSA</span><span class="o">-</span><span class="n">PKCS</span><span class="err">#</span><span class="mi">1</span><span class="n">v1</span><span class="mf">.5</span> <span class="err">的</span> <span class="n">RSA</span> <span class="n">padding</span>
</span><span class='line'><span class="err">•</span> <span class="n">RC4</span> <span class="err">的任何使用</span>
</span><span class='line'><span class="err">•</span> <span class="err">很蠢的设计：临时</span> <span class="n">RSA</span> <span class="err">密钥协商，</span><span class="n">GOST</span> <span class="err">类</span><span class="n">CipherSuite</span><span class="err">，</span><span class="n">Snap</span> <span class="n">Start</span> <span class="err">等</span>
</span><span class='line'><span class="err">•</span> <span class="err">可怕的向后兼容要求，导致迟迟不能废弃一些老算法。</span>
</span><span class='line'>
</span><span class='line'><span class="n">The</span> <span class="n">Most</span> <span class="n">Dangerous</span> <span class="n">Code</span> <span class="n">in</span> <span class="n">the</span> <span class="nl">World</span><span class="p">:</span> <span class="n">Validating</span> <span class="n">SSL</span> <span class="n">Certificates</span> <span class="n">in</span> <span class="n">Non</span><span class="o">-</span><span class="n">Browser</span> <span class="n">Software</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.cs.utexas.edu/~shmat/shmat_ccs12.pdf&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">Why</span> <span class="n">Eve</span> <span class="n">and</span> <span class="n">Mallory</span> <span class="n">Love</span> <span class="n">Android</span> <span class="n">An</span> <span class="n">Analysis</span> <span class="n">of</span> <span class="n">Android</span> <span class="n">SSL</span> <span class="p">(</span><span class="n">In</span><span class="p">)</span><span class="n">Security</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.dfn-cert.de/dokumente/workshop/2013/FolienSmith.pdf)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###2. 密码学常见陷阱</span>
</span><span class='line'>
</span><span class='line'><span class="err">先举几个加密协议被破解的例子，给大家助兴：</span>
</span><span class='line'>
</span><span class='line'>   <span class="o">*</span> <span class="p">[</span><span class="err">人人网使用</span><span class="mi">256</span><span class="err">比特</span><span class="n">RSA</span><span class="err">加密登录密码，</span><span class="mi">3</span><span class="err">分钟可破</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.91ri.org/8928.html)</span>
</span><span class='line'>   <span class="o">*</span> <span class="p">[</span><span class="n">Flickr</span> <span class="n">length</span> <span class="n">extension</span> <span class="n">attack</span> <span class="err">漏洞</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//www.happybearsoftware.com/you-are-dangerously-bad-at-cryptography.html)</span>
</span><span class='line'>   <span class="o">*</span> <span class="p">[</span><span class="err">分析</span><span class="n">whatsapp</span><span class="err">协议缺陷的一个文章</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//blog.thijsalkema.de/blog/2013/10/08/piercing-through-whatsapp-s-encryption/)</span>
</span><span class='line'>   <span class="o">*</span> <span class="p">[</span><span class="err">卫星电话的私有</span><span class="n">gmr</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">gmr</span><span class="o">-</span><span class="mi">2</span><span class="err">加密算法被逆向并破解</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//cryptanalysis.eu/blog/2012/02/02/dont-trust-satellite-phones-the-gmr-1-and-gmr-2-ciphers-have-been-broken/)</span>
</span><span class='line'>   <span class="o">*</span> <span class="nl">http</span><span class="p">:</span><span class="c1">//cryptofails.blogspot.ca/2013/07/cakephp-using-iv-as-key.html</span>
</span><span class='line'>   <span class="o">*</span> <span class="nl">http</span><span class="p">:</span><span class="c1">//cryptofails.blogspot.ca/2013/07/saltstack-rsa-e-d-1.html</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">网上有一些资料，有兴趣自己看吧</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.schneier.com/essays/archives/1998/01/security_pitfalls_in.html&amp;gt;</span>
</span><span class='line'><span class="o">*</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.schneier.com/essays/archives/1999/03/cryptography_the_imp.html&amp;gt;</span>
</span><span class='line'><span class="o">*</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//www.lauradhamilton.com/10-cryptography-mistakes-amateurs-make&amp;gt;</span>
</span><span class='line'><span class="o">*</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//www.cryptofails.com/&amp;gt;</span>
</span><span class='line'><span class="o">*</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//cryptofails.blogspot.ca/&amp;gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">密码学常见应用错误</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="err">不要自己发明加密算法。</span><span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">roll</span> <span class="n">your</span> <span class="n">own</span> <span class="n">crypto</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要使用不带</span><span class="n">MAC</span><span class="err">的加密</span> <span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">encryption</span> <span class="n">without</span> <span class="n">message</span> <span class="n">authentication</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">在拼接多个字符串做</span><span class="n">hash</span><span class="err">之前，要特别小心</span> <span class="n">Be</span> <span class="n">careful</span> <span class="n">when</span> <span class="n">concatenating</span> <span class="n">multiple</span> <span class="n">strings</span><span class="p">,</span> <span class="n">before</span> <span class="n">hashing</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">要特别小心使用的随机数生成器，确保有足够的熵</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">you</span> <span class="n">seed</span> <span class="n">random</span> <span class="n">number</span> <span class="n">generators</span> <span class="n">with</span> <span class="n">enough</span> <span class="n">entropy</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要重用</span> <span class="n">nonce</span> <span class="err">或者。</span><span class="n">IV</span> <span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">reuse</span> <span class="n">nonces</span> <span class="n">or</span> <span class="n">IVs</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">加密和</span><span class="n">MAC</span><span class="err">不要使用同样的</span><span class="n">key</span><span class="err">，非对称加密和签名不要使用相同的</span><span class="n">key</span> <span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">the</span> <span class="n">same</span> <span class="n">key</span> <span class="k">for</span> <span class="n">both</span> <span class="n">encryption</span> <span class="n">and</span> <span class="n">authentication</span><span class="p">.</span> <span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">the</span> <span class="n">same</span> <span class="n">key</span> <span class="k">for</span> <span class="n">both</span> <span class="n">encryption</span> <span class="n">and</span> <span class="n">signing</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要使用</span><span class="n">ECB</span><span class="err">模式做对称加密</span> <span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">a</span> <span class="n">block</span> <span class="n">cipher</span> <span class="n">with</span> <span class="n">ECB</span> <span class="k">for</span> <span class="n">symmetric</span> <span class="n">encryption</span>
</span><span class='line'><span class="o">*</span>  <span class="n">Kerckhoffs</span><span class="err">定律，一个密码学系统的安全性必须建立在密码保密的基础上，其他都是公开的。</span><span class="n">Kerckhoffs</span><span class="err">&#39;</span><span class="n">s</span> <span class="nl">principle</span><span class="p">:</span> <span class="n">A</span> <span class="n">cryptosystem</span> <span class="n">should</span> <span class="n">be</span> <span class="n">secure</span> <span class="n">even</span> <span class="k">if</span> <span class="n">everything</span> <span class="n">about</span> <span class="n">the</span> <span class="n">system</span><span class="p">,</span> <span class="n">except</span> <span class="n">the</span> <span class="n">key</span><span class="p">,</span> <span class="n">is</span> <span class="n">public</span> <span class="n">knowledge</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要把用户产生的密码作为加密的</span><span class="n">key</span><span class="err">。</span><span class="n">Try</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">using</span> <span class="n">passwords</span> <span class="n">as</span> <span class="n">encryption</span> <span class="n">keys</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">在密码学协议中，任何</span><span class="mi">2</span><span class="err">条消息的密文都不应该一样。</span><span class="n">In</span> <span class="n">a</span> <span class="n">cryptographic</span> <span class="nl">protocol</span><span class="p">:</span> <span class="n">Make</span> <span class="n">every</span> <span class="n">authenticated</span> <span class="n">message</span> <span class="nl">recognisable</span><span class="p">:</span> <span class="n">no</span> <span class="n">two</span> <span class="n">messages</span> <span class="n">should</span> <span class="n">look</span> <span class="n">the</span> <span class="n">same</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要把相同的</span><span class="n">key</span><span class="err">用在通信的</span><span class="mi">2</span><span class="err">个方向上。</span><span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">the</span> <span class="n">same</span> <span class="n">key</span> <span class="n">in</span> <span class="n">both</span> <span class="n">directions</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="err">不要使用不安全的</span><span class="n">key</span><span class="err">长度。</span><span class="n">Don</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">use</span> <span class="n">insecure</span> <span class="n">key</span> <span class="n">lengths</span><span class="p">.</span>
</span><span class='line'><span class="o">*</span>  <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##13. 下一代TLS: TLS 1.3</span>
</span><span class='line'>
</span><span class='line'><span class="n">tls</span> <span class="mf">1.3</span><span class="err">的草案在</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//tlswg.github.io/tls13-spec/&amp;gt;</span>
</span><span class='line'><span class="err">相比</span><span class="n">tls</span> <span class="mf">1.2</span><span class="p">,</span>  <span class="mf">1.3</span><span class="err">改动巨大，这些改动对加密通信协议的一般设计也有重要启发。</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">的改动</span>
</span><span class='line'><span class="err">值得关注的重大改进有：</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="err">支持</span>
</span><span class='line'><span class="o">*</span>  <span class="mi">1</span><span class="o">-</span><span class="n">RTT</span><span class="err">握手支持</span>
</span><span class='line'><span class="o">*</span>  <span class="err">改为使用</span><span class="n">HKDF</span><span class="err">做密钥拓展</span>
</span><span class='line'><span class="o">*</span>  <span class="err">彻底禁止</span><span class="n">RC4</span>
</span><span class='line'><span class="o">*</span>  <span class="err">彻底禁止压缩</span>
</span><span class='line'><span class="o">*</span>  <span class="err">彻底禁止</span><span class="n">aead</span><span class="err">以外的其他算法</span>
</span><span class='line'><span class="o">*</span>  <span class="err">去除</span><span class="n">aead</span><span class="err">的显式</span><span class="n">IV</span>
</span><span class='line'><span class="o">*</span>  <span class="err">去除了</span><span class="n">AEAD</span><span class="err">的</span><span class="n">AD</span><span class="err">中的长度字段</span>
</span><span class='line'><span class="o">*</span>  <span class="err">去除</span><span class="n">ChangeCipherSpec</span>
</span><span class='line'><span class="o">*</span>  <span class="err">去除重协商</span>
</span><span class='line'><span class="o">*</span>  <span class="err">去除静态</span><span class="n">RSA</span><span class="err">和</span><span class="n">DH</span><span class="err">密钥协商</span>
</span><span class='line'>
</span><span class='line'><span class="err">移动互联网兴起之后，</span><span class="n">rtt</span><span class="err">延迟变得更重要，可以看到，</span><span class="n">tls</span> <span class="mf">1.3</span> <span class="err">的各项改进，主要就是针对移动互联网场景的。</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">去掉了</span> <span class="n">ChangeCipherSpec</span> <span class="err">，这样</span><span class="n">record</span><span class="err">之上有</span><span class="mi">3</span><span class="err">个协议：</span><span class="n">handshake</span><span class="err">，</span><span class="n">alert</span><span class="err">，</span><span class="n">application</span> <span class="n">data</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###1. record层的密码学保护的改动</span>
</span><span class='line'><span class="err">由于只保留了</span><span class="n">aead</span><span class="err">，所以不需要</span><span class="n">MAC</span> <span class="n">key</span><span class="err">了。</span>
</span><span class='line'>
</span><span class='line'><span class="n">aead</span><span class="err">的具体参数用法也有调整，前文有。</span>
</span><span class='line'>
</span><span class='line'><span class="n">KDF</span> <span class="err">换成了标准的</span><span class="n">HKDF</span><span class="err">，有</span><span class="mi">2</span><span class="err">种</span> <span class="n">tls_kdf_sha256</span><span class="p">,</span> <span class="n">tls_kdf_sha384</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###2.handshake协议的改动</span>
</span><span class='line'>
</span><span class='line'><span class="err">鉴于</span><span class="n">session</span> <span class="n">ticket</span><span class="err">如此之好用，简直人见人爱，所以</span> <span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">直接把</span><span class="n">session</span> <span class="n">ticket</span><span class="err">内置了，并改名叫</span> <span class="n">PSK</span>
</span><span class='line'>
</span><span class='line'><span class="err">要注意的是，此</span> <span class="n">PSK</span> <span class="err">和</span> <span class="n">tls</span> <span class="mf">1.2</span><span class="err">中一个很生僻的</span><span class="n">psk</span><span class="p">(</span><span class="err">见</span> <span class="p">[</span><span class="n">rfc4279</span><span class="p">](</span><span class="nl">https</span><span class="p">:</span><span class="c1">//tools.ietf.org/html/rfc4279) )并不是一回事。</span>
</span><span class='line'>
</span><span class='line'><span class="err">综合考虑了</span> <span class="n">session</span> <span class="n">resuming</span> <span class="err">，</span><span class="n">session</span> <span class="n">ticket</span><span class="err">后，</span>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">提出了</span><span class="mi">3</span><span class="err">种</span><span class="n">handshake</span><span class="err">模式：</span>
</span><span class='line'>
</span><span class='line'> <span class="mf">1.</span>  <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">（</span> <span class="err">包含</span> <span class="n">DH</span> <span class="err">和</span> <span class="n">ECDH</span> <span class="err">两种，下文说到</span> <span class="n">ECDH</span> <span class="err">的地方，请自行脑补成</span> <span class="s">&quot;ECDH/DH&quot;</span><span class="err">）</span><span class="p">.</span>
</span><span class='line'> <span class="mf">1.</span>  <span class="n">A</span> <span class="n">pre</span><span class="o">-</span><span class="n">shared</span> <span class="n">symmetric</span> <span class="n">key</span> <span class="p">(</span><span class="n">PSK</span><span class="p">)</span> <span class="err">，预先共享的对称密钥，此处用统一的模型来处理</span><span class="n">session</span> <span class="n">resuming</span> <span class="err">和</span> <span class="n">rfc4279</span><span class="err">的</span><span class="n">psk</span>
</span><span class='line'> <span class="mf">1.</span>  <span class="n">A</span> <span class="n">combination</span> <span class="n">of</span> <span class="n">a</span> <span class="n">symmetric</span> <span class="n">key</span> <span class="n">and</span> <span class="n">Diffie</span><span class="o">-</span><span class="n">Hellman</span> <span class="err">，前两者合体</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###3.1-RTT 握手</span>
</span><span class='line'>
</span><span class='line'><span class="err">首先，</span><span class="n">TLS</span> <span class="mf">1.2</span> <span class="err">的握手有</span><span class="mi">2</span><span class="err">个</span><span class="n">rtt</span><span class="err">，第一个</span><span class="n">rtt</span><span class="err">是</span> <span class="n">ClientHello</span><span class="o">/</span><span class="n">ServerHello</span><span class="err">，第二个</span><span class="n">rtt</span><span class="err">是</span><span class="n">ClientKeyExchange</span><span class="o">/</span><span class="n">ServerKeyExchange</span><span class="err">，</span>
</span><span class='line'><span class="err">之所以</span><span class="n">KeyExchange</span><span class="err">要放在第二个</span><span class="n">rtt</span><span class="err">，是由于</span><span class="n">tls1</span><span class="mf">.2</span><span class="err">要支持多种密钥交换算法，和各种不同参数</span><span class="p">(</span><span class="err">比如</span> <span class="n">DH</span><span class="err">还是</span><span class="n">ECDH</span><span class="err">还是</span><span class="n">RSA</span><span class="err">，</span><span class="n">ECDHE</span><span class="err">用什么曲线，</span><span class="n">DH</span><span class="err">用什么群生成元，用什么模数，等等</span><span class="p">)</span><span class="err">，这些算法和参数都依赖第一个</span><span class="n">rtt</span><span class="err">去协商出来，</span>
</span><span class='line'><span class="n">TLS1</span><span class="mf">.3</span><span class="err">大刀阔斧地砍掉了各种自定义</span><span class="n">DH</span><span class="err">群，砍掉了</span><span class="n">ECDH</span><span class="err">的自定义曲线，砍掉了</span><span class="n">RSA</span><span class="err">协商，密钥协商的算法只剩下不多几个，而且其实大家实际应用中基本都用</span> <span class="n">ECDH</span> <span class="n">P</span><span class="o">-</span><span class="mi">256</span><span class="err">，也没啥人用别的，所以干脆让客户端缓存服务器上一次用的是啥协商算法，把</span> <span class="n">KeyExchange</span><span class="err">直接和入第一个</span><span class="n">rtt</span><span class="err">，客户端在第一个</span><span class="n">rtt</span><span class="err">里直接就用缓存的这个算法发</span><span class="n">KeyExchange</span><span class="err">的公钥，如果服务器发现客户端发上来的算法不对，那么再告诉正确的，让客户端重试好了。</span>
</span><span class='line'><span class="err">这样，就引入了</span> <span class="n">HelloRetryRequest</span> <span class="err">这个消息。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这样，基本没有副作用，就可以降到</span> <span class="mi">1</span><span class="o">-</span><span class="n">RTT</span><span class="err">。</span>
</span><span class='line'><span class="err">这是</span><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">的完整握手。</span>
</span><span class='line'>
</span><span class='line'> <span class="o">**</span><span class="err">显然，如果一个协议只有一种密钥协商算法，比如定死为</span> <span class="n">ECDH</span> <span class="n">P</span><span class="o">-</span><span class="mi">256</span><span class="err">，那一定可以做到</span> <span class="mi">1</span><span class="o">-</span><span class="n">RTT</span><span class="o">**</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###4.  有副作用的 0-RTT握手</span>
</span><span class='line'>
</span><span class='line'><span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="err">应该是受</span><span class="n">Google</span><span class="err">的</span><span class="n">QUIC</span><span class="err">协议的启发，</span>
</span><span class='line'><span class="err">如果服务器把自己的</span> <span class="n">ECDH</span> <span class="err">公钥长期缓存在客户端，那么客户端就可以用缓存里的</span><span class="n">ECDHE</span><span class="err">公钥，构造一个电子信封，在第一个</span><span class="n">RTT</span><span class="err">里，直接就发送应用层数据了。</span>
</span><span class='line'><span class="err">这个长期缓存在客户端的</span><span class="n">ECDH</span><span class="err">公钥，称为</span> <span class="err">半静态</span> <span class="n">ECDH</span> <span class="err">公钥（</span> <span class="n">semi</span><span class="o">-</span><span class="k">static</span> <span class="p">(</span><span class="n">EC</span><span class="p">)</span><span class="n">DH</span> <span class="n">share</span> <span class="err">）</span>
</span><span class='line'><span class="n">ECDH</span><span class="err">公钥通过</span> <span class="n">ServerConfiguration</span> <span class="err">消息发送给客户端。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这个</span><span class="mi">0</span><span class="o">-</span><span class="n">rtt</span><span class="err">优化是有副作用的：</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span> <span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="err">发送的应用数据没有前向安全性。</span>
</span><span class='line'><span class="mf">1.</span> <span class="err">跨连接可以重放</span><span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="err">里的应用数据（任何服务器端无共享状态的协议，都无法做到跨连接防重放）</span>
</span><span class='line'><span class="mf">1.</span> <span class="err">如果服务器端</span> <span class="err">半静态</span> <span class="n">ECDH</span><span class="err">公钥对应的私钥泄露了，攻击者就可以伪装成客户端随意篡改数据了。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">服务器在</span> <span class="n">ServerConfiguration</span> <span class="err">消息里把半静态</span> <span class="n">ECDH</span> <span class="err">公钥发送给客户端。</span>
</span><span class='line'><span class="n">ServerConfiguration</span> <span class="err">值得关注一下：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">configuration_id</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="n">uint32</span> <span class="n">expiration_date</span><span class="p">;</span>
</span><span class='line'>  <span class="n">NamedGroup</span> <span class="n">group</span><span class="p">;</span>
</span><span class='line'>  <span class="n">opaque</span> <span class="n">server_key</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="n">EarlyDataType</span> <span class="n">early_data_type</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ConfigurationExtension</span> <span class="n">extensions</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mf">0..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">ServerConfiguration</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">其中的</span> <span class="n">expiration_date</span> <span class="err">是本</span> <span class="n">ServerConfiguration</span> <span class="err">最后的有效期限。</span>
</span><span class='line'><span class="err">这个值绝对不允许大于</span><span class="mi">7</span><span class="err">天。</span>
</span><span class='line'><span class="err">客户端绝对不允许存储</span> <span class="n">ServerConfiguration</span> <span class="err">大于</span><span class="mi">7</span><span class="err">天，不管服务器怎么填这个值。</span>
</span><span class='line'>
</span><span class='line'><span class="mi">0</span><span class="o">-</span><span class="n">RTT</span> <span class="err">中的应用数据，放在</span> <span class="n">EarlyDataIndication</span> <span class="err">中发送，</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">还特意给</span> <span class="n">EarlyDataIndication</span>  <span class="err">定义了一种</span> <span class="nl">ContentType</span> <span class="p">:</span> <span class="n">early_handshake</span>
</span><span class='line'><span class="err">（共四种</span> <span class="n">alert</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span> <span class="n">handshake</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span>      <span class="n">application_data</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">early_handshake</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span> <span class="err">）</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###5.  Resumption 和  PSK</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">里面，把</span><span class="n">session</span> <span class="n">resumption</span><span class="o">/</span><span class="n">session</span> <span class="n">ticket</span> <span class="err">恢复出来的</span><span class="n">key</span><span class="err">，和</span> <span class="n">psk</span> <span class="p">(</span><span class="n">rfc4279</span><span class="p">)</span><span class="err">，</span> <span class="err">统一在一个</span> <span class="n">handshake</span> <span class="n">PSK</span> <span class="err">模式下处理。</span>
</span><span class='line'>
</span><span class='line'><span class="n">PSK</span> <span class="n">CipherSuite</span><span class="err">可以</span> <span class="err">把</span><span class="n">PSK</span><span class="err">和</span><span class="n">ECDHE</span><span class="err">结合起来用，这样是有前向安全性的。</span>
</span><span class='line'><span class="err">也可以仅仅使用</span><span class="n">PSK</span><span class="err">，这样就没有前向安全性。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">###6. Key Schedule 过程的改动</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">中，综合考虑的</span> <span class="n">session</span> <span class="n">ticket</span><span class="err">的各种情况后，提出了</span> <span class="n">ES</span><span class="err">，</span><span class="n">SS</span> <span class="err">两个概念，统一处理密钥协商的各种情况。</span>
</span><span class='line'><span class="err">在各种</span><span class="n">handshake</span><span class="err">模式下，</span><span class="n">ES</span><span class="err">和</span><span class="n">SS</span><span class="err">的取值来源不同。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Ephemeral</span> <span class="n">Secret</span> <span class="p">(</span><span class="n">ES</span><span class="p">)</span>
</span><span class='line'><span class="o">:</span>  <span class="err">每个连接新鲜的</span> <span class="n">ECDHE</span> <span class="err">协商得出的值。凡是从</span> <span class="n">ES</span> <span class="err">得出的值，都是前向安全的（当然，在</span> <span class="n">PSK</span> <span class="n">only</span><span class="err">模式下，不是前向安全的）。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Static</span> <span class="n">Secret</span> <span class="p">(</span><span class="n">SS</span><span class="p">)</span>
</span><span class='line'><span class="o">:</span>  <span class="err">从静态，或者半静态</span><span class="n">key</span><span class="err">得出的值。例如</span><span class="n">psk</span><span class="err">，或者服务器的半静态</span> <span class="n">ECDH</span> <span class="err">公钥。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">在各种</span> <span class="n">handshake</span> <span class="err">模式下：</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">|</span>    <span class="n">Key</span> <span class="n">Exchange</span>       <span class="o">|</span>     <span class="n">Static</span> <span class="n">Secret</span> <span class="p">(</span><span class="n">SS</span><span class="p">)</span> <span class="o">|</span>    <span class="n">Ephemeral</span> <span class="n">Secret</span> <span class="p">(</span><span class="n">ES</span><span class="p">)</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span>    <span class="o">------------</span>       <span class="o">|</span>     <span class="o">------------------</span> <span class="o">|</span>   <span class="o">---------------------</span>  <span class="o">|</span>
</span><span class='line'><span class="o">|</span><span class="p">(</span><span class="n">EC</span><span class="p">)</span><span class="n">DHE</span> <span class="p">(</span><span class="err">完整握手</span><span class="p">)</span><span class="o">|</span><span class="n">Client</span> <span class="n">ephemeral</span>  <span class="n">w</span><span class="o">/</span> <span class="n">server</span> <span class="n">ephemeral</span> <span class="o">|</span> <span class="n">Client</span> <span class="n">ephemeral</span> <span class="n">w</span><span class="o">/</span> <span class="n">server</span> <span class="n">ephemeral</span><span class="o">|</span>
</span><span class='line'><span class="o">|</span><span class="p">(</span><span class="n">EC</span><span class="p">)</span><span class="n">DHE</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span> <span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="p">)</span><span class="o">|</span><span class="n">Client</span> <span class="n">ephemeral</span> <span class="n">w</span><span class="o">/</span> <span class="n">server</span> <span class="k">static</span> <span class="o">|</span><span class="n">Client</span> <span class="n">ephemeral</span> <span class="n">w</span><span class="o">/</span> <span class="n">server</span> <span class="n">ephemeral</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span>    <span class="n">PSK</span>                    <span class="o">|</span>     <span class="n">Pre</span><span class="o">-</span><span class="n">Shared</span> <span class="n">Key</span>    <span class="o">|</span>       <span class="n">Pre</span><span class="o">-</span><span class="n">shared</span> <span class="n">key</span>  <span class="o">|</span>
</span><span class='line'><span class="o">|</span>    <span class="n">PSK</span> <span class="o">+</span> <span class="p">(</span><span class="n">EC</span><span class="p">)</span><span class="n">DHE</span>          <span class="o">|</span>     <span class="n">Pre</span><span class="o">-</span><span class="n">Shared</span> <span class="n">Key</span>    <span class="o">|</span>    <span class="n">Client</span> <span class="n">ephemeral</span>  <span class="n">w</span><span class="o">/</span> <span class="n">server</span> <span class="n">ephemeral</span> <span class="o">|</span>
</span><span class='line'><span class="err">如上表所示：</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="err">完整的</span> <span class="mi">1</span><span class="o">-</span><span class="n">RTT</span><span class="err">握手的时候，</span> <span class="n">SS</span> <span class="err">和</span> <span class="n">ES</span> <span class="err">都是用的</span> <span class="n">ephemeral</span> <span class="n">key</span> <span class="err">，这样是一定有前向安全性的。</span>
</span><span class='line'><span class="mf">1.</span>  <span class="err">使用</span> <span class="mi">0</span><span class="o">-</span><span class="n">RTT</span> <span class="err">的握手的时候，使用客户端的</span> <span class="n">ephemeral</span> <span class="n">key</span> <span class="err">和</span> <span class="err">服务器端的半静态</span> <span class="n">ECDH</span> <span class="err">公钥生成</span> <span class="n">SS</span><span class="err">，</span>
</span><span class='line'><span class="mf">1.</span>  <span class="err">纯</span> <span class="n">PSK</span><span class="err">，这种场景完全没有前向安全性，应该避免。</span>
</span><span class='line'><span class="mf">1.</span>  <span class="n">PSK</span> <span class="o">+</span><span class="err">　</span><span class="n">ECDHE</span><span class="err">，这种场景比较有意思，</span><span class="n">SS</span><span class="err">是用的</span><span class="n">Pre</span><span class="o">-</span><span class="n">Shared</span> <span class="n">Key</span><span class="err">，没有前向安全性，</span><span class="n">ES</span> <span class="err">用的</span> <span class="n">ephemeral</span> <span class="n">key</span><span class="err">，有前向安全性。</span>
</span><span class='line'>
</span><span class='line'><span class="err">可以看到，相比</span> <span class="n">TLS</span> <span class="mf">1.2</span> <span class="err">的</span> <span class="n">session</span> <span class="n">ticket</span><span class="err">，</span><span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">中</span> <span class="err">的</span> <span class="n">PSK</span> <span class="o">+</span> <span class="n">ECDHE</span><span class="err">，是结合了</span> <span class="n">ES</span> <span class="err">的，这样就有了前向安全性，相对更安全。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">和</span> <span class="n">TLS</span> <span class="mf">1.2</span> <span class="err">不同的是，</span><span class="n">TLS</span> <span class="mf">1.3</span><span class="err">的</span> <span class="n">master_secret</span> <span class="err">是使用</span> <span class="n">ES</span><span class="err">和</span><span class="n">SS</span> <span class="err">两个得出的。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span> <span class="o">=</span>
</span><span class='line'>   <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="err">\</span><span class="mi">0</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span> <span class="o">+</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ol</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">xSS</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">extractedSS</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">L</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">xES</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">extractedES</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">L</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">master_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span> <span class="n">xES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">master</span> <span class="n">secret</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">L</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">finished_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span>
</span><span class='line'>                                 <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">finished</span> <span class="n">secret</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span>
</span><span class='line'>                                 <span class="n">handshake_hash</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ol</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'> <span class="n">Traffic</span> <span class="n">Key</span> <span class="n">Calculation</span>
</span><span class='line'>
</span><span class='line'> <span class="err">加密流量用的</span><span class="n">key</span><span class="err">，在</span> <span class="n">TLS</span> <span class="mf">1.3</span> <span class="err">里面称为</span> <span class="n">Traffic</span> <span class="n">Key</span><span class="err">，由于多引入了一种</span><span class="n">ContentType</span><span class="err">，在不同的</span><span class="n">ContentType</span><span class="err">下，</span><span class="n">Traffic</span> <span class="n">Key</span> <span class="err">并不相同。</span>
</span><span class='line'> <span class="err">如下表：</span>
</span><span class='line'>
</span><span class='line'><span class="o">|</span>  <span class="n">Record</span> <span class="n">Type</span> <span class="o">|</span> <span class="n">Secret</span> <span class="o">|</span> <span class="n">Label</span>     <span class="o">|</span>                         <span class="n">Handshake</span> <span class="n">Hash</span><span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">-----------</span> <span class="o">|</span> <span class="o">------</span> <span class="o">|</span> <span class="o">-----</span>     <span class="o">|</span>                       <span class="o">---------------</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="n">Early</span> <span class="n">data</span>  <span class="o">|</span>   <span class="n">xSS</span>  <span class="o">|</span> <span class="s">&quot;early data key expansion&quot;</span>        <span class="o">|</span>    <span class="n">ClientHello</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="n">Handshake</span>   <span class="o">|</span>  <span class="n">xES</span>   <span class="o">|</span> <span class="s">&quot;handshake key expansion&quot;</span>         <span class="o">|</span> <span class="n">ClientHello</span><span class="p">...</span>      <span class="n">ServerKeyShare</span><span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="n">Application</span> <span class="o">|</span> <span class="n">master</span> <span class="n">secret</span> <span class="o">|</span> <span class="s">&quot;application data key expansion&quot;</span>  <span class="o">|</span>  <span class="n">All</span> <span class="n">handshake</span> <span class="n">messages</span> <span class="n">but</span>     <span class="n">Finished</span><span class="o">|</span>
</span><span class='line'>
</span><span class='line'><span class="err">要关注的是，</span> <span class="n">Early</span> <span class="n">Data</span> <span class="err">的</span> <span class="n">Traffic</span> <span class="n">Key</span> <span class="err">是用</span> <span class="n">xSS</span> <span class="err">算出来的。也就是说，是用</span> <span class="n">Pre</span><span class="o">-</span><span class="n">Shared</span> <span class="n">Key</span><span class="err">决定的。因此是没有前向安全性的。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="err">在一个</span><span class="n">TLS</span> <span class="err">连接中，究竟是用哪种</span> <span class="n">handshake</span> <span class="err">模式，是由</span> <span class="n">CipherSuite</span> <span class="err">协商决定的。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#三. TLS协议的代码实现</span>
</span><span class='line'>
</span><span class='line'><span class="n">TLS</span><span class="err">的主要实现：</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span>  <span class="n">OpenSSL</span>
</span><span class='line'><span class="o">*</span>  <span class="n">libressl</span>
</span><span class='line'><span class="o">*</span>  <span class="n">boringssl</span><span class="p">(</span><span class="n">Google</span><span class="p">)</span>
</span><span class='line'><span class="o">*</span>  <span class="n">libressl</span>
</span><span class='line'><span class="o">*</span>  <span class="n">s2n</span><span class="p">(</span><span class="n">Amazon</span><span class="p">)</span>
</span><span class='line'><span class="o">*</span>  <span class="n">nss</span><span class="p">(</span><span class="n">Mozilla</span><span class="p">)</span>
</span><span class='line'><span class="o">*</span>  <span class="n">polarssl</span>
</span><span class='line'><span class="o">*</span>  <span class="n">botan</span>
</span><span class='line'><span class="o">*</span>  <span class="n">gnutls</span><span class="p">(</span><span class="n">gpl</span><span class="p">)</span>
</span><span class='line'><span class="o">*</span>  <span class="n">cyassl</span>
</span><span class='line'><span class="o">*</span>  <span class="n">go</span><span class="p">.</span><span class="n">crypto</span>
</span><span class='line'>
</span><span class='line'><span class="n">openssl</span> <span class="err">的</span> <span class="n">tls</span> <span class="err">协议实现有</span> <span class="mi">6</span><span class="n">W</span> <span class="err">行，</span><span class="n">libressl</span> <span class="mf">3.68</span><span class="n">W</span><span class="err">行，</span> <span class="n">polarssl</span> <span class="mf">1.29</span> <span class="n">W</span><span class="err">行，</span> <span class="n">Botan</span> <span class="mf">1.13</span> <span class="n">W</span><span class="err">行</span>
</span><span class='line'>
</span><span class='line'><span class="n">openssl</span><span class="err">是其中代码最糟糕的（没有之一）。</span>
</span><span class='line'><span class="n">openssl</span><span class="err">提供了的</span><span class="n">api</span><span class="err">都太过于底层，</span><span class="n">api</span><span class="err">设计的也很费解，而且严重匮乏文档。</span>
</span><span class='line'><span class="err">请参考</span> <span class="p">[</span><span class="err">《令人作呕的</span><span class="n">OpenSSL</span><span class="err">》</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//blog.csdn.net/dog250/article/details/24552307)</span>
</span><span class='line'>
</span><span class='line'><span class="err">不幸的是，</span><span class="n">OpenSSL</span><span class="err">是用的最广泛的，是事实上的标准。</span>
</span><span class='line'>
</span><span class='line'><span class="n">boringssl</span>
</span><span class='line'><span class="n">Google</span><span class="err">’</span><span class="n">s</span> <span class="n">OpenSSL</span> <span class="n">fork</span> <span class="n">by</span> <span class="n">Adam</span> <span class="n">Langley</span> <span class="p">(</span><span class="err">@</span><span class="n">agl__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/sweis/crypto-might-not-suck</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#四. TLS协议的部署与优化</span>
</span><span class='line'>
</span><span class='line'><span class="err">这个方面网上的文章还是不少的，本文就简略一点。</span>
</span><span class='line'>
</span><span class='line'><span class="err">全站</span><span class="n">https</span><span class="err">时代正在到来</span><span class="o">!</span><span class="err">，</span>
</span><span class='line'><span class="err">移动互联网对人们生活的介入越来越深人，用户越来越多的隐私数据和支付数据通过网络传输，人们的隐私意识安全意识不断提高；运营商流量劫持，强行插入广告越来越引起反感。因此，各互联网大厂都开始切换到</span><span class="n">https</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">例如，</span><span class="mi">2015</span><span class="err">年</span><span class="mi">3</span><span class="err">月百度全站切换到</span><span class="n">https</span><span class="err">，百度运维部的介绍文章：</span><span class="p">[</span><span class="err">《全站</span> <span class="n">https</span> <span class="err">时代的号角</span> <span class="o">:</span> <span class="err">大型网站的</span> <span class="n">https</span> <span class="err">实践系列》</span><span class="p">](</span><span class="nl">http</span><span class="p">:</span><span class="c1">//op.baidu.com/2015/04/https-index/)。</span>
</span><span class='line'>
</span><span class='line'><span class="err">不久后淘宝切了全站</span><span class="n">https</span><span class="err">，</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.taobao.com/&amp;gt;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//velocity.oreilly.com.cn/2015/index.php?func=session&amp;amp;id=8&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">国外：由</span><span class="n">Snowden</span><span class="err">爆料，美国人发现</span><span class="n">NSA</span><span class="err">在大范围深度地监听互联网</span><span class="p">;</span> <span class="err">还有</span><span class="n">openssl</span><span class="err">连续被爆多个严重安全漏洞。之后近</span><span class="mi">2</span><span class="err">年，各种加密通信协议，软件，项目开始热门，各大厂商开始关注密码协议，做数据加密，信息安全。</span><span class="p">(</span><span class="n">openssl</span><span class="err">资助，</span><span class="n">pfs</span><span class="err">被重视，</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">Google</span><span class="err">的性能数据：</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="err">“</span><span class="n">In</span> <span class="n">January</span> <span class="n">this</span> <span class="n">year</span> <span class="p">(</span><span class="mi">2010</span><span class="p">),</span> <span class="n">Gmail</span> <span class="n">switched</span> <span class="n">to</span> <span class="n">using</span> <span class="n">HTTPS</span> <span class="k">for</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">everything</span> <span class="n">by</span> <span class="k">default</span><span class="p">.</span> <span class="p">..</span> <span class="n">In</span> <span class="n">order</span> <span class="n">to</span> <span class="k">do</span> <span class="n">this</span> <span class="n">we</span> <span class="n">had</span> <span class="n">to</span> <span class="n">deploy</span> <span class="n">no</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">additional</span> <span class="n">machines</span> <span class="n">and</span> <span class="n">no</span> <span class="n">special</span> <span class="n">hardware</span><span class="p">.</span> <span class="n">On</span> <span class="n">our</span> <span class="n">production</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">frontend</span> <span class="n">machines</span><span class="p">,</span> <span class="o">**</span><span class="n">SSL</span> <span class="n">accounts</span> <span class="k">for</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span><span class="o">%</span> <span class="n">of</span> <span class="n">the</span> <span class="n">CPU</span> <span class="n">load</span><span class="p">,</span><span class="o">**</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">10</span> <span class="n">KB</span> <span class="n">of</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">memory</span> <span class="n">per</span> <span class="n">connection</span><span class="p">,</span> <span class="n">and</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">2</span><span class="o">%</span> <span class="n">of</span> <span class="n">network</span> <span class="n">overhead</span><span class="err">…</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">If</span> <span class="n">you</span> <span class="n">stop</span> <span class="n">reading</span> <span class="n">now</span> <span class="n">you</span> <span class="n">only</span> <span class="n">need</span> <span class="n">to</span> <span class="n">remember</span> <span class="n">one</span> <span class="nl">thing</span><span class="p">:</span> <span class="n">SSL</span> <span class="n">is</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">not</span> <span class="n">computationally</span> <span class="n">expensive</span> <span class="n">any</span> <span class="n">more</span><span class="p">.</span><span class="err">”</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="o">--</span> <span class="n">Overclocking</span> <span class="n">SSL</span> <span class="n">blog</span> <span class="n">post</span> <span class="n">by</span> <span class="n">Adam</span> <span class="n">Langley</span> <span class="p">(</span><span class="n">Google</span>   <span class="nl">https</span><span class="p">:</span><span class="c1">//www.imperialviolet.org/2010/06/25/overclocking-ssl.html )</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">google</span><span class="err">的优化：</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//bit.ly/gottls&amp;gt;</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//www.imperialviolet.org/2010/06/25/overclocking-ssl.html</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//istlsfastyet.com/</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf</span>
</span><span class='line'><span class="nl">http</span><span class="p">:</span><span class="c1">//chimera.labs.oreilly.com/books/1230000000545/ch04.html</span>
</span><span class='line'>
</span><span class='line'><span class="o">!</span><span class="p">[][</span><span class="n">google_ecdsa_chacha20</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">baidu</span><span class="err">的经验：</span>
</span><span class='line'><span class="nl">http</span><span class="p">:</span><span class="c1">//op.baidu.com/2015/04/https-index/</span>
</span><span class='line'>
</span><span class='line'><span class="n">aws</span><span class="err">的配置</span>
</span><span class='line'><span class="nl">http</span><span class="p">:</span><span class="c1">//docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-https-load-balancers.html</span>
</span><span class='line'>
</span><span class='line'><span class="err">可以参考</span><span class="n">byron</span><span class="err">之前给出的一个介绍</span><span class="n">nginx</span><span class="err">配置的文章</span> <span class="p">[</span><span class="n">Nginx</span><span class="err">下配置高性能，高安全性的</span><span class="n">https</span> <span class="n">TLS</span><span class="err">服务</span><span class="p">][</span><span class="n">nginx_https_deploy</span><span class="p">]</span><span class="err">，本人提供售后咨询服务，哈哈。</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">CipherSuite</span><span class="err">配置</span><span class="p">(</span><span class="n">Mozilla</span><span class="err">的权威配置</span><span class="p">)</span>
</span><span class='line'><span class="nl">https</span><span class="p">:</span><span class="c1">//wiki.mozilla.org/Security/Server_Side_TLS</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">hardenedlinux</span><span class="err">的这个文档：</span><span class="n">SSL</span><span class="o">/</span><span class="n">TLS</span><span class="err">部署最佳实践</span><span class="n">v1</span><span class="mf">.4</span><span class="o">:</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//hardenedlinux.org/jekyll/update/2015/07/28/ssl-tls-deployment-1.4.html&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">全站切</span><span class="n">https</span><span class="err">，值得关注的一个点是</span><span class="n">cdn</span><span class="err">切</span><span class="n">https</span><span class="err">，如果</span><span class="n">cdn</span><span class="err">资源不使用</span><span class="n">cdn</span><span class="err">提供商的域名的话，之前会有私钥必须得交给</span><span class="n">cdn</span><span class="err">提供商的安全风险，但是幸运的是</span><span class="n">cloudflare</span><span class="err">提出了</span><span class="n">keyless</span> <span class="n">ssl</span><span class="err">方案，解决了这个问题</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/cloudflare/keyless&amp;gt;，cdn切https应该可以借鉴。</span>
</span><span class='line'>
</span><span class='line'><span class="err">有时候我们会用</span><span class="n">wireshark</span><span class="err">之类的工具抓包，来调试</span><span class="n">http</span><span class="err">协议，但是切换到</span><span class="n">https</span><span class="err">后，都变成二进制密文了，直接抓包是行不通了，那怎么调试协议呢？</span>
</span><span class='line'><span class="err">有个简单的解决办法：</span><span class="p">[</span><span class="err">小技巧</span><span class="o">:</span><span class="err">如何在</span><span class="n">wireshark</span><span class="err">里查看</span><span class="n">https</span><span class="err">的明文数据</span><span class="p">][</span><span class="n">wireshark_https_dump</span><span class="p">]</span>
</span><span class='line'><span class="err">参考</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format&amp;gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#五. 更多的加密通信协议case：QUIC，iMessage，TextSecure, otr,  ios HomeKit，libsodium</span>
</span><span class='line'>
</span><span class='line'><span class="err">时间有限，下面有些协议就没有做详细的分析了，读者自己去看吧。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###1. QUIC</span>
</span><span class='line'>
</span><span class='line'><span class="o">**</span><span class="n">QUIC</span> <span class="o">=</span>  <span class="n">TCP</span><span class="o">+</span><span class="n">TLS</span><span class="o">+</span><span class="n">SPDY</span><span class="o">**</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//www.chromium.org/quic&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">其中的</span> <span class="n">crypto</span> <span class="n">design</span><span class="err">文档是本文关注的。</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//network.chinabyte.com/162/13361162.shtml&amp;gt;</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//blog.chromium.org/2015/04/a-quic-update-on-googles-experimental.html&amp;gt;</span>
</span><span class='line'><span class="err">截止</span><span class="mf">2015.04</span><span class="err">，从</span><span class="n">Chrome</span><span class="err">到</span><span class="n">Google</span> <span class="n">server</span><span class="err">的流量的大概</span><span class="mi">50</span><span class="o">%</span> <span class="err">是走的</span><span class="n">QUIC</span><span class="err">协议，而且还在不断增加。</span>
</span><span class='line'><span class="err">据说减少了</span><span class="n">YouTube</span><span class="err">的</span><span class="mi">30</span><span class="o">%</span><span class="err">的卡顿。</span>
</span><span class='line'>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/devsisters/libquic&amp;gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">QUIC</span><span class="err">值得借鉴的地方有：</span><span class="n">crypto</span><span class="err">算法选择，</span><span class="mi">0</span><span class="o">-</span><span class="n">RTT</span><span class="err">的实现方法，证书压缩省流量</span>
</span><span class='line'>
</span><span class='line'><span class="n">QUIC</span><span class="err">的</span><span class="n">crypto</span><span class="err">算法选择：</span>
</span><span class='line'><span class="err">密钥交换算法只有</span><span class="mi">2</span><span class="err">种：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Key exchange methods</span>
</span><span class='line'><span class="k">const</span> <span class="n">QuicTag</span> <span class="n">kP256</span> <span class="o">=</span> <span class="n">TAG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">P</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">2</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">5</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">6</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;);</span>   <span class="c1">// ECDH, Curve P-256</span>
</span><span class='line'><span class="k">const</span> <span class="n">QuicTag</span> <span class="n">kC255</span> <span class="o">=</span> <span class="n">TAG</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">C</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">2</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">5</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="mi">5</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;);</span>   <span class="c1">// ECDH, Curve25519</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>对称加密只使用AEAD，并且只有2种：
<code>cpp
// AEAD algorithms
const QuicTag kNULL = TAG('N', 'U', 'L', 'N');   // null algorithm
const QuicTag kAESG = TAG('A', 'E', 'S', 'G');   // AES128 + GCM-12
const QuicTag kCC12 = TAG('C', 'C', '1', '2');   // ChaCha20 + Poly1305
</code></p>

<p>证书类型2种，RSA证书， 和 RSA/ECDSA双证书
<code>cpp
// Proof types (i.e. certificate types)
const QuicTag kX509 = TAG(‘X’, ‘5’, ‘0’, ‘9’);   // X.509 certificate, all key types
const QuicTag kX59R = TAG(‘X’, ‘5’, ‘9’, ‘R’);   // X.509 certificate, RSA keys only
</code></p>

<p> handshake的结果是为了协商出来下面这些参数：</p>

<pre><code class="cpp">// Parameters negotiated by the crypto handshake.
struct NET_EXPORT_PRIVATE QuicCryptoNegotiatedParameters {
  // Initializes the members to 0 or empty values.
  QuicCryptoNegotiatedParameters();
  ~QuicCryptoNegotiatedParameters();

  QuicTag key_exchange;
  QuicTag aead;
  std::string initial_premaster_secret;
  std::string forward_secure_premaster_secret;
  // subkey_secret is used as the PRK input to the HKDF used for key extraction.
  std::string subkey_secret;
  CrypterPair initial_crypters;
  CrypterPair forward_secure_crypters;
  // Normalized SNI: converted to lower case and trailing '.' removed.
  std::string sni;
  std::string client_nonce;
  std::string server_nonce;
  // hkdf_input_suffix contains the HKDF input following the label: the
  // ConnectionId, client hello and server config. This is only populated in the
  // client because only the client needs to derive the forward secure keys at a
  // later time from the initial keys.
  std::string hkdf_input_suffix;
  // cached_certs contains the cached certificates that a client used when
  // sending a client hello.
  std::vector&lt;std::string&gt; cached_certs;
  // client_key_exchange is used by clients to store the ephemeral KeyExchange
  // for the connection.
  scoped_ptr&lt;KeyExchange&gt; client_key_exchange;
  // channel_id is set by servers to a ChannelID key when the client correctly
  // proves possession of the corresponding private key. It consists of 32
  // bytes of x coordinate, followed by 32 bytes of y coordinate. Both values
  // are big-endian and the pair is a P-256 public key.
  std::string channel_id;

  // Used when generating proof signature when sending server config updates.
  bool x509_ecdsa_supported;

  // Used to generate cert chain when sending server config updates.
  std::string client_common_set_hashes;
  std::string client_cached_cert_hashes;
};
</code></pre>

<p>可以看到：QUIC内置支持sni
而且区分 initial_premaster_secret 和 forward_secure_premaster_secret。</p>

<p>先这样吧，后续再分析。</p>

<a name="L2..apple.ios.iMessage"></a>
<h3>2. apple ios iMessage</h3>

<p>iOS Security Guide : <a href="https://www.apple.com/business/docs/iOS_Security_Guide.pdf">https://www.apple.com/business/docs/iOS_Security_Guide.pdf</a></p>

<p>Apple 的 iMessage系统的密码学安全机制设计，端到端加密，前向安全(PFS)，签名使用ECDSA P-256，非对称加密使用RSA 1280 bit，苹果自己维护一个 用户名&ndash;》公钥 的目录服务。</p>

<p>iMessage在注册时，给每个用户生成一对 RSA-1280 密钥用作非对称加密，一对 NIST P-256 ECDSA 密钥用作签名，2个私钥本地保存，公钥上传给Apple的目录服务器(IDS)。</p>

<p>当要发送消息的时候，根据接收方的用户名，从IDS里面找到RSA公钥 和 APNS 地址。然后随机生成 128 比特密钥，用 AES-CTR-128 加密要发送的消息，用接收方的 RSA 1280 公钥，使用 OAEP 填充加密 128比特aes密钥。然后拼接 aes密文和rsa密文，对结果使用发送方的 ECDSA 私钥，用sha1算一次数字签名。
然后把aes密文，rsa密文，数字签名拼接起来，发给 APNS 投递给接收方。</p>

<p>如果要发送大文件，就生成一个key，用 aes-ctr-256 加密文件，并计算一个sha1，然后把key和sha1 放入消息里面发送。</p>

<blockquote><p>Apple iMessage is a messaging service for iOS devices and Mac
computers. iMessage supports text and attachments such as photos,
contacts, and locations.Apple does not log messages or attachments, and their
contents are protected by end-to-end encryption so no one but the
sender and receiver can access them. Apple cannot decrypt the data.
&hellip;
When a user turns on iMessage on a device, the device generates two
pairs of keys for use with the service: an RSA 1280-bit key for
encryption and an ECDSA 256-bit key on the NIST P-256 curve for
signing. The private keys for both key pairs are saved in the device’s
keychain and the public keys are sent to Apple’s directory service
(IDS), where they are associated with the user’s phone number or email
address, along with the device’s APNs address.
&hellip;</p>

<p>Users start a new iMessage conversation by entering an address or name.
If the user enters a name, the device first utilizes
 the user’s Contacts app to gather the phone numbers and email
 addresses associated with that name, then gets the public keys and
 APNs addresses from the IDS. The user’s outgoing message is
 individually encrypted for each of the receiver’s devices. The public
 RSA encryption keys of the receiving devices are retrieved from IDS.
 For each receiving device, the sending device generates a random
 128-bit key and encrypts the message with it using AES in CTR mode.
 This per-message AES key is encrypted using RSA-OAEP to the public key
 of the receiving device. The combination of the encrypted message text
 and the encrypted message key is then hashed with SHA-1, and the hash
 is signed with ECDSA using the sending device’s private signing key.
 The resulting messages, one for each receiving device, consist of the
 encrypted message text, the encrypted message key, and the sender’s
 digital signature. They are then dispatched to the APNs for delivery.
 Metadata, such as the timestamp and APNs routing information, is not
 encrypted. Communication with APNs is encrypted using a forwardsecret
 TLS channel.</p>

<p> APNs can only relay messages up to 4 KB or 16 KB in size, depending
on iOS version. If the message text is too long, or if an attachment
such as a photo is included, the attachment is encrypted using AES in
CTR mode with a randomly generated 256-bit key and uploaded to iCloud.
The AES key for the attachment, its URI (Uniform Resource Identifier),
and a SHA-1 hash of its encrypted form are then sent to the recipient
as the contents of an iMessage, with their confidentiality and
integrity protected through normal iMessage encryption,</p></blockquote>

<a name="L3..apple.ios.HomeKit"></a>
<h3>3. apple ios HomeKit</h3>

<p>iOS Security Guide : <a href="https://www.apple.com/business/docs/iOS_Security_Guide.pdf">https://www.apple.com/business/docs/iOS_Security_Guide.pdf</a></p>

<p>Apple的HomeKit，是 WWDC2014 上提出的 iot 智能家居开发平台 （iot啊，目前最火的概念啊，各种高大上啊）。
可以看到 HomeKit 作为一个全新的协议， 抛弃了历史遗留算法，直接采用了目前最先进的算法</p>

<p>HomeKit 密码学安全机制的设计：
使用Ed25519做 公钥签名/验证，使用 SRP(3072 bit) 做来在iOS设备和HomeKit配件之间交换密码并做认证，使用 ChaCha20-Poly1305做对称加密，
使用HKDF-SHA512做密钥拓展。每个session的开始用Station-to-Station 协议做密钥协商和认证，
随后使用Curve25519做密钥协商，生成共享key。</p>

<blockquote><p> HomeKit provides a home automation infrastructure that utilizes
 iCloud and iOS security to protect and synchronize private data
 without exposing it to Apple.<br/>
 &hellip;
 HomeKit identity and
 security are based on Ed25519 public-private key pairs. An Ed25519 key
 pair is generated on the iOS device for each user for HomeKit, which
 becomes his or her HomeKit identity. It is used to authenticate
 communication between iOS devices, and between iOS devices and
 accessories.<br/>
 &hellip;  <br/>
 Communication with HomeKit accessories
 HomeKit accessories generate their own Ed25519 key pair for use in
 communicating with iOS devices.
 To establish a  relationship between an iOS device and a HomeKit accessory, keys are
 exchanged using Secure Remote Password (3072-bit) protocol, utilizing
 an 8-digit code provided by the accessory’s manufacturer and entered
 on the iOS device by the user, and then encrypted using
 ChaCha20-Poly1305 AEAD with HKDF-SHA-512-derived keys. The accessory’s
 MFi certification is also verified during setup.  When the iOS device
 and the HomeKit accessory communicate during use, each authenticates
 the other utilizing the keys exchanged in the above process. Each
 session is established using the Station-to-Station protocol and is
 encrypted with HKDF-SHA-512 derived keys based on per-session
 Curve25519 keys. This applies to both IP-based and Bluetooth Low
 Energy accessories.</p></blockquote>

<a name="L4..TextSecure"></a>
<h3>4. TextSecure</h3>

<p>TextSecure是一个端到端im加密通信协议，由WhisperSystem公司设计，目前whatsapp和WhisperSystem公司有合作，看网上资料，2014年11月开始，whatsapp已经开始使用TextSecure协议来做端到端加密(消息来源:  <a href="https://whispersystems.org/blog/whatsapp/">https://whispersystems.org/blog/whatsapp/</a>
<a href="http://www.wired.com/2014/11/whatsapp-encrypted-messaging/">http://www.wired.com/2014/11/whatsapp-encrypted-messaging/</a>)。</p>

<p>TextSecure V2 协议：
<a href="https://github.com/WhisperSystems/TextSecure/wiki/ProtocolV2">https://github.com/WhisperSystems/TextSecure/wiki/ProtocolV2</a>
<a href="https://github.com/trevp/axolotl/wiki">https://github.com/trevp/axolotl/wiki</a>
<a href="https://whispersystems.org/blog/advanced-ratcheting/">https://whispersystems.org/blog/advanced-ratcheting/</a></p>

<p>The TextSecure encrypted messaging protocol 是otr的一个衍生协议，主要有2个不同点:
1.ECDSA代替DSA
2.某些数据结构压缩</p>

<a name="L5..otr......."></a>
<h3>5. otr 协议</h3>

<p>标准文档见：<a href="https://otr.cypherpunks.ca/Protocol-v3-4.0.0.html">https://otr.cypherpunks.ca/Protocol-v3-4.0.0.html</a></p>

<p>open kullo协议
<a href="https://www.kullo.net/protocol/">https://www.kullo.net/protocol/</a></p>

<p>Choice of algorithms
Whenever we write about symmetric or asymmetric encryption or signatures, we mean the following algorithms, modes and parameters:</p>

<p>symmetric encryption: AES-256 in GCM mode
asymmetric encryption: RSA-4096 with OAEP(SHA-512) padding
asymmetric signatures: RSA-4096 with PSS(SHA-512) padding</p>

<a name="L6...libsodium.NaCL"></a>
<h3>6.  libsodium/NaCL</h3>

<p>libsodium/NaCL 值得重点介绍，大力推广 。
新的没有兼容包袱的系统，都值得考虑用 NaCL来代替 openssl。
libsodium是对NaCL的封装，NaCL大有来头，作者 DJB 是密码学领域的权威人物，chacha20，Curve25519 的作者 。
没有历史包袱的项目，强烈建议使用 libsodium/NaCL。</p>

<p>这篇文章介绍了NaCL和openssl相比的各方面改进
<a href="http://cr.yp.to/highspeed/coolnacl-20120725.pdf">http://cr.yp.to/highspeed/coolnacl-20120725.pdf</a>
<a href="https://cryptojedi.org/peter/data/tenerife-20130121.pdf">https://cryptojedi.org/peter/data/tenerife-20130121.pdf</a>
<a href="http://nacl.cr.yp.to/">http://nacl.cr.yp.to/</a></p>

<a name="L7..Tox.im"></a>
<h3>7. Tox.im</h3>

<p>一款实用NaCL的端到端加密im
<a href="https://github.com/irungentoo/toxcore/blob/master/docs/updates/Crypto.md">https://github.com/irungentoo/toxcore/blob/master/docs/updates/Crypto.md</a></p>

<a name="L8..CurveCP"></a>
<h3>8. CurveCP</h3>

<p>CurveCP值得重点介绍，
<a href="http://curvecp.org/security.html">http://curvecp.org/security.html</a></p>

<blockquote><p>CurveCP的安全考量：
Confidentiality and integrity
server authentication?
client authentication?
replay attacks?
man-in-the-middle attacks?
passive forward secrecy?
active forward secrecy?
against traffic analysis? internet destination, exact timing, and approximate length of each packet that you send.</p>

<p>Availability availability, i.e., to make denial-of-service attacks more difficult.
Blind amplification
Unauthenticated memory consumption
CPU consumption</p>

<p>Efficiency
CPU overhead
Network overhead without packet loss
Latency without packet loss</p>

<p>Decongestion</p></blockquote>

<a name="L9..tcpcrypt"></a>
<h3>9. tcpcrypt</h3>

<p><a href="http://tcpcrypt.org/">http://tcpcrypt.org/</a></p>

<a name="L10.noise"></a>
<h3>10.noise</h3>

<p><a href="https://github.com/trevp/noise/wiki">https://github.com/trevp/noise/wiki</a></p>

<a name="L11.tcpcrypt"></a>
<h3>11.tcpcrypt</h3>

<p><a href="http://tcpcrypt.org/">http://tcpcrypt.org/</a></p>

<a name="L12..netflix.MSL"></a>
<h3>12. netflix MSL</h3>

<p><a href="http://techblog.netflix.com/2014/10/message-security-layer-modern-take-on.html">http://techblog.netflix.com/2014/10/message-security-layer-modern-take-on.html</a></p>

<p><a href="http://www.infoq.com/cn/news/2014/11/netflix-safe-communication">http://www.infoq.com/cn/news/2014/11/netflix-safe-communication</a></p>

<a name="L12.Amazon.KMS............................."></a>
<h3>12.Amazon KMS 密钥管理服务 白皮书</h3>

<p><a href="https://d0.awsstatic.com/whitepapers/KMS-Cryptographic-Details.pdf">https://d0.awsstatic.com/whitepapers/KMS-Cryptographic-Details.pdf</a></p>

<p>值得注意和借鉴的点：</p>

<ul>
<li>对称加密算法选择了 AES-GCM-256</li>
<li>数字签名有2种：ECDSA，RSA，

<ul>
<li> ECDSA 的曲线选择了 secp384r1 （P384），hash 算法选择了 SHA384</li>
<li> RSA 选择2048位，签名体制选择 RSASSA-PSS，hash 算法选择了 SHA256</li>
</ul>
</li>
<li>密钥协商，使用ECDH，选择曲线 secp384r1 (P384)，有2种用法

<ul>
<li> one-pass ECDH.</li>
<li> ECDHE</li>
</ul>
</li>
<li>电子信封加密，KMS内置了电子信封。</li>
</ul>


<p> 电子信封就是，你预先知道对方的长期公钥，你有一个消息要发送给对方，所以你生成一个随机的msgKey,然后 ciphertext = Encrypt(msgKey, message), 并且用对方的公钥加密 msgKey： encKey = Encrypt(k, msgKey),  最后把(encKey, ciphertext) 发给对方，这样，只有公钥对应私钥的拥有者才能打开信封。典型应用比如 OpenPGP。</p>

<p>其中的 one-pass ECDH，大概意思是：
发起方有一对长期使用的签名密钥对，发起方生成一对临时的 ECDH 密钥，用自己的长期签名密钥签署 临时ECDH公钥。对端有一对长期 ECDH 密钥，收到发起方发来的 ECDH 公钥后，验证签名，并且用自己的长期ECDH私钥和收到的公钥协商出共享密钥。
整个过程中，只是用了一对临时ECDH密钥，2对长期密钥。</p>

<p>ECDHE就是比较典型的ECDHE了，和TLS用法一样：双方都持有一对长期使用的签名密钥对，并拥有对方的签名公钥，然后分别生成一对临时ECDH密钥，用自己的签名私钥签署ECDH公钥，把得出的签名和ECDH公钥发给对方，
双方收到对方的ECDH公钥后，验证签名，通过后用对方的ECDH公钥和自己的ECDH私钥协商出共享密钥。DONE。</p>

<p>白皮书中还举了几个例子，</p>

<a name="L......TLS.........................--..............................."></a>
<h1>六.  TLS协议给我们的启发 &ndash; 现代加密通信协议设计</h1>

<p>在看了这么多的分析和案例之后，我们已经可以归纳出加密通信协议设计的普遍问题，和常见设计决策，</p>

<p>设计决策点：</p>

<ol>
<li><p>四类基础算法 加密/MAC/签名/密钥交换 如何选择？
对称加密目前毫无疑问应该直接用aead，最佳选择就是 aes-128-gcm/aes-256-gcm/chacha20-poly1305了
数字签名/验证方案，如果是移动互联网，应该考虑直接放弃 RSA，考虑 P-256 的 ECDSA 公钥证书，或者更进一步的 ed25519 公钥证书。
密钥交换算法，目前最佳选择就是 curve25519，或者 P-256。</p></li>
<li><p>对称加密算法+认证算法，如何选择？或者直接用aead？</p></li>
<li><p>签名算法如何选择？RSA or ECDSA or Ed25519？</p></li>
<li><p>考虑将来的算法调整，要加版本号机制吗？
建议是加上，起码在密钥协商的步骤，要加上版本号。便于将来更新算法。</p></li>
<li><p>RSA用作密钥交换是一个好的选择吗？考虑PFS
建议直接放弃RSA，RSA服务器端性能比ECDSA更差，签名更大费流量，而且没有前向安全性，给私钥保管带来更大风险。</p></li>
<li><p>自建PKI，是个好的选择吗？crl如何解决？
自建PKI可以做到更安全，比如简单的客户端内置数字签名公钥。可是当需要紧急吊销一个证书的时候，只能通过紧急发布新版客户端来解决。</p></li>
<li><p>必须用糟糕的openssl吗？or something better？crypto++,botan, nacl/libsodium, polarssl？libsodium: ed25519+curve2519+chacha20+poly1305</p></li>
<li><p>重放攻击如何解决？某种seq？或者nonce如何生成？</p></li>
<li><p>握手过程被中间人篡改的问题怎么解决？</p></li>
<li><p>性能：私钥运算的cpu消耗可以承受吗？加上某种cache？
要解决私钥运算的高cpu消耗，必然就需要 session ticket/session id 这种cache机制。显然session ticket 更好</p></li>
<li><p>延迟：密钥协商需要几个rtt？最少多少？加上cache后？和tcp对比如何</p></li>
<li><p>TLS的性能(主要指服务器cpu消耗)还有空间可以压榨吗？我能设计一个性能更牛逼的吗？</p></li>
</ol>


<a name="L..................................."></a>
<h1>七. 附录：密码学基础概念</h1>

<p>本文已经很长了，基础概念的内容更多，再展开介绍就太长了，下面就列一下点，贴一下参考资料，就先这样,以后再说吧。</p>

<p>当然，最好的资料是下面列的书。</p>

<a name="L1..................block.cipher"></a>
<h2>1. 块加密算法 block cipher</h2>

<p> AES 等</p>

<p>《AES后分组密码的研究现状 及发展趋势》
<a href="http://www.ccf.org.cn/resources/1190201776262/2010/04/15/019026.pdf">http://www.ccf.org.cn/resources/1190201776262/2010/04/15/019026.pdf</a></p>

<p>aead的介绍（作者是大神）
<a href="https://www.imperialviolet.org/2015/05/16/aeads.html">https://www.imperialviolet.org/2015/05/16/aeads.html</a></p>

<p>3种组合方式之争
<a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/</a></p>

<p>CBC模式+MAC-then-encrypt的padding oracle 攻击, tls POODLE 漏洞
<a href="http://drops.wooyun.org/papers/3194">http://drops.wooyun.org/papers/3194</a>
<a href="https://defuse.ca/blog/recovering-cbc-mode-iv-chosen-ciphertext.html">https://defuse.ca/blog/recovering-cbc-mode-iv-chosen-ciphertext.html</a></p>

<p>128 bit 和 256 bit key size之争
<a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html">https://www.schneier.com/blog/archives/2009/07/another_new_aes.html</a></p>

<p>nist 对 aes gcm 的技术标准，官方权威文档：
<a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf">http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/gcm/gcm-spec.pdf</a></p>

<p>一个gcm的调用范例
<a href="https://github.com/facebook/conceal/blob/master/native/crypto/gcm_util.c">https://github.com/facebook/conceal/blob/master/native/crypto/gcm_util.c</a></p>

<p>DES
1天之内破解DES（2008年）
<a href="http://www.sciengines.com/company/news-a-events/74-des-in-1-day.html">http://www.sciengines.com/company/news-a-events/74-des-in-1-day.html</a></p>

<p>iPhone 5S开始，A7芯片也有了aes硬件指令 (ARMv8 指令集)，有825%的性能提升：
<a href="http://www.anandtech.com/show/7335/the-iphone-5s-review/4">http://www.anandtech.com/show/7335/the-iphone-5s-review/4</a></p>

<a name="L2..................stream.cipher"></a>
<h2>2. 流加密算法 stream cipher</h2>

<p> RC4，ChaCha20 等</p>

<p> 序列密码发展现状
<a href="http://www.ccf.org.cn/resources/1190201776262/2010/04/15/019018.pdf">http://www.ccf.org.cn/resources/1190201776262/2010/04/15/019018.pdf</a></p>

<p>rc4 : <a href="http://www.rc4nomore.com/">http://www.rc4nomore.com/</a></p>

<p>[RC4加密已不再安全，破解效率极高（含视频）]  <a href="http://www.freebuf.com/news/72622.html">http://www.freebuf.com/news/72622.html</a></p>

<a name="L3..Hash.......hash.funtion"></a>
<h2>3. Hash函数 hash funtion</h2>

<p>  MD5，sha1，sha256，sha512 , ripemd 160，poly1305 等</p>

<p>MD5被碰撞:
<a href="http://natmchugh.blogspot.com/2014/10/how-i-created-two-images-with-same-md5.html">http://natmchugh.blogspot.com/2014/10/how-i-created-two-images-with-same-md5.html</a></p>

<p><a href="http://blog.avira.com/md5-the-broken-algorithm/">http://blog.avira.com/md5-the-broken-algorithm/</a></p>

<a name="L4........................message.authentication.code"></a>
<h2>4. 消息验证码函数 message authentication code</h2>

<p>  HMAC-sha256，AEAD 等</p>

<p>为什么要用MAC
<a href="http://www.happybearsoftware.com/you-are-dangerously-bad-at-cryptography.html">http://www.happybearsoftware.com/you-are-dangerously-bad-at-cryptography.html</a></p>

<p>Flickr的漏洞案例：
<a href="http://netifera.com/research/flickr_api_signature_forgery.pdf">http://netifera.com/research/flickr_api_signature_forgery.pdf</a></p>

<p><a href="http://www.ietf.org/rfc/rfc2104.txt">http://www.ietf.org/rfc/rfc2104.txt</a></p>

<a name="L5...............key.exchange"></a>
<h2>5. 密钥交换 key exchange</h2>

<p> DH，ECDH，RSA，PFS方式的（DHE，ECDHE）等</p>

<p><a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a></p>

<p>关于 前向安全性( Perfect Forward Secrecy )
<a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html</a></p>

<p><a href="http://www.cryptopp.com/wiki/Elliptic_Curve_Cryptography">http://www.cryptopp.com/wiki/Elliptic_Curve_Cryptography</a></p>

<p>google对openssl里面的椭圆曲线的优化：
<a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37376.pdf">http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37376.pdf</a></p>

<p><a href="http://www.math.brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf">http://www.math.brown.edu/~jhs/Presentations/WyomingEllipticCurve.pdf</a></p>

<p>ripple从nistp256k1曲线迁移到ed25519
<a href="https://ripple.com/uncategorized/curves-with-a-twist/">https://ripple.com/uncategorized/curves-with-a-twist/</a></p>

<p>openssh 6.5 开始支持 ed25519, curve25519, chacha20-poly1305
<a href="http://www.openssh.org/txt/release-6.5">http://www.openssh.org/txt/release-6.5</a></p>

<a name="L6...............public-key.encryption"></a>
<h2>6. 公钥加密 public-key encryption</h2>

<p> RSA，rabin-williams 等</p>

<p>RSA入门必读（斯坦福，普渡的课件）：
<a href="http://crypto.stanford.edu/~dabo/courses/cs255_winter07/rsa.ppt">http://crypto.stanford.edu/~dabo/courses/cs255_winter07/rsa.ppt</a>
<a href="https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture12.pdf">https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture12.pdf</a></p>

<p>PKCS1 标准，应用RSA必读：
<a href="https://www.ietf.org/rfc/rfc3447">https://www.ietf.org/rfc/rfc3447</a></p>

<p>RSA 的公钥为什么比AES的key长？
<a href="http://crypto.stackexchange.com/questions/8687/security-strength-of-rsa-in-relation-with-the-modulus-size">http://crypto.stackexchange.com/questions/8687/security-strength-of-rsa-in-relation-with-the-modulus-size</a></p>

<p><a href="http://cryptofails.blogspot.ca/2013/07/saltstack-rsa-e-d-1.html">http://cryptofails.blogspot.ca/2013/07/saltstack-rsa-e-d-1.html</a></p>

<p>使用什么padding？ OAEP，为什么不要用PKCS V1.5</p>

<p><a href="http://stackoverflow.com/questions/2991603/pkcs1-v2-0-encryption-is-usually-called-oaep-encryption-where-can-i-confirm-i">http://stackoverflow.com/questions/2991603/pkcs1-v2-0-encryption-is-usually-called-oaep-encryption-where-can-i-confirm-i</a></p>

<p><a href="http://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5">http://crypto.stackexchange.com/questions/12688/can-you-explain-bleichenbachers-cca-attack-on-pkcs1-v1-5</a>
<a href="http://en.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack">http://en.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack</a></p>

<p>PKCS #1 &ndash; #15标准协议官方网站：
<a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm</a>
<a href="http://arxiv.org/pdf/1207.5446v1.pdf">http://arxiv.org/pdf/1207.5446v1.pdf</a></p>

<p>blinding 一种实现上的技术，用来解决 timing 侧通道攻击的问题
<a href="https://en.wikipedia.org/wiki/Blinding_">https://en.wikipedia.org/wiki/Blinding_</a>(cryptography)
<a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf">http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf</a></p>

<p>Twenty Years of Attacks on the RSA Cryptosystem:
<a href="http://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf">http://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf</a></p>

<p> 电子信封(digital envelope)
<a href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/what-is-a-digital-envelope.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/what-is-a-digital-envelope.htm</a></p>

<p>在openssl的evp接口中有直接支持：
<a href="https://wiki.openssl.org/index.php/EVP_Asymmetric_Encryption_and_Decryption_of_an_Envelope">https://wiki.openssl.org/index.php/EVP_Asymmetric_Encryption_and_Decryption_of_an_Envelope</a></p>

<a name="L7.....................signature.algorithm"></a>
<h2>7. 数字签名算法 signature algorithm</h2>

<p>RSA，DSA，ECDSA (secp256r1 , ed25519) 等</p>

<p>三大公钥体制：RSA，DSA，ECDSA
RSA目前是主流，占据绝大多数市场份额
DSA已经被废弃
ECDSA是未来的趋势，例如bitcoin就用ECDSA
<a href="https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/">https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/</a>
<a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a></p>

<a name="L8.....................key.derivation.function"></a>
<h2>8. 密码衍生函数 key derivation function</h2>

<p> TLS-12-PRF(SHA-256) , bcrypto，scrypto，pbkdf2 等</p>

<p>hkdf：        <a href="http://tools.ietf.org/html/rfc5869">http://tools.ietf.org/html/rfc5869</a>
<a href="https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/">https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/</a></p>

<a name="L9.....................random.number.generators"></a>
<h2>9. 随机数生成器 random number generators</h2>

<p>  /dev/urandom 等</p>

<p><a href="https://blog.helong.info/blog/2015/06/05/modern-crypto/">现代密码学实践指南[2015年]</a></p>

<a name="L...................."></a>
<h1>八. 参考文献：</h1>

<a name="TLS.SSL.......RFC........."></a>
<h3>TLS/SSL 相关RFC及标准</h3>

<ul>
<li><a href="https://tools.ietf.org/html/rfc5246">TLS 1.2</a></li>
<li><a href="https://github.com/tlswg/tls13-spec">TLS 1.3 draft specification</a></li>
<li><a href="https://tools.ietf.org/html/rfc5288">AES GCM for TLS</a></li>
<li><a href="https://tools.ietf.org/html/rfc4492">ECC cipher suites for TLS</a></li>
<li><a href="https://tools.ietf.org/html/rfc6066">TLS extensions</a></li>
<li><a href="https://tools.ietf.org/html/rfc7301">Application-Layer Protocol Negotiation Extension</a></li>
<li><a href="https://tools.ietf.org/html/rfc4210">X.509 PKI</a></li>
<li><a href="https://tools.ietf.org/html/rfc5280">X.509 PKI and CRLs</a></li>
<li><a href="http://csrc.nist.gov/groups/ST/toolkit/index.html">美国国家标准局NIST 的密码学标准</a></li>
<li><a href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">NIST SP 800-90A </a></li>
<li><a href="https://www.nsa.gov/ia/programs/suiteb_cryptography/">nsa 的 SuiteB 密码学标准</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS on wikipedia</a></li>
</ul>


<a name="L.................."></a>
<h3>协议分析文章</h3>

<ul>
<li><a href="http://www.root.org/talks/TLS_Design20071129_2.pdf">http://www.root.org/talks/TLS_Design20071129_2.pdf</a></li>
<li><a href="http://www-brs.ub.ruhr-uni-bochum.de/netahtml/HSS/Diss/MeyerChristopher/diss.pdf">20 Years of SSL/TLS Research An Analysis of the Internet&rsquo;s Security Foundation</a></li>
<li><a href="https://www.slideshare.net/yassl/securing-data-in-transit">https://www.slideshare.net/yassl/securing-data-in-transit</a></li>
<li><a href="http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work">http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work</a></li>
<li><a href="https://technet.microsoft.com/en-us/library/cc785811(v=ws.10">SSL/TLS in Detail</a>.aspx>)</li>
<li><a href="http://www.spiegel.de/media/media-35511.pdf">SSL/TLS</a></li>
<li><a href="https://hynek.me/talks/tls/">The Sorry State Of SSL</a></li>
<li><a href="http://hyperelliptic.org/internetcrypto/OpenSSLPresentation.pdf">What&rsquo;s the matter with TLS?</a></li>
<li><a href="http://blog.csdn.net/CaesarZou/article/details/9331993">http://blog.csdn.net/CaesarZou/article/details/9331993</a></li>
<li>&lt;tools.ietf.org/html/rfc4210>)</li>
<li><a href="https://tools.ietf.org/html/rfc5280">X.509 PKI and CRLs</a></li>
<li><a href="http://luca.ntop.org/Teaching/Appunti/asn1.html">Layman&rsquo;s Guide to ASN.1</a></li>
</ul>


<a name="L........................"></a>
<h3>实际部署调优相关</h3>

<ul>
<li><a href="https://bit.ly/gottls">https://bit.ly/gottls</a></li>
<li><a href="https://istlsfastyet.com/">https://istlsfastyet.com/</a></li>
<li><a href="https://www.imperialviolet.org/">https://www.imperialviolet.org/</a></li>
<li><a href="https://letsencrypt.org/">https://letsencrypt.org/</a></li>
<li><a href="http://chimera.labs.oreilly.com/books/1230000000545/ch04.to/crypto.html">http://chimera.labs.oreilly.com/books/1230000000545/ch04.to/crypto.html</a></li>
<li><a href="http://www.rsaconference.com/writable/presentations/file_upload/dsp-f03-new-trends-in-cryptographic-algorithm-suites-used-for-tls-communications.pdf">RSA Conference 2015 : New Trends In Cryptographic Algorithm Suites Used For TLS Communications</a></li>
</ul>


<a name="L..............."></a>
<h3>密码学相关</h3>

<ul>
<li><a href="https://www.coursera.org/course/crypto">Stanford Cryptography open course</a></li>
<li><a href="http://crypto101.io">crypto101，一本很棒的开源电子书</a></li>
<li><a href="https://book.douban.com/subject/1172109/">现代密码学理论与实践</a> - 毛文波</li>
<li><a href="http://book.douban.com/subject/5954556/">现代密码学:原理与协议</a> - Katz and Lindell</li>
<li><a href="http://saweis.net/pdfs/weis-modern-crypto-defcon-2015.pdf">&ldquo;Modern Crypto: 15 Years of Advancement in Cryptography&rdquo;  &ndash; 2015 defcon 大会Steve Weis 演讲</a></li>
<li>强烈建议不要看90年代的书，普遍严重过时，比如《应用密码学：协议、算法与C源程序（原书第2版）》</li>
<li><a href="http://cr.yp.to/crypto.html">DJBs crypto page</a></li>
<li><a href="http://blog.cr.yp.to/20140205-entropy.html">DJBs entropy attacks</a></li>
<li><a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad">Cryptographic Right Answers</a></li>
<li><a href="http://www.slideshare.net/yassl/securing-data-in-transit">http://www.slideshare.net/yassl/securing-data-in-transit</a></li>
<li>[Schneier 关于密码学2010年现状的评述]( &lt;<a href="https://www.schneier.com/blog/archives/2013/07/is_cryptography.html">https://www.schneier.com/blog/archives/2013/07/is_cryptography.html</a>)</li>
<li><a href="http://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology">http://security.stackexchange.com/questions/2202/lessons-learned-and-misconceptions-regarding-encryption-and-cryptology</a></li>
<li><a href="http://chargen.matasano.com/chargen/2009/7/22/if-youre-typing-the-letters-a-e-s-into-your-code-youre-doing.html">http://chargen.matasano.com/chargen/2009/7/22/if-youre-typing-the-letters-a-e-s-into-your-code-youre-doing.html</a></li>
<li><a href="http://kodu.ut.ee/~swen/publications/articles/laur-thesis-binded.pdf">http://kodu.ut.ee/~swen/publications/articles/laur-thesis-binded.pdf</a></li>
<li><a href="https://www.enisa.europa.eu/activities/identity-and-trust/library/deliverables/study-on-cryptographic-protocols">https://www.enisa.europa.eu/activities/identity-and-trust/library/deliverables/study-on-cryptographic-protocols</a></li>
<li><a href="https://github.com/sweis/crypto-might-not-suck">https://github.com/sweis/crypto-might-not-suck</a></li>
<li><a href="http://pages.uoregon.edu/joe/crypto-bcp/crypto-bcp.pdf">Cryptographic Best Practices in the Post-Snowden Era</a></li>
<li><a href="http://en.wikipedia.org/wiki/Crypto_Wars">Crypto War</a></li>
<li><a href="http://www.cs.bris.ac.uk/Research/CryptographySecurity/knowledge.html">52 Things People Should Know To Do Cryptography</a></li>
<li><a href="http://bristolcrypto.blogspot.com/">http://bristolcrypto.blogspot.com/</a></li>
<li><a href="https://www.schneier.com/">https://www.schneier.com/</a></li>
<li><a href="https://www.imperialviolet.org/2015/05/16/aeads.html">https://www.imperialviolet.org/2015/05/16/aeads.html</a></li>
<li><a href="https://crypto.stanford.edu/~dabo/cryptobook/draft_0_2.pdf">https://crypto.stanford.edu/~dabo/cryptobook/draft_0_2.pdf</a></li>
<li><a href="http://saweis.net/pdfs/weis-modern-crypto-defcon-2015.pdf">http://saweis.net/pdfs/weis-modern-crypto-defcon-2015.pdf</a></li>
</ul>


<a name="L.................."></a>
<h3>相关开源项目</h3>

<ul>
<li><a href="http://golang.org/pkg/crypto/tls/">GoTLS</a> - go语言自己搞的 TLS 协议实现</li>
<li><a href="https://www.openssl.org/">OpenSSL</a> - 事实上的标准</li>
<li><a href="http://www.libressl.org/">LibreSSL</a> - OpenBSD搞的OpenSSL的分支，代码可读性大大提高</li>
<li><a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a> - Google Security team 维护的OpenSSL分支</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS">NSS</a> - Mozilla 维护的TLS协议实现</li>
<li><a href="https://github.com/awslabs/s2n/">s2n</a> - Amazon搞的tls协议实现</li>
<li><a href="http://www.mitls.org/wsgi/home">MiTLS</a> ,  <a href="http://www.mitls.org/wsgi/tls-attacks">TLS Attacks</a></li>
<li><a href="http://nacl.cr.yp.to/">NaCL</a> and <a href="https://github.com/jedisct1/libsodium">libsodium</a></li>
<li><a href="http://www.tarsnap.com/spiped.html">spiped</a></li>
</ul>


<p><embed src="//music.163.com/style/swf/widget.swf?sid=4236464&type=2&auto=0&width=320&height=66" width="340" height="86"  allowNetworking="all"></embed></p>

<!--
![][pay_me_ad]
![][pay_me]
-->


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[现代密码学实践指南[2015年]]]></title>
    <link href="https://blog.helong.info//blog/2015/06/05/modern-crypto/"/>
    <updated>2015-06-05T22:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/06/05/modern-crypto</id>
    <content type="html"><![CDATA[<hr />

<p>本文介绍目前现代密码学的最先进技术，
前半部分主要翻译自  <a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad">《Cryptographic Right Answers》</a>，附上收集的资料，和byron个人的理解。</p>

<p>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</p>

<hr />

<a name="L...................................................................................."></a>
<h5>下文分类介绍在各种适用场景下，你应该使用的现代密码学算法</h5>

<a name="L1....strong...............strong..:"></a>
<h3>1.  <strong>加密数据</strong> :</h3>

<p>按照优先级，应该选择:</p>

<p>(1)   首选 NaCl库，或者libsodium库，使用里面的crypto_secretbox()/crypto_secretbox_open() 函数
(2)   Chacha20-Poly1305 算法
(3)   AES-GCM 算法</p>

<p>适用场景:当你需要避免把明文数据在网络上传输的时候。</p>

<p>以上3种算法，都是AEAD类的算法，AEAD是2015年最好的选择。
其中的(2)和(3)在结构上类似：一个流加密模式的算法，配合一个多项式结构的MAC。
(2)是一个流加密算法，配合一个为通用cpu优化的MAC算法，
对密码学库的实现者来说，Poly1305也比GCM更容易安全地实现。
AES-GCM是工业标准(TLS目前主要用的就是AES-GCM)，现代CPU通常都有专门为AES-GCM设计的硬件指令，但是在没有硬件指令支持的CPU上(比如32位的arm)，(3)性能低于(2)。</p>

<!--more-->


<p>此外，应该</p>

<ul>
<li>避免AES-CBC(说来话长，后文有解释)</li>
<li>避免AES-CTR</li>
<li>避免64bit块大小的块加密算法&ndash;(说的就是你&ndash;BlowFish)</li>
<li>避免OFB模式</li>
<li>不要使用RC4，RC4已经被攻破</li>
</ul>


<a name="L2....strong.....................strong..:"></a>
<h3>2.  <strong>对称密钥长度</strong> :</h3>

<p>选择使用256bit长度的密钥</p>

<p>适用场景：只要你在使用密码学，你就应该注意<strong>对称密钥长度</strong></p>

<p>请记住：不要把对称加密（如AES）的key长度，和非对称加密(如RSA)的key长度搞混淆了，对称加密的key通常比非对称加密的key短多了。</p>

<p>下表对比了相同安全程度时，不同算法的密钥长度，单位:bit</p>

<table>
<thead>
<tr>
<th> Symmetric</th>
<th>   ECC   </th>
<th>DH/DSA/RSA</th>
</tr>
</thead>
<tbody>
<tr>
<td>   80     </td>
<td>   163   </td>
<td>     1024 </td>
</tr>
<tr>
<td>  112     </td>
<td>   233   </td>
<td>     2048 </td>
</tr>
<tr>
<td>  128     </td>
<td>   283   </td>
<td>     3072 </td>
</tr>
<tr>
<td>  192     </td>
<td>   409   </td>
<td>     7680 </td>
</tr>
<tr>
<td>  256     </td>
<td>   571   </td>
<td>    15360 </td>
</tr>
</tbody>
</table>


<p>此外，应该</p>

<ul>
<li>避免使用巨大key的算法(使用远大于256的key，只能说明使用者没有安全概念)</li>
<li>避免把多个加密算法串联叠加起来使用，这并没有什么卵用</li>
<li>避免128bit以下的key长度(比如，哥们求你别再提DES这种56bit密钥的古董了)</li>
</ul>


<a name="L3....strong...............strong.:"></a>
<h3>3.  <strong>对称签名</strong>:</h3>

<p>应该选择 HMAC 类的算法</p>

<p>适用场景：安全加固一个API，如各种开放API的调用方认证</p>

<p>如果对一个API，你需要做认证(authenticating)，但是不需要做加密(encrypting)，记得千万不要自己发明算法，你自己发明的MAC算法基本都有安全漏洞，如果不信，请Google一下 &ldquo;长度扩展攻击&rdquo;
<a href="http://en.wikipedia.org/wiki/Length_extension_attack">长度扩展攻击</a>
<a href="http://netifera.com/research/flickr_api_signature_forgery.pdf">Flickr的漏洞案例</a></p>

<p>同时，必须要注意的是，要使用一个<strong>常数时间字符串对比算法</strong>（这个地方和码农的常识完全相反，请务必留意）</p>

<p>此外，应该</p>

<ul>
<li>避免自行设计的“带密码的hash”结构，你的设计基本都是有安全漏洞的</li>
<li>避免HMAC-MD5，避免HMAC-SHA1，使用HMAC-SHA256, HMAC-SHA512等</li>
<li>避免复杂的多项式MAC</li>
<li>避免加密hash值的结构</li>
<li>避免CRC</li>
</ul>


<a name="L4....strong.Hashing.HMAC.........strong."></a>
<h3>4.  <strong>Hashing/HMAC 算法</strong></h3>

<p>应该选择<a href="http://en.wikipedia.org/wiki/SHA-2">SHA2</a>类的算法:: SHA-256, SHA-384, SHA-512, SHA-512/256</p>

<p>优先使用 SHA-512/256，SHA-512/256这个算法把 SHA-512 的512bit输出截短到256bit，避开了length extension 攻击。
同时，目前SHA-2是很安全可靠的，你不需要升级到SHA-3.</p>

<p>此外，应该</p>

<ul>
<li>避免SHA-1</li>
<li>避免MD5</li>
<li>避免MD6</li>
</ul>


<a name="L5....strong.......ID..strong."></a>
<h3>5.  <strong>随机ID</strong></h3>

<p>应该使用256 bit的随机值</p>

<p>一定要使用 /dev/urandom，请认准这个</p>

<p>此外，应该</p>

<ul>
<li>避免用户空间的随机数生成器如:havaged,prngs,egd,等</li>
<li>避免/dev/random</li>
</ul>


<a name="L6....strong...............strong."></a>
<h3>6.  <strong>密码处理</strong></h3>

<p>按照优先级顺序,选择：</p>

<ul>
<li>scrypt</li>
<li>bcrypt</li>
<li>如果以上2个都没有，那就用PBKDF2</li>
</ul>


<p>此外，应该</p>

<ul>
<li>避免直接SHA-2</li>
<li>避免直接SHA-1</li>
<li>避免直接MD5</li>
</ul>


<a name="L7....strong..................strong."></a>
<h3>7.  <strong>非对称加密</strong></h3>

<p>应该使用NaCl库</p>

<p>适用场景：当你需要加密消息，发给陌生人，并且对方异步接收消息，做离线解密时。这是一个很窄的应用案例，这种用法有个名字叫<em>电子信封(digital envelope)</em>，典型比如gpg加密文件后发送。</p>

<p>这条是几条之中最难做正确的，不要使用底层的密码学库，比如OpenSSL或者BouncyCastle。</p>

<p>你应该停止使用RSA，并且切换到椭圆曲线类体制，原因是：</p>

<ul>
<li>对RSA的攻击能力的进步 &mdash; 定义在传统质数域上的乘法运算(应用包括DH,DSA,ElGamal等)，要比椭圆曲线域上的乘法运算快得多。这是由于质数域上数域筛法（number field sieve,NFS）的进展，而在椭圆曲线域上，没有NFS这类算法。</li>
<li>RSA (和DH) 或迫使你考虑“向后兼容性”，而椭圆曲线体制没有这种兼容性包袱。TLS最近的几个安全漏洞，部分愿意也是由于这种向后兼容性，导致已经被破解的陈旧算法存在</li>
<li>RSA在一般场景中，都是直接用公钥做非对称加密，这种用法丧失了<strong>前向安全性(Perfect Forward Secrecy)</strong>。而椭圆曲线就不提倡，也很难这样使用，这样你就不会害死自己了。</li>
<li>在椭圆曲线体制下，保证正确性和安全性的重任，主要由密码学家承担，密码学家会提供一组曲线参数，在某一性能水平下，针对安全性和性能做优化。这样程序员不容易误用而害死自己。在RSA体制下，正好相反，程序员必须提供参数来保证正确性和安全性，就算是RSA-OAEP这种很好的设计，程序员也必须知道怎么提供参数，这样程序员很容易搞错。</li>
</ul>


<p>如果你必须使用RSA，一定要使用RSA-OAEP with SHA256，指数使用 65537</p>

<ul>
<li>避免 RSA-PKCS1v15</li>
<li>避免 ElGamal</li>
<li>避免 RSA</li>
</ul>


<a name="L8....strong..................strong."></a>
<h3>8.  <strong>非对称签名</strong></h3>

<p>应该使用NaCl，Ed25519，或者RFC6979</p>

<p>应用场景：如果你在设计一种新的比特币，或者一个给Ruby Gems或者Vagrant imges文件签名的系统，或者数字版权保护系统(DRM)，其中一系列的文件需要离线做认证；
或者你在设计一个加密消息传输层</p>

<p>上一条的内容在此处全部适用。</p>

<p>在10+年做付费软件安全评估的工作经历中，我只有屈指可数的几次，遇到使用RSA-PSS的用户，RSA-PSS是一个学术界的推荐算法。</p>

<p>过去10年，非对称签名最主要的应用场景是比特币，和前向安全的密钥协商（TLS协议里面的ECDHE）。
其中最主要的算法全都是基于椭圆曲线体制的。务必警惕新出现的使用RSA签名的系统，很有可能有问题。</p>

<p>在过去几年中，业界有一种趋势：放弃传统DSA签名，改为难以误用的<strong>确定性签名体制</strong>，其中的EdDSA(不要和ECDSA搞混了喂！)和RFC6979是最好的例子。这种趋势的主要是受到2010年索尼PlayStation 3的 ECDSA私钥被破解事件的影响，在这个案例中，索尼公司的码农错误地把一个随机数重复使用来做ECDSA签名，形成了漏洞，使得破解者据此直接把私钥算出来了。<strong>确定性签名体制</strong>在设计中不再依赖随机数生成器，因此彻底避开此类误用。所以你应该优先使用确定性签名体制。</p>

<ul>
<li>避免RSA-PKCS1v15，避免RSA，避免ECDSA，避免DSA</li>
<li>特别要避免常规的DSA和ECDSA</li>
</ul>


<a name="L9....strong.Diffie-Hellman...............strong."></a>
<h3>9.  <strong>Diffie-Hellman 密钥交换</strong></h3>

<p>应该使用NaCl，Curve25519，或者DH-2048</p>

<p>适用场景:<em>如果你在设计加密消息传输系统，并且无法使用固定对称密码</em></p>

<p>这是很棘手的一条，主要考量如下：</p>

<ul>
<li>如果你能使用NaCl库，那就使用NaCl库。你甚至不需要管NaCl是什么。</li>
<li>如果你能使用一个可信赖的第三方库，那就使用Curve25519，这是一条现代的ECDH曲线，有丰富的开源代码，性能经过高度优化，被彻底地安全分析过。并且Curve25519即将进入TLS 1.3版本标准。</li>
<li>但是绝对不要自己实现Curve25519，也绝对不要自己移植Curve25519的C代码</li>
<li>如果你不能使用第三方ECDH库，但是可以使用DH库，那就使用DH-2048，使用1个标准的2048 bit的群。</li>
<li>但是不要使用传统的DH，如果你需要协商DH参数，或者和其他实现互操作</li>
<li>如果你一定要做握手协商，或者和旧软件互操作，那么考虑使用NIST P-256, NIST P-256 有广泛的软件支持。</li>
<li>写死在代码里的DH-2048参数，比NIST P-256更安全。NIST P-256比协商出来的DH更安全。</li>
<li>但是，由于NIST P-256的实现有一些陷阱，所以一定要谨慎选择可信赖的，广泛使用使的第三方库</li>
<li>P-256 可能是NIST曲线中最安全的，不要使用P-224。</li>
</ul>


<p>DH（密钥协商）算法确实很难用，但是它很重要。</p>

<ul>
<li>避免，传统常规的 DH, SRP, J-PAKE 握手和协商</li>
<li>避开任何只使用了块加密算法和srand(time())的密钥协商模式（肯定有漏洞）</li>
</ul>


<a name="L10....strong...............strong."></a>
<h3>10.  <strong>网站安全</strong></h3>

<p>应该使用OpenSSL，或者Google的BoringSSL，或者直接使用 AWS的 ELB</p>

<p>此处网站安全，指的是让网站支持HTTPS协议。
如果你不能把这个任务交给Amazon的云服务去做，把难题留给Amazon去解决，那么OpenSSL目前仍然是正确选择。</p>

<ul>
<li>避免不常见的TLS库，例如polarssl，GnuTLS，MatrixSSL等</li>
</ul>


<a name="L11....strong..........-.........................................strong...."></a>
<h3>11.  <strong>客户端-服务器结构的应用程序的安全</strong>：</h3>

<p>应该使用TLS</p>

<p>适用场景：如果你以为自己理解了前面关于公钥加密的介绍。。。</p>

<p>通常，在你设计了自己的RSA协议之后的1至18个月，你肯定会发现，你犯了某个错误，使你的协议没有任何安全性。
比如Salt Stack，Salt Stack的协议使用了 e=1 的RSA 公钥。。。</p>

<p>听起来，TLS有下面这些黑历史：</p>

<ul>
<li>The Logjam DH negotiation attack</li>
<li>The FREAK export cipher attack</li>
<li>The POODLE CBC oracle attack</li>
<li>The RC4 fiasco</li>
<li>The CRIME compression attack</li>
<li>The Lucky13 CBC padding oracle timing attack</li>
<li>The BEAST CBC chained IV attack</li>
<li>Heartbleed</li>
<li>Renegotiation</li>
<li>Triple Handshakes</li>
<li>Compromised CAs</li>
</ul>


<p>但是，你仍然应该使用TLS做传输协议，因为：</p>

<ul>
<li>这些漏洞中的大部分，仅仅是针对浏览器的，因为他们依赖受害者执行攻击者控制的JavaScript脚本，这些JavaScript脚本生成重复的明文，或特定的明文。</li>
<li>这些漏洞中的大部分，其影响都可以被减轻，只需要你在代码和配置里面写死 TLS v1.2, ECDHE，和 AES-GCM就行。这听起来很棘手，但是这远远没有你自己设计使用ECDHE和AES-GCM的传输协议棘手。</li>
<li><p>在一个自定义的传输协议的场景中，你并不需要依赖CA，你可以用一个自签名证书，嵌入到你的客户端里面。</p></li>
<li><p>不要自己设计加密传输协议，这是<strong>极其困难而易错的工程难题</strong></p></li>
<li>使用TLS，但是不要使用默认配置</li>
</ul>


<a name="L12....strong...............strong."></a>
<h3>12.  <strong>在线备份</strong></h3>

<p>应该使用Tarsnap</p>

<hr />

<a name="L............"></a>
<h1>名词解释</h1>

<p>本文的内容比较新，相关中文资料极少，因此文中的名词对读者可能有点陌生，故byron这里介绍一下文中提到的一些名词：</p>

<a name="L1...NaCl...:"></a>
<h3>1.  NaCl库:</h3>

<p><a href="http://nacl.cr.yp.to/">http://nacl.cr.yp.to/</a>
是密码学学术权威 Daniel J. Bernstein教授 设计的一个密码学算法库，2008年发开始公布。NaCl的特点是：api简洁而易用，高性能，高安全性，主要用于网络通信，加密，解密，签名等，NaCl提供了构建高层密码学工具的核心功能。</p>

<a name="L2...libsodium...:"></a>
<h3>2.  libsodium库:</h3>

<p><a href="https://download.libsodium.org/doc/">https://download.libsodium.org/doc/</a>
libsodium是对NaCl库的一个分支，进一步改进接口易用性，和可移植性。</p>

<a name="L3...AEAD:"></a>
<h3>3.  AEAD:</h3>

<p><a href="https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html">https://www.imperialviolet.org/2014/02/27/tlssymmetriccrypto.html</a>
AEAD的概念:
在通常的密码学应用中，Confidentiality  (保密) 用加密实现，Message authentication (消息认证) 用MAC实现。这两种算法的配合方式，引发了很多安全漏洞，过去曾经有3种方法：1. Encrypt-and-MAC  2.MAC-then-Encrypt 3.Encrypt-then-MAC ，后来发现，1和2都是有安全问题的，所以，2008年起，
逐渐提出了“用一个算法在内部同时实现cipher+MAC”的idea，称为AEAD(Authenticated encryption with additional data)。
在AEAD这种概念里，cipher+MAC 被 一个AEAD算法替换。
<a href="http://en.wikipedia.org/wiki/Authenticated_encryption">http://en.wikipedia.org/wiki/Authenticated_encryption</a></p>

<a name="L4...ChaCha20-poly1305"></a>
<h3>4.  ChaCha20-poly1305</h3>

<p>ChaCha20-poly1305是一种AEAD，提出者是Daniel J. Bernstein教授，针对移动互联网优化，目前Google对移动客户端的所有流量都使用ChaCha20-Poly1305</p>

<a name="L5...AES-GCM"></a>
<h3>5.  AES-GCM</h3>

<p>AES-GCM是一种AEAD，是目前TLS的主力算法，互联网上https流量的大部分依赖使用AES-GCM。</p>

<a name="L6...AES-GCM...ChaCha20-Poly1305...........................:"></a>
<h3>6.  AES-GCM和ChaCha20-Poly1305的性能对比测试结果:</h3>

<table>
<thead>
<tr>
<th> Chip  </th>
<th style="text-align:center;"> AES-128-GCM speed </th>
<th style="text-align:center;"> ChaCha20-Poly1305 speed   </th>
</tr>
</thead>
<tbody>
<tr>
<td> OMAP 4460 </td>
<td style="text-align:center;"> 24.1 MB/s     </td>
<td style="text-align:center;"> 75.3 MB/s </td>
</tr>
<tr>
<td> Snapdragon S4 Pro </td>
<td style="text-align:center;">41.5 MB/s  </td>
<td style="text-align:center;">   130.9 MB/s  </td>
</tr>
<tr>
<td> Sandy Bridge Xeon (AESNI) </td>
<td style="text-align:center;">900 MB/s   </td>
<td style="text-align:center;">   500 MB/s    </td>
</tr>
</tbody>
</table>


<a name="L7...AES-CBC"></a>
<h3>7.  AES-CBC</h3>

<p>关于AES-CBC，在AES-GCM流行之前，TLS主要依赖AES-CBC，而由于历史原因，TLS在设计之初固定选择了MAC-then-Encrypt结构，AES-CBC和MAC-then-encrypt结合，为选择密文攻击(CCA)创造了便利条件，TLS历史上有多个漏洞都和CBC模式有关：</p>

<ul>
<li>The POODLE CBC oracle attack:参考:
<a href="http://www.thoughtcrime.org/blog/the-cryptographic-doom-principle/">1.POODLE的一个分析</a>
<a href="https://www.openssl.org/~bodo/tls-cbc.txt">2.openssl的分析</a>
<a href="http://drops.wooyun.org/papers/3194">3.乌云的文章</a></li>
<li>The CRIME compression attack:</li>
<li>The Lucky13 CBC padding oracle timing attack:</li>
<li>The BEAST CBC chained IV attack:</li>
</ul>


<a name="L8...SHA2"></a>
<h3>8.  SHA2</h3>

<p><a href="http://en.wikipedia.org/wiki/SHA-2">http://en.wikipedia.org/wiki/SHA-2</a></p>

<a name="L9...Curve25519"></a>
<h3>9.  Curve25519</h3>

<p><a href="http://cr.yp.to/ecdh.html">http://cr.yp.to/ecdh.html</a>
Curve25519 是目前最高水平的 Diffie-Hellman函数，适用于广泛的场景，由Daniel J. Bernstein教授设计。由于NIST P-256的设计过程不透明，有来历不明的参数，被广泛怀疑有后门，所以设计了Curve25519，Curve25519的设计过程完全公开，没有任何来历不明的参数。
部署情况：<a href="http://ianix.com/pub/curve25519-deployment.html">http://ianix.com/pub/curve25519-deployment.html</a></p>

<a name="L10...Ed25519"></a>
<h3>10.  Ed25519</h3>

<p><a href="http://ed25519.cr.yp.to/">http://ed25519.cr.yp.to/</a>
Ed25519是一个数字签名算法，</p>

<ul>
<li>签名和验证的性能都极高， 一个4核2.4GHz 的 Westmere cpu，每秒可以验证 71000 个签名</li>
<li>安全性极高，等价于RSA约3000-bit</li>
<li>签名过程不依赖随机数生成器，不依赖hash函数的防碰撞性，没有时间通道攻击的问题</li>
<li>并且签名很小，只有64字节，公钥也很小，只有32字节。
部署情况：<a href="http://ianix.com/pub/ed25519-deployment.html">http://ianix.com/pub/ed25519-deployment.html</a></li>
</ul>


<a name="L11.................."></a>
<h3>11.  前向安全性</h3>

<p>前向安全性( Perfect Forward Secrecy )
<a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html</a>
前向安全性指的是，如果攻击者抓取并保存流量，那么将来私钥泄露后，攻击者也无法利用泄露的私钥解密这些流量。</p>

<a name="L12...Diffie-Hellman............."></a>
<h3>12.  Diffie-Hellman 密钥交换</h3>

<p><a href="http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a>
在任何一本密码学教材里面都会重点介绍的</p>

<a name="L13...constant.time.compare"></a>
<h3>13.  constant time compare</h3>

<p>针对Timing attack，<a href="http://en.wikipedia.org/wiki/Timing_attack">http://en.wikipedia.org/wiki/Timing_attack</a> （这种攻击真是脑洞大开！）
当一个算法的运行时间和输入数据有关的时候，可以根据运行时间这一信息，破解出密钥等。
典型的，比如要验证一个对称签名，如果你用了C库里面的memcmp()，那你就会被timing attack方式攻击。
因此，涉及到密码学数据的memcmp，必须要用运行时间和输入无关的函数，比如OpenSSL库里面的<code>CRYPTO_memcmp()</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx下配置高性能，高安全性的https TLS服务]]></title>
    <link href="https://blog.helong.info//blog/2015/05/08/https-config-optimize-in-nginx/"/>
    <updated>2015-05-08T20:32:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/05/08/https-config-optimize-in-nginx</id>
    <content type="html"><![CDATA[<p>下文以nginx为例，介绍如何部署一个高性能，高安全性的https服务器。</p>

<p>并附送一个优化出来的openssl编译脚本，可以编译出一个高性能，高安全性的openssl库，您可以直接复制粘贴使用。</p>

<p>此处直接给出实践指导，后续再写文章解释tls协议的这些原理细节。</p>

<p>nginx下https配置的优化点，主要有:</p>

<ol>
<li>session ticket</li>
<li>session id cache</li>
<li>ocsp stapling</li>
<li>http KeepAlive</li>
<li>ECDHE等ciphersuite优化</li>
<li>openssl 编译优化</li>
</ol>


<a name="L.......nginx.https........."></a>
<h3>一， nginx https的配置</h3>

<p>先贴一下nginx配置，如下。</p>

<p>是根据<a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx">mozilla的权威文档</a>
,和<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">生成工具</a>(选择 nginx，intermediate ) 生成的配置为基础，加入session ticket等配置的结果</p>

<!--more-->


<pre><code class="c tls_nginx.conf">server {
    listen 443 ssl;

    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
    ssl_certificate /path/to/signed_cert_plus_intermediates;
    ssl_certificate_key /path/to/private_key;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;

    ssl_session_ticket_key /etc/nginx/conf.d/tls_session_ticket.key;
    ssl_session_tickets on;

    keepalive_timeout 75s;

    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
    ssl_dhparam /path/to/dhparam.pem;

    # intermediate configuration. tweak to your needs.
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';
    ssl_prefer_server_ciphers on;

    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
    add_header Strict-Transport-Security max-age=15768000;

    # OCSP Stapling ---
    # fetch OCSP records from URL in ssl_certificate and cache them
    ssl_stapling on;
    ssl_stapling_verify on;

    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
    ssl_trusted_certificate /path/to/signed_cert_plus_intermediates;

    resolver 114.114.114.114;

    ....
}
</code></pre>

<a name="L..............................."></a>
<h3>二， 其中的几个配置项</h3>

<a name="L1...path.to.signed_cert_plus_intermediates"></a>
<h5>1. /path/to/signed_cert_plus_intermediates</h5>

<p>是你的证书链，就是ca签署之后发给你的文件，是一串这样的内容</p>

<pre><code>-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
...
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
</code></pre>

<a name="L2...path.to.private_key"></a>
<h5>2. /path/to/private_key</h5>

<p>是你的私钥，一定要保密，最好chown+chmod限制只有http server可以读取！内容大致是：
<code>
-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----
</code></p>

<a name="L3...path.to.dhparam.pem"></a>
<h5>3. /path/to/dhparam.pem</h5>

<p>是dhe密钥协商的参数，生成方法：</p>

<pre><code>     openssl  dhparam -out dhparam.pem 2048
</code></pre>

<a name="L4...etc.nginx.conf.d.tls_session_ticket.key"></a>
<h5>4. /etc/nginx/conf.d/tls_session_ticket.key</h5>

<p>是用来加解密session ticket的密码文件，这个文件的安全等级应该和私钥一样，最好chmod+chown限制只有http server能读取。 生成方法:</p>

<pre><code>     openssl rand 48 &gt; tls_session_ticket.key
</code></pre>

<p>最好定期（比如2天一次）轮换，配置文件里把新的key文件放在最前面，旧的在下面，如下</p>

<pre><code>    ssl_session_ticket_key current.key;
    ssl_session_ticket_key previous.key;
</code></pre>

<a name="L5..ssl_trusted_certificate..path.to.signed_cert_plus_intermediates"></a>
<h5>5. ssl_trusted_certificate /path/to/signed_cert_plus_intermediates</h5>

<p>ssl_trusted_certificate，是用来验证ocsp响应的各个ca证书+中级证书，和信任的ca根证书列表。当用来验证ocsp响应的时候，应该配置为你的ca根证书+和中级ca证书的列表，此处可以简单和ssl_certificate使用同一个证书列表文件。<br/>
其中当需要使用tls的客户端认证的时候（大多数https server都用不到客户端认证），需要指定信任的ca根证书列表文件, 这个文件在centos里面是/etc/ssl/certs/ca-bundle.trust.crt 这个文件。</p>

<p>配置完成之后，使用ssllabs的这个在线检查工具<a href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a> 做检查，里面提出的警告，都需要改正。</p>

<a name="L........openssl............"></a>
<h3>三，  openssl编译优化</h3>

<p>主流的https server，都是依赖openssl来提供tls协议，openssl本身代码复杂，概念繁多，最近对这方面做了研究，下面是一个深入分析过后的最优化编译配置，可以编译出一个高性能，高安全性的openssl版本，您可以直接复制粘贴使用。</p>

<p>openssl请使用最新的1.0.2a版本，这个版本有intel针对ecdh p256曲线的优化，编译脚本见本文末尾。</p>

<p>编译好之后，需要让nginx使用我们编译的这个openssl库，在centos下，可以用LD_LIBRARY_PATH的办法：</p>

<pre><code>sudo vim /usr/lib/systemd/system/nginx.service
</code></pre>

<p>在其中添加一行Environment，如下：</p>

<pre><code>[Service]
...
Environment=LD_LIBRARY_PATH=/usr/local/bin/openssl-1.0.2a_64_build/lib/
ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf
...
</code></pre>

<p>其中的路径，请自行修改。</p>

<p>还需要创建软连接，解决so库版本号的问题，如下</p>

<pre><code>ln -s libcrypto.so.1.0.0 libcrypto.so.10
ln -s libssl.so.1.0.0 libssl.so.10
</code></pre>

<p>脚本中包含了一个cloudflare的patch，增加chacha20_poly1305 cipher，使用了这个patch之后，可以使用<a href="https://github.com/cloudflare/sslconfig/blob/master/conf">cloudflare的ciphers配置</a></p>

<p><a href="https://github.com/byronhe/modern-crypto-toolbox/blob/master/build_openssl.sh">https://github.com/byronhe/modern-crypto-toolbox/blob/master/build_openssl.sh</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【翻译】密码学一小时必知]]></title>
    <link href="https://blog.helong.info//blog/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour/"/>
    <updated>2015-04-12T14:05:55+00:00</updated>
    <id>https://blog.helong.info//blog/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour</id>
    <content type="html"><![CDATA[<p>本文翻译了Colin Percival 于2010年在bsdcan的演讲ppt</p>

<p>原文标题：Everything you need to know about cryptography in 1 hour</p>

<p>演讲时间：May 13, 2010</p>

<p>原文在 <a href="https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf">https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf</a></p>

<p>演讲视频在 <a href="https://www.youtube.com/watch?v=jzY3m5Kv7Y8">https://www.youtube.com/watch?v=jzY3m5Kv7Y8</a> ( 请自行翻墙 )</p>

<p>Colin Percival 是密码学方面的专家，FreeBSD项目的安全长官，Tarsnap在线备份服务的创始人，scrypt密钥衍生算法的作者，致力于改进软件中密码学的应用，向程序员传播密码学的正确使用。</p>

<!--more-->


<hr />

<p>为什么要 cryptography in 1 hour：</p>

<p>因为有例如下面这些错误的使用案例：</p>

<ol>
<li><p>Google keyczar(时间通道攻击)</p></li>
<li><p>SSL( session renegotiation)</p></li>
<li><p>Amazon AWS 签名方法 (可能碰撞的签名算法)</p></li>
<li><p>Flicker API 签名(hash length-extension) 错误地使用了错误的工具</p></li>
<li><p>Intel Hyper Threading (architectual side channel) 不常用的环境</p></li>
<li><p>WEP,WPA,GSM&hellip;（多种漏洞）</p></li>
</ol>


<p>密码学被攻破通常是由于：</p>

<ol>
<li><p>愚蠢</p></li>
<li><p>使用了错误的工具，或者以错误的方式使用它们</p></li>
<li><p>不常用的环境</p></li>
</ol>


<hr />

<p>经验智慧：不要亲自写密码学代码！</p>

<ol>
<li>使用SSL做传输</li>
<li>使用GPG保护静止数据</li>
</ol>


<p>&ldquo;如果你在输入A-E-S到你的代码里，你已经开始犯错&rdquo; &ndash; Tomas Ptacek</p>

<p>现实：如果你无论如何都要写密码学代码，你最好知道你在干什么</p>

<p>现实：大多数应用程序只需要众所周知的标准模式的一个子集，而这是很容易保证正确的</p>

<p>55分钟后，你应该：</p>

<p>知道在99%的情况下应该怎么做</p>

<p>知道一些常见的错误在哪里</p>

<p>知道当你在做一些非标准的事情的时候，你真的需要咨询一个密码学专家</p>

<hr />

<p>密码学做保护，并对抗一些攻击，但不能对抗所有攻击：</p>

<p>贿赂，盗窃，敲诈</p>

<p>监狱刑罚</p>

<p>攻击人通常比攻击数据更贵</p>

<p>攻击人通常比攻击数据更危险</p>

<p>数据被拷打时不会开记者招待会来控诉</p>

<p>密码学的目的是强迫美国政府拷打你</p>

<p>希望他们认为你的信息不是这么重要</p>

<hr />

<p>密码学有3个主要目的：<em>加密 Encryption</em> ，<em>认证 Authentication </em>，<em>识别  Identification</em></p>

<ol>
<li>加密阻止恶意者读取你的数据</li>
<li>认证阻止恶意者在不被发现的情况下改动你的数据</li>
<li>识别阻止恶意者假装你</li>
</ol>


<p>有时认证和识别在一个步骤中进行：“这条消息自从我写下它之后没有被篡改”和“我是Colin”
可以替换成“这条消息自从Colin写下它之后没有被改过”</p>

<p>在大多数case里，你需要把2个，或者更多的密码学组件合起来使用</p>

<hr />

<p>概念定义</p>

<ol>
<li>plaintext是我们关心的数据</li>
<li>ciphertext是恶意者可以得到的数据</li>
<li>key用于在这两者之间做转换，有时候我们需要多个key</li>
</ol>


<p>对称密码学就是 ，使用相同的key，来把plaintext转换成ciphertext，和把ciphertext转换成
plaintext</p>

<p>非对称密码学就是，这两个方向的转换使用不同的key</p>

<p>理想的密码学组件并不存在，但是如果一个密码学组件被识别出不理想，一般就认为它是被攻破的</p>

<hr />

<p>hashing</p>

<p>一个理想的hash函数H(x)是一个函数映射，把任意长度的输入映射成n-bit的输出，
保证：</p>

<p><em>抵抗碰撞</em></p>

<p><em>单向</em></p>

<p>抵抗碰撞意味着需要 2<sup>n/2</sup>的时间来找到2个输入，使得它们的hash相同</p>

<p>单向意味着给定hash后，需要2<sup>n</sup>的时间来找到一个输入，使得它的hash是给定hash</p>

<p><em>没有保证任何其他性质</em></p>

<p>特别是：
知道H(x)可能允许一个攻击者计算某些y的H(y)</p>

<hr />

<p>实践：</p>

<p>使用 SHA-256</p>

<p>考虑切换到SHA-3，在未来5-10年内（2010年算起）</p>

<p>使用一个hash，如果你可以安全地分布 H(x)，并且想验证不安全地收到的x'实际上等于x</p>

<p>不要使用：MD2 MD4 MD5 SHA-1 RIPEMD</p>

<p>不要把 FreeBSD-8.0-RELEASE-amd64-disc1.iso和CHECKSUM.SHA256放到同一个FTP
服务器上，还以为自己干了件有用的事情</p>

<p>不要尝试把一个hash函数当成对称签名用</p>

<hr />

<p>对称认证</p>

<p>对称认证是通过提供一个消息认证码（MAC，message authentication code）来进行的。</p>

<p>一个理想的 MAC fk(x)使用一个key，来把任意长度的输入映射到n-bit的输出，确保需要 2<sup>n</sup>
的时间，一个攻击者才能在得到任意(x, fx(x))对的情况下，生成任意(y,fk(y))对。
有时MAC被称作随机函数</p>

<p>与hashing不同，知道fk(x)不能使你对另一个key计算出 fk(y)，</p>

<p> Flicker的API使用了hashing来认证API请求，他们实际需要的是 MAC</p>

<hr />

<p>对称认证</p>

<p>实践</p>

<p>使用 HMAC-SHA256</p>

<p>确保同样的输入，HMAC-SHA256不会生成不同的消息</p>

<p>Amazon和Flicker都做错了</p>

<p>不要使用 CBC-MAC</p>

<p>理论上安全，但是把你的块加密算法暴露给了攻击者</p>

<p>不要使用 Poly1305</p>

<p>太新，除非你是Daniel Bernstein(Poly 1305的发明者)，否则你基本不可能做出一个</p>

<p>安全和正确的实现</p>

<p>不要 当验证一个签名的时候，通过timing side channel的形式泄露信息</p>

<hr />

<p>Side channel 攻击</p>

<p>一个side channel 是攻击者除了ciphertext以外可以获取信息的任何方式</p>

<p>密码系统是以它们的数学设计被定义的，但是side channel 是由于密码系统的人工实现导致的。</p>

<p>最常见的side channel是timing &ndash; 你花费多长时间来 加密/解密/签名/验证 一个消息</p>

<p>其他side channel包括：电磁辐射，电力消耗，和微架构特征（例如L1缓存替换，在支持
HyperThreading的Intel CPU上）</p>

<hr />

<p>Side channel 攻击
实践</p>

<p>咨询一个密码学专家，如果你计划使恶意者可以物理接触到任何密码设备</p>

<p>咨询一个密码学专家，如果你计划允许恶意者在你允许密码学的物理硬件上运行代码(虚拟化系统)</p>

<p>咨询一个密码学专家，如果你计划发布一个以新方式泄露信息的CPU</p>

<p> intel可能做错了
不要写其运行时间泄露信息的代码</p>

<hr />

<p>Timing attacks</p>

<p>避免 依赖于key，或者依赖于plaintext的表查找</p>

<p>不要有依赖于key，或者依赖于plaintext的分支(if, for, while , foo?bar:baz 等代码指令)</p>

<p>不要想这种代码：</p>

<pre><code>for(int i=0;i&lt;MACLEN;i++){
    if(MAC-computed[i] != MAC-received[i])
        return MAC_IS_BAD ;
return  MAC_IS_GOOD;
</code></pre>

<p>应该这样写</p>

<pre><code>for(int i=0;i&lt;MACLEN;i++){
    x  |= (MAC-computed[i] - MAC-received[i]);

return  x?MAC_IS_BAD:MAC_IS_GOOD;
</code></pre>

<p>Google Keyczar就做错了</p>

<hr />

<p>块加密</p>

<p>对称加密通常构建在块加密算法的基础之上</p>

<p>一个理想的块加密算法使用一个key来双向地把n-bit的输入x转换成n-bit的输出Ek(x)，这样当
知道(x,Ek(x))时，对任意的(x',k')!=(x,k)，你没法以大于2^-n的概率猜出(x',Ek'(x'))</p>

<p>有时被称为“随机排列”</p>

<p>通常我们关心的是Ek(x)不透露出 当x!=x'时Ek(x')的信息。</p>

<p>如果一个攻击者可以通过观察一个块加密算法怎么处理不同key，来获取有用信息，该块加密算法
被认为可被  key相关攻击 （key-related attack）攻破。</p>

<hr />

<p>实践：</p>

<p>使用 AES-256</p>

<p>AES-256有related key攻击漏洞，但是当你把其它事情做对时，这并不是问题</p>

<p>AES-128理论上足够强壮，但是块加密算法很难没有side channel地正确实现 ，</p>

<p>并且key里面的额外bit 在key的一些bit泄露之后是有用的。</p>

<p>不要使用 blowfish</p>

<p>想都不要想使用DES</p>

<p>避免 triple-des(3des)</p>

<p>不要使用块加密算法"raw"，替代地，在一个已经建立的操作模式中使用它(?)。</p>

<hr />

<p>块加密算法操作模式</p>

<p>一个块加密算法操作模式告诉你怎么使用一个块加密算法来保护数据流</p>

<p>在很多case中，plaintext需要被填充到块大小的整数倍，块密码算法操作模式会
告诉你怎么做到这一点</p>

<p>流行的模式有: ECB ，CBC  , CFB , OFB，CTR，IAPM，CCM，EAX，GCM &hellip;</p>

<p>大多数模式只提供了加密，但也有一些提供了认证</p>

<p>实践：
使用：CTR模式</p>

<p>不要使用同时提供加密和认证的模式</p>

<p>想都不要想使用ECB</p>

<p>使用一个MAC（例如HMAC-SHA256）来认证你的加密数据</p>

<p>如果你认为你不需要这么做，咨询一个密码学专家，他会告诉你你为什么是错的。</p>

<p>验证你的加密数据的真实性，在你揭秘数据之前。</p>

<hr />

<p>非对称加密</p>

<p>一个非对称加密模式使用一个签名key来把plaintext转换成ciphertext，使用一个认证码来把
ciphertext转化成plaintext或者“错误的签名”</p>

<p>签名key不能从认证key算出，但是认证key可以从签名key算出</p>

<p>ciphertext通常由 plaintext加一个签名构成</p>

<p>如果一个攻击者接触到了验证key，并且可以说服你签名任意的plaintext，那就可以认为这个
非对称加密系统被攻破了。</p>

<hr />

<p>非对称认证</p>

<p>使用 RSASSA-PSS（RSA签名，使用Probabilistic Signature Scheme padding）</p>

<p>使用 2048-bit的RSA key，使用65537作为公钥的公共幂，和SHA256</p>

<p>不要使用 PKCS v1.5 padding</p>

<p>想都不要想 使用不带消息padding的RSA(即RAW)</p>

<p>可能避免： DSA</p>

<p>可能避免：椭圆曲线签名模式</p>

<p>想都不要想使用相同的RSA key既做认证，又做加密</p>

<hr />

<p>非对称加密</p>

<p>非对称加密类似于非对称签名，除了方向相反，使用公钥把plaintext转成ciphertext，但是要
使用私钥把ciphertext转成plaintext</p>

<p>一个</p>

<p>大多数非对称加密模式都限制能加密的消息大小到一个很低的数字以下。</p>

<hr />

<p>非对称加密</p>

<p>使用 RSAES-OAEP（RSA加密，使用Optimal Asymmeric Encryption Padding）</p>

<p>使用2048-bit的RSA key，以65537为幂底数，SHA256和MGF1-SHA256</p>

<p>不要使用 PCKS v1.5 padding</p>

<p>不要使用不带消息padding的RSA</p>

<p>生成一个随机key，用这个key使用对称加密加密你的消息，然后使用非对称加密算法加密你的key</p>

<p>小心避免RSAES-OAEP的timing攻击通道</p>

<hr />

<p>密码</p>

<p>密码通常被直接用于识别，但是也可以被用于加密或者认证。</p>

<p>实践：</p>

<p>尽可能避免密码</p>

<p>使用一个key继承函数，来尽快把密码转成key。</p>

<p>使用PBKDF2，如果你跟随流行趋势</p>

<p>使用scrypt，如果你希望2<sup>8</sup>倍地比严肃的攻击者更安全</p>

<p>想都不要想把用户的密码存储在服务器上。绝对不能，就算它们被加密了也不能。</p>

<hr />

<p>SSL</p>

<p>SSL是一个可怕的系统</p>

<p>SSL的复杂性导致它很难别安全地实现</p>

<p>SSL给了攻击者很多攻击选项</p>

<p>SSL要求你决定你想信任什么CA</p>

<p>你相信中国政府吗？</p>

<p>不幸的是，SSL是唯一可行的选项</p>

<p>实践：</p>

<p>随客户端分发非对称签名key，并且使用这个key开始你的整个密码系统</p>

<p>使用SSL加密你的网站，Email，和其他公开的标准面向Internet的服务器。</p>

<p>认真地想想你信任哪些CA。</p>

<hr />

<p>奇奇怪怪地部分：</p>

<p>咨询一个密码学专家，如果</p>

<p>你的密码学硬件设备，攻击者可以物理接触到。（例如smartcards）</p>

<p>你想使用最少的电力消耗（例如在手机上）</p>

<p>你需要处理尽可能大的数据流量（例如 10Gbps的 IPSec 隧道）</p>

<p>你需要传输尽可能少的bit（例如和一个核潜艇的通信）</p>

<p>你想忽视我在这个talk中提出的任何建议</p>

<hr />

<p>QA</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSL/TLS CipherSuite 介绍]]></title>
    <link href="https://blog.helong.info//blog/2015/01/23/ssl_tls_ciphersuite_intro/"/>
    <updated>2015-01-23T14:30:00+00:00</updated>
    <id>https://blog.helong.info//blog/2015/01/23/ssl_tls_ciphersuite_intro</id>
    <content type="html"><![CDATA[<p>本文是关于SSL/TLS的 CipherSuite 的信息摘录，翻译。如有疑问，欢迎指出。</p>

<a name="L......CipherSuite........."></a>
<h2>一，CipherSuite的概念</h2>

<p>CipherSuite 这个名词目前没看到有好的中文翻译，个人觉得翻译成“加密算法套件”比较合适。Cipher泛指是密码学的加密算法，例如 aes, rsa, ecdh 等。
tls是由各类基础算法，作为原语组合而成。
一个CipherSuite是4个算法的组合：</p>

<ol>
<li>1个authentication (认证)算法</li>
<li>1个encryption(加密)算法</li>
<li>1个message authentication code (消息认证码 简称MAC)算法</li>
<li>1 个key exchange(密钥交换)算法</li>
</ol>


<!--more-->


<a name="L......CipherSuite..............."></a>
<h2>二，CipherSuite的注册管理</h2>

<p>TLS Cipher Suite  在 iana 集中注册，每一个CipherSuite分配有 一个2字节的数字用来标识 ：
可以在 iana的网页查看：
 <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4</a>
例如:</p>

<pre><code>0x00,0x2F   TLS_RSA_WITH_AES_128_CBC_SHA    Y   [RFC5246]
0x00,0x30   TLS_DH_DSS_WITH_AES_128_CBC_SHA Y   [RFC5246]
0x00,0x31   TLS_DH_RSA_WITH_AES_128_CBC_SHA Y   [RFC5246]
0x00,0x32   TLS_DHE_DSS_WITH_AES_128_CBC_SHA    Y   [RFC5246]
0x00,0x33   TLS_DHE_RSA_WITH_AES_128_CBC_SHA    Y   [RFC5246]
0x00,0x34   TLS_DH_anon_WITH_AES_128_CBC_SHA    Y   [RFC5246]
0x00,0x35   TLS_RSA_WITH_AES_256_CBC_SHA    Y   [RFC5246]
0x00,0x36   TLS_DH_DSS_WITH_AES_256_CBC_SHA Y   [RFC5246]
0x00,0x37   TLS_DH_RSA_WITH_AES_256_CBC_SHA Y   [RFC5246]
0x00,0x38   TLS_DHE_DSS_WITH_AES_256_CBC_SHA    Y   [RFC5246]
0x00,0x39   TLS_DHE_RSA_WITH_AES_256_CBC_SHA    Y   [RFC5246]
0x00,0x3A   TLS_DH_anon_WITH_AES_256_CBC_SHA    Y   [RFC5246]
0x00,0x3B   TLS_RSA_WITH_NULL_SHA256    Y   [RFC5246]
0x00,0x3C   TLS_RSA_WITH_AES_128_CBC_SHA256 Y   [RFC5246]
0x00,0x3D   TLS_RSA_WITH_AES_256_CBC_SHA256 Y   [RFC5246]
0x00,0x3E   TLS_DH_DSS_WITH_AES_128_CBC_SHA256  Y   [RFC5246]
0x00,0x3F   TLS_DH_RSA_WITH_AES_128_CBC_SHA256  Y   [RFC5246]
</code></pre>

<p>例如其中的：
<code>
0x00,0x37   TLS_DH_RSA_WITH_AES_256_CBC_SHA Y   [RFC5246]
</code></p>

<p>这一条，
0x00,0x37 这个 value 就是  TLS_DH_RSA_WITH_AES_256_CBC_SHA 这个 Cipher Suite的数字，rfc5246 定义了这个CipherSuite的具体实现。</p>

<a name="L......CipherSuite........................"></a>
<h2>三，CipherSuite在现实环境的应用</h2>

<p>tls/ssl 一共出过 5个版本：ssl2/ssl3/tls1.0/tls1.1/tls1.2 ，ssl2/ssl3这两个版本漏洞太多，请务必禁用。</p>

<p>tls1.2，当前(2015年)最新的tls协议，定义在：rfc5246</p>

<p>tls协议的实现有多种，如openssl, gnutls, nss, libressl, cyassl, polarssl, botan等等。</p>

<p>openssl的代码算是其中最混乱的，但是也是最久经考验的。
( 请参见此打脸文： <a href="http://blog.csdn.net/dog250/article/details/24552307">http://blog.csdn.net/dog250/article/details/24552307</a> )</p>

<p>个人觉得polarssl和botan的架构最清晰，代码风格清新可爱，便于学习理解协议（但是不建议在生产环境下用，例如polarssl功能尚有欠缺）。</p>

<a name="L1................"></a>
<h3>1.服务器端：</h3>

<p>说说openssl，openssl 实现了以上列表中的大部分( 摒弃了不安全的一些CipherSuite)。</p>

<p>openssl 支持的 cipher 列表，可以用  openssl  ciphers -V  | column -t 命令查看
输出如：</p>

<pre><code>0xC0,0x30  -  ECDHE-RSA-AES256-GCM-SHA384    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(256)    Mac=AEAD
0xC0,0x2C  -  ECDHE-ECDSA-AES256-GCM-SHA384  TLSv1.2  Kx=ECDH        Au=ECDSA  Enc=AESGCM(256)    Mac=AEAD
0xC0,0x28  -  ECDHE-RSA-AES256-SHA384        TLSv1.2  Kx=ECDH        Au=RSA    Enc=AES(256)       Mac=SHA384
0xC0,0x24  -  ECDHE-ECDSA-AES256-SHA384      TLSv1.2  Kx=ECDH        Au=ECDSA  Enc=AES(256)       Mac=SHA384
0xC0,0x14  -  ECDHE-RSA-AES256-SHA           SSLv3    Kx=ECDH        Au=RSA    Enc=AES(256)       Mac=SHA1
0xC0,0x0A  -  ECDHE-ECDSA-AES256-SHA         SSLv3    Kx=ECDH        Au=ECDSA  Enc=AES(256)       Mac=SHA1
0x00,0xA5  -  DH-DSS-AES256-GCM-SHA384       TLSv1.2  Kx=DH/DSS      Au=DH     Enc=AESGCM(256)    Mac=AEAD
0x00,0xA1  -  DH-RSA-AES256-GCM-SHA384       TLSv1.2  Kx=DH/RSA      Au=DH     Enc=AESGCM(256)    Mac=AEAD
0x00,0x9F  -  DHE-RSA-AES256-GCM-SHA384      TLSv1.2  Kx=DH          Au=RSA    Enc=AESGCM(256)    Mac=AEAD
0x00,0x6B  -  DHE-RSA-AES256-SHA256          TLSv1.2  Kx=DH          Au=RSA    Enc=AES(256)       Mac=SHA256
0x00,0x69  -  DH-RSA-AES256-SHA256           TLSv1.2  Kx=DH/RSA      Au=DH     Enc=AES(256)       Mac=SHA256
0x00,0x68  -  DH-DSS-AES256-SHA256           TLSv1.2  Kx=DH/DSS      Au=DH     Enc=AES(256)       Mac=SHA256
0x00,0x39  -  DHE-RSA-AES256-SHA             SSLv3    Kx=DH          Au=RSA    Enc=AES(256)       Mac=SHA1
0x00,0x37  -  DH-RSA-AES256-SHA              SSLv3    Kx=DH/RSA      Au=DH     Enc=AES(256)       Mac=SHA1
</code></pre>

<p>每一行里：</p>

<ol>
<li>第1个字段是 这个CipherSuite的value，</li>
<li>第2个字段是 CipherSuite 的名字 ，</li>
<li>第3个字段是本Cipher Suite是用于哪个 SSL/TLS版本的协议，</li>
<li>第4个字段 Kx 是 key exchange 算法</li>
<li>第5个字段 Au 是 authentication 算法</li>
<li>第6个字段Enc是 encryptation算法</li>
<li>第7个字段 Mac 是 MAC 算法，用于创建消息摘要</li>
</ol>


<p>例如:</p>

<pre><code>0xC0,0x23  -  ECDHE-ECDSA-AES128-SHA256      TLSv1.2  Kx=ECDH        Au=ECDSA  Enc=AES(128)       Mac=SHA256
</code></pre>

<p>这一行，表示：</p>

<ul>
<li> 名字为 ECDH-ECDSA-AES128-SHA256  的CipherSuite ，用于 TLSv1.2版本，</li>
<li> 使用 ECDH做密钥交换，</li>
<li> 使用ECDSA做认证，</li>
<li> 使用AES-128做加密算法，</li>
<li> 使用SHA256做MAC算法。</li>
</ul>


<p>一个CipherSuite，在 openssl 库里用这个结构体表示:</p>

<pre><code class="cpp">/* used to hold info on the particular ciphers used */
struct ssl_cipher_st {
    int valid;
    const char *name;           /* text name */
    unsigned long id;           /* id, 4 bytes, first is version */
    /*
     * changed in 0.9.9: these four used to be portions of a single value
     * 'algorithms'
     */
    unsigned long algorithm_mkey; /* key exchange algorithm */
    unsigned long algorithm_auth; /* server authentication */
    unsigned long algorithm_enc; /* symmetric encryption */
    unsigned long algorithm_mac; /* symmetric authentication */
    unsigned long algorithm_ssl; /* (major) protocol version */
    unsigned long algo_strength; /* strength and export flags */
    unsigned long algorithm2;   /* Extra flags */
    int strength_bits;          /* Number of bits really used */
    int alg_bits;               /* Number of bits for algorithm */
};
</code></pre>

<p>以上4个算法，对应其中的下面四行：</p>

<pre><code class="cpp">     unsigned long algorithm_mkey;   /* key exchange algorithm */
     unsigned long algorithm_auth;   /* server authentication */
     unsigned long algorithm_enc;    /* symmetric encryption */
     unsigned long algorithm_mac;    /* symmetric authentication */
</code></pre>

<a name="L2..............."></a>
<h3>2，客户端：</h3>

<p>在浏览器里面，可以这样查看当前使用的CipherSuite:
Firefox下打开gmail，点击地址栏左侧锁图标</p>

<a name="L3..............CipherSuite"></a>
<h3>3. 如何指定CipherSuite</h3>

<p>在tls中，选择CipherSuite的方法是通过cipher list</p>

<p>格式和用法见：<a href="https://www.openssl.org/docs/apps/ciphers.html">https://www.openssl.org/docs/apps/ciphers.html</a></p>

<p>nginx里面的配置项是  cipher_list</p>

<p>cipher list 的格式是：</p>

<p>一个cipher list 包含一个或者多个由冒号分隔的cipher string( 逗号和空格也可以接受但不常用)。</p>

<p>一个cipher string可以是下列形式之一:</p>

<p>(1).可以由单个cipher suite构成，例如  RC4-SHA。</p>

<p>(2).它可以表示含有某个特定算法的cipher列表，或者一种特定类型的cipher suite。例如， SHA1表示所有使用摘要算法SHA1的cipher suite, SSLV3表示所有SSL V3算法。</p>

<p>(3).cipher suite的列表,可以使用加号+ 合并到一个单一的cipher string里面。这被作为一个逻辑且操作。例如，SHA1+DES表示所有包含了 SHA，并且包含了DES的算法。</p>

<p>(4).每一个cipher string可以在前面加上字符 !,-,或者+</p>

<p>如果加了!，那么这种cipher永久从列表里面删除，就算后边显式添加进来也不行。</p>

<p>如果加了-，那么cipher中的一些或者全部可以在后面的选项里面加回来。</p>

<p>如果加了+，那么cipher被移动到列表的最后，这个选项不增加任何cipher，只是把匹配的cipher移动到最后。</p>

<p>如果没有上述字符，那么字符串被解析成一个cipher list，追加到当前配置列表的后面。如果cipher list 中的某些cipher已经存在了，就忽略该cipher。</p>

<p>(5).另外，cipher string @STRENGTH 可以用在任何点，用来把当前cipher list按照加密算法key长度排序。</p>

<p>当前建议的配置参数可以看看mozilla的这个文档：<a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations">https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations</a></p>

<a name="L......CipherSuite.................."></a>
<h2>四，CipherSuite的进化与现状</h2>

<p>随着密码学的发展，硬件性能的提高，加密和破解的不断对抗博弈，常用的算法也在不断进化，旧的算法被破解，新的算法诞生。</p>

<p>CipherSuite的当前流行趋势：</p>

<p>authentication (认证)算法 ：常见的有 RSA/DSA/ECDSA 3种，目前最主流的是人民群众喜闻乐见，妇孺皆知的RSA ( 2048 bit及以上)， （ECDSA 是新兴趋势，例如gmail，facebook都在迁移到ECDSA，当然目前用的还不多，DSA 由于只能提供1024bit，已经没啥人敢用）。</p>

<p>加密算法：主流趋势是使用 aes，128/256 bit都可以，加密模式的趋势是使用gcm，cbc由于被发现有 BEAST 攻击等，比较难以正确使用，至于ecb模式，请勿使用。加密算法 还有RC4（不建议使用），3DES（不建议使用），Camellia(貌似日本人搞的) ，DES(已经被淘汰)等，</p>

<p>message authentication code (消息认证码 简称MAC)算法 ，主流有 sha256,sha384,sha1,等。tls中使用了HMAC模式，而不是原始的 sha256,sha1等。google已经在淘汰MD5了。（gcm是一种特殊的称为aead的加密模式，不需要配合MAC。）</p>

<p>key exchange(密钥交换)算法：主流有两种：DH和ECDH，自从斯诺登爆料了NSA的https破解方案以后，现在的 key exchange(密钥交换)算法，普遍流行 PFS，把DH, ECDH变成 DHE，ECDHE 。</p>

<p>mozilla目前推荐的 cipher list：</p>

<pre><code>ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
</code></pre>

<p>mozilla的优先级选择考虑：</p>

<p>1.ECDHE+AESGCM最先选，目前没有已知漏洞。</p>

<p>2.PFS ciphersuite优先，其中ECDHE优先于DHE</p>

<p>3.SHA256优先于SHA1。完全禁用MD5。</p>

<p>4.AES 128优先于AES 256。这个问题有一些讨论。</p>

<p>5.在向后兼容模式中，AES优先于3DES。</p>

<p>6.完全禁止RC4。3DES只用于兼容老版本。</p>

<p>cloudflare的ssl cipher list配置：</p>

<p><a href="https://github.com/cloudflare/sslconfig/blob/master/conf">https://github.com/cloudflare/sslconfig/blob/master/conf</a></p>

<p>google的一篇文章解释当前cipher suite的流行趋势
<a href="http://googleonlinesecurity.blogspot.com.au/2013/11/a-roster-of-tls-cipher-suites-weaknesses.html">http://googleonlinesecurity.blogspot.com.au/2013/11/a-roster-of-tls-cipher-suites-weaknesses.html</a></p>

<p>google在密码学方面的最新进展可以在这个博客追踪：<a href="http://googleonlinesecurity.blogspot.com/">http://googleonlinesecurity.blogspot.com/</a></p>
]]></content>
  </entry>
  
</feed>
