
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Tech Ideas</title>
  <meta name="author" content="byronhe">

  
  <meta name="description" content="一，问题背景 随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。 机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。 1.常见的特征工程逻辑 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://blog.helong.info//">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Tech Ideas" type="application/atom+xml">
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-49290834-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Tech Ideas</a></h1>
  
    <h2>C++,Linux,Algorithm,Crypto,Lisp,etc</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="blog.helong.info/">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/">Python 自动翻译成 C++ ，彻底保证离线在线特征一致</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-11-29T13:54:00+00:00'><span class='date'>2019-11-29</span> <span class='time'>1:54 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<a name="L.................."></a>
<h1>一，问题背景</h1>

<p>随着深度学习的广泛应用，在搜索引擎/推荐系统/机器视觉等业务系统中，越来越多的深度学习模型部署到线上服务。</p>

<p>机器学习模型在离线训练时，一般要将输入的数据做特征工程预处理，再输入模型在 TensorFlow PyTorch 等框架上做训练。</p>

<a name="L1............................"></a>
<h3>1.常见的特征工程逻辑</h3>

<p>常见的特征工程逻辑有：
1. 分箱/分桶 离散化
1. log/exp 对数/幂等 math numpy 常见数学运算
1. 特征缩放/归一化/截断
1. 交叉特征生成
1. 分词匹配程度计算
1. 字符串分隔匹配判断tong
1. 缺省值填充等
1. 数据平滑
1. onehot 编码，hash 编码等</p>

<p>这些特征工程代码，当然一般使用深度学习最主要的语言 <strong>python</strong> 实现。</p>

<a name="L.................."></a>
<h1>二，业务痛点</h1>

<p>离线训练完成，模型上线部署后，同样要<strong>用 C++ 重新实现</strong> 这些 python 的特征工程逻辑代码。</p>

<p>我们发现，<strong>“用 C++ 重新实现”</strong> 这个步骤，给实际业务带来了大量的问题：</p>

<ol>
<li>繁琐，费时费力，极容易出现 python 和 C++ 代码<strong>不一致</strong></li>
<li><strong>不一致</strong>会直接影响模型在线上的效果，导致大盘业务指标不如预期，产生各种 bad case</li>
<li><strong>不一致</strong>难以发现，无法测试，无法监控，经常要靠用户投诉反馈，甚至大盘数据异常才能发现</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/">用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-11-25T12:34:00+00:00'><span class='date'>2019-11-25</span> <span class='time'>12:34 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<a name="L.................."></a>
<h2>一，问题背景</h2>

<p>中文分词应用比较广泛的开源算法，是 <a href="https://github.com/fxsjy/jieba">jieba 结巴分词</a>，结巴分词较高性能的实现是 C++ 版本的 CppJieba :
<a href="https://github.com/yanyiwu/cppjieba">https://github.com/yanyiwu/cppjieba</a></p>

<p>在实际使用 CppJieba 的过程中，我们发现 CppJieba 的内存占用比较高。</p>

<p>比如对一个 76W 词 大小 11MB 的词典 ，加载 2份 （比如为了支持平滑改动用户词典）就需要耗费 505MB内存。</p>

<p>这对一些多进程的后台服务，浪费大量内存，难以接受，因此这里希望削减内存耗费。</p>

<p>经过初步调查，确定改进方法，然后动手改造，<strong>最终把 505MB 缩减到了 4.7MB ，实现了 99% 内存降低</strong>。</p>

<p>此处也有 issue 讨论 <a href="https://github.com/yanyiwu/cppjieba/issues/3">https://github.com/yanyiwu/cppjieba/issues/3</a></p>

<p>代码稍后可能会开源出来。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2019/09/18/newwords_discovery/">GB 规模语料上的高性能新词发现算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2019-09-18T22:19:00+00:00'><span class='date'>2019-09-18</span> <span class='time'>10:19 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<p>分词是中文搜索的重要环节，目前分词算法已经比较成熟，分词错误的主要是由于未登录词。</p>

<p>因此发现业务领域语料库中的新词，减少未登录词，对改善搜索引擎的用户体验有重要意义。</p>

<p>新词发现的一种常用算法，是 matrix67 大神 2012 年提出的 《互联网时代的社会语言学：基于SNS的文本数据挖掘》
<a href="https://www.matrix67.com/blog/archives/5044">https://www.matrix67.com/blog/archives/5044</a></p>

<p>其主要思路，是统计语料中出现的所有 ngram 子字符串的凝固度，自由度，信息熵。</p>

<p>算法中需要统计所有 ngram 子字符串的 左熵右熵，实现该算法时，一般以子字符串为 key，用哈希表来存。</p>

<p>但随着语料库变大时，内存消耗变大，</p>

<p>比如之前的 python 版本实现，对 200MB 的语料，就需要约 30G 内存来存哈希表，</p>

<p>导致单机内存不足无法运行，而且对这样规模的语料库，算法需要跑一两天才能出结果。</p>

<p>这里我应用一些工程实现方面的技巧，
把用哈希表统计左熵右熵的计算，拆分成多个子哈希表，分批计算，并利用多核并行，大幅度优化了算法的性能。</p>

<p>最终实现了 GB 大小语料上的新词发现，并把运行时间缩减到了 30 分钟左右 。</p>

<p><a href="https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB">https://github.com/hankcs/HanLP/wiki/%E6%96%B0%E8%AF%8D%E8%AF%86%E5%88%AB</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-06T22:32:55+00:00'><span class='date'>2015-09-06</span> <span class='time'>10:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近发现密码学很有意思，刚好还和工作有点关系，就研究了一下，本文是其中一部分笔记和一些思考。</p>

<p><strong>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</strong></p>

<p><strong>本文禁止转载</strong></p>

<p>本文目标：</p>

<ol>
<li>学习鉴赏TLS协议的设计，透彻理解原理和重点细节</li>
<li>跟进一下密码学应用领域的历史和进展</li>
<li>整理现代加密通信协议设计的一般思路</li>
</ol>


<p>本文有门槛，读者需要对现代密码学有清晰而系统的理解，建议花精力补足背景知识再读。本文最后的参考文献里有一些很不错的学习资料。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/05/modern-crypto/">现代密码学实践指南[2015年]</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-05T22:32:55+00:00'><span class='date'>2015-06-05</span> <span class='time'>10:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<p>本文介绍目前现代密码学的最先进技术，
前半部分主要翻译自  <a href="https://gist.github.com/tqbf/be58d2d39690c3b366ad">《Cryptographic Right Answers》</a>，附上收集的资料，和byron个人的理解。</p>

<p>密码学理论艰深，概念繁多，本人知识水平有限，错误难免，如果您发现错误，请务必指出，非常感谢!</p>

<hr />

<a name="L...................................................................................."></a>
<h5>下文分类介绍在各种适用场景下，你应该使用的现代密码学算法</h5>

<a name="L1....strong...............strong..:"></a>
<h3>1.  <strong>加密数据</strong> :</h3>

<p>按照优先级，应该选择:</p>

<p>(1)   首选 NaCl库，或者libsodium库，使用里面的crypto_secretbox()/crypto_secretbox_open() 函数
(2)   Chacha20-Poly1305 算法
(3)   AES-GCM 算法</p>

<p>适用场景:当你需要避免把明文数据在网络上传输的时候。</p>

<p>以上3种算法，都是AEAD类的算法，AEAD是2015年最好的选择。
其中的(2)和(3)在结构上类似：一个流加密模式的算法，配合一个多项式结构的MAC。
(2)是一个流加密算法，配合一个为通用cpu优化的MAC算法，
对密码学库的实现者来说，Poly1305也比GCM更容易安全地实现。
AES-GCM是工业标准(TLS目前主要用的就是AES-GCM)，现代CPU通常都有专门为AES-GCM设计的硬件指令，但是在没有硬件指令支持的CPU上(比如32位的arm)，(3)性能低于(2)。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/06/05/modern-crypto/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/08/https-config-optimize-in-nginx/">Nginx下配置高性能，高安全性的https TLS服务</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-08T20:32:55+00:00'><span class='date'>2015-05-08</span> <span class='time'>8:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>下文以nginx为例，介绍如何部署一个高性能，高安全性的https服务器。</p>

<p>并附送一个优化出来的openssl编译脚本，可以编译出一个高性能，高安全性的openssl库，您可以直接复制粘贴使用。</p>

<p>此处直接给出实践指导，后续再写文章解释tls协议的这些原理细节。</p>

<p>nginx下https配置的优化点，主要有:</p>

<ol>
<li>session ticket</li>
<li>session id cache</li>
<li>ocsp stapling</li>
<li>http KeepAlive</li>
<li>ECDHE等ciphersuite优化</li>
<li>openssl 编译优化</li>
</ol>


<a name="L.......nginx.https........."></a>
<h3>一， nginx https的配置</h3>

<p>先贴一下nginx配置，如下。</p>

<p>是根据<a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Nginx">mozilla的权威文档</a>
,和<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">生成工具</a>(选择 nginx，intermediate ) 生成的配置为基础，加入session ticket等配置的结果</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/05/08/https-config-optimize-in-nginx/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour/">【翻译】密码学一小时必知</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-12T14:05:55+00:00'><span class='date'>2015-04-12</span> <span class='time'>2:05 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文翻译了Colin Percival 于2010年在bsdcan的演讲ppt</p>

<p>原文标题：Everything you need to know about cryptography in 1 hour</p>

<p>演讲时间：May 13, 2010</p>

<p>原文在 <a href="https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf">https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf</a></p>

<p>演讲视频在 <a href="https://www.youtube.com/watch?v=jzY3m5Kv7Y8">https://www.youtube.com/watch?v=jzY3m5Kv7Y8</a> ( 请自行翻墙 )</p>

<p>Colin Percival 是密码学方面的专家，FreeBSD项目的安全长官，Tarsnap在线备份服务的创始人，scrypt密钥衍生算法的作者，致力于改进软件中密码学的应用，向程序员传播密码学的正确使用。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/04/12/translate-Everything-you-need-to-know-about-cryptgraphy-in-1-hour/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/13/jump_consistent_hash/">【翻译/介绍】jump Consistent hash:零内存消耗，均匀，快速，简洁，来自Google的一致性哈希算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-13T10:05:55+00:00'><span class='date'>2015-03-13</span> <span class='time'>10:05 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><a name="L......"></a>
<h2>简介</h2>

<p>jump consistent hash是一种一致性哈希算法, 此算法<strong>零内存消耗</strong>，<strong>均匀分配</strong>，<strong>快速</strong>，并且<strong>只有5行代码</strong>。</p>

<p>此算法适合使用在分shard的分布式存储系统中 。</p>

<p>此算法的作者是 Google 的 John Lamping 和 Eric Veach，论文原文在 <a href="http://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf">http://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</a></p>

<p>完整代码：</p>

<figure class='code'><figcaption><span>JumpConsistentHash</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int32_t</span> <span class="nf">JumpConsistentHash</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">num_buckets</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_buckets</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">b</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">*</span> <span class="mi">2862933555777941757ULL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">/</span> <span class="kt">double</span><span class="p">((</span><span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="mi">33</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输入是一个64位的key，和桶的数量（一般对应服务器的数量），输出是一个桶的编号。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/03/13/jump_consistent_hash/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/23/ssl_tls_ciphersuite_intro/">SSL/TLS CipherSuite 介绍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-23T14:30:00+00:00'><span class='date'>2015-01-23</span> <span class='time'>2:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文是关于SSL/TLS的 CipherSuite 的信息摘录，翻译。如有疑问，欢迎指出。</p>

<a name="L......CipherSuite........."></a>
<h2>一，CipherSuite的概念</h2>

<p>CipherSuite 这个名词目前没看到有好的中文翻译，个人觉得翻译成“加密算法套件”比较合适。Cipher泛指是密码学的加密算法，例如 aes, rsa, ecdh 等。
tls是由各类基础算法，作为原语组合而成。
一个CipherSuite是4个算法的组合：</p>

<ol>
<li>1个authentication (认证)算法</li>
<li>1个encryption(加密)算法</li>
<li>1个message authentication code (消息认证码 简称MAC)算法</li>
<li>1 个key exchange(密钥交换)算法</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/01/23/ssl_tls_ciphersuite_intro/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/27/mock-c-plus-plus-function-for-unit-test/">Mock C++ Function for Unit Test</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-27T10:05:55+00:00'><span class='date'>2014-03-27</span> <span class='time'>10:05 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在单元测试中，我们需要提供业务逻辑的mock版本，
当业务逻辑实现为C++的virtual function时，这是很容易的，我们只需要写一个子类，
实现virtual function就行了，Google 的 gmock就针对这种情况设计。</p>

<p>可是，如果遗留代码中有一般C函数，非virtual的类成员函数，模板函数，inline函数，如何提供mock版本呢？</p>

<p>下面的代码用一点trick实现了上述函数的运行时mock。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/03/27/mock-c-plus-plus-function-for-unit-test/">继续阅读/Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2019/11/29/pthran-py-to-cpp-translater-in-feature-engineering/">Python 自动翻译成 C++ ，彻底保证离线在线特征一致</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/11/25/cppjieba-darts-DAT-memory_optimize/">用 DAT 重实现 CppJieba 中文分词算法，降低 99% 内存消耗</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/09/18/newwords_discovery/">GB 规模语料上的高性能新词发现算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/05/modern-crypto/">现代密码学实践指南[2015年]</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/byronhe">@byronhe</a> on GitHub
  
  <script type="text/javascript">

    //$(document).ready(function(){
    document.addEventListener("DOMContentLoaded", function(event) { 
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'byronhe',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script async src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - byronhe -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
    <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
  <script async >!window.jQuery && document.write(unescape('%3Cscript async  src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script async  src="/javascripts/octopress.js" type="text/javascript"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-49290834-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>




<script type="text/javascript">
      var disqus_shortname = 'byronheblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










<script src="//s95.cnzz.com/z_stat.php?id=1256308650&web_id=1256308650" language="JavaScript"></script>

<script src="/javascripts/jquery.tableofcontents.min.js" type="text/javascript"></script>
<script src="/javascripts/toc-generator.js" type="text/javascript"></script>




</body>
</html>
